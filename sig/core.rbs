FUNC_MAP: ::Hash[Symbol, untyped]

FuncMapEntry: untyped

NOTHING_TYPE: TypeName

BOOL_TYPE: TypeName

VECTOR_TYPE: TypeName

MAP_TYPE: TypeName

LIST_TYPE: TypeName

FUNCTION_TYPE: TypeName

INTEGER_TYPE: TypeName

FLOAT_TYPE: TypeName

SET_TYPE: TypeName

TYPE_NAME_TYPE: TypeName

STRING_TYPE: TypeName

SYMBOL_TYPE: TypeName

BOX_TYPE: TypeName

RATIO_TYPE: TypeName

ERROR_TYPE: TypeName

CHAR_TYPE: TypeName

KEYWORD_TYPE: TypeName

# ALIAS_TYPE = TypeName.new "::alias", 17
DELAY_TYPE: TypeName

GENSYM_CNT: ::Array[Integer]

class Object
  def find_fn: (untyped func_name, untyped type_name) -> untyped

  def def_generic_fn: (Symbol func_name, untyped fallback) -> untyped

  def type_of: (untyped x) -> untyped

  def type_id_of: (untyped x) -> untyped

  def lyra_eq?: (untyped x, untyped y) -> untyped

  def elem_to_s: (untyped e) -> untyped

  def elem_to_pretty: (untyped e) -> untyped

  def eager: (untyped x) -> untyped

  def lyra_buildin_eq?: (untyped x, untyped y) -> untyped

  def gensym: (Symbol|String x) -> Symbol

  def div: (untyped x, untyped y) -> untyped

  def rem: (untyped x, untyped y) -> untyped

  def truthy?: (untyped x) -> untyped

  def string_to_chars: (untyped s) -> untyped

  def apply_op_to_list: (untyped xs) { (untyped, untyped) -> untyped } -> bool

  def setup_add_fn: (Symbol name, Integer min_args, ?Integer max_args) { () -> untyped } -> Env

  def setup_add_fn_with_env: (Symbol name, Integer min_args, ?Integer max_args) { () -> untyped } -> Env

  def setup_add_var: (Symbol name, untyped value) -> Env

  # Sets up the core functions and variables. The functions defined here are
  # of the type NativeLyraFn instead of LyraFn. They can not make use of tail-
  # recursion and are supposed to be very simple.
  def setup_core_functions: () -> true
end
