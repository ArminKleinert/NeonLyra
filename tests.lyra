(module tests
  ((run-tests run-all-tests))

(load! "core/random.lyra")
(load! "core/sort.lyra")
(load! "core/aliases.lyra")

(define (all-true? & cases)
  (all? id cases))

(define (crash!)
  (/ 0 0))

(define (test-lambda)
  (let* ((f (lambda (n) n))
         (fr (f 6)))
    (all-true?
      (= 2 ((lambda (n) (+ n n)) 1))
      (< 2 ((lambda (n) (+ n n)) 2))
      (= 2 ((lambda (n) n) 2))
      ((lambda (n) #t) 2)
      (= (f 2) 2) 
      (= (f 2) 2) 
      (= (f 2) 2)
      (= fr 6)))

  (let* ((f (λ n . n))
         (fr (f 6)))
    (all-true?
      (= 2 ((λ n . (+ n n)) 1))
      (< 2 ((λ n . (+ n n)) 2))
      (= 2 ((λ n . n) 2))
      ((λ n . #t) 2)
      (= (f 2) 2) 
      (= (f 2) 2) 
      (= (f 2) 2)
      (= fr 6))))

(define (test-cond)
  (all-true?
    (= 3 (cond (#f 0) (#f 1) (#f 2) (#t 3)))
    (cond (#f 0) (#f 1) (#f 2) (else #t))
    (cond (#t #t) (else (crash!)))))

(define (test-if)
  (all-true?
    (if #f #f #t)
    (if #t #t #f)
    (= 2 (if #t 2 3))
    (= 3 (if #f 2 3))))

(define (test-spread)
  (all-true?
    (eq? '(1 2 3) (spread '(1 2 (3))))
    (eq? '(1 2 3) (spread '((1 2 3))))
    (eq? '((1) 1 2 3) (spread '((1) (1 2 3))))))

(define (test-apply)
  (all-true?
    (eq? [[1] [2]] (concat [[1] [2]]))
    (eq? [1 2] (apply concat [[1] [2]]))
    (eq? '(0 (1) (2)) (concat '(0) '((1) (2))))
    (eq? '(0 1 2) (apply concat '(0) (list (list 1) (list 2))))
    (eq? 20 (apply v+ 1 2 3 '(2 3 4 5)))
    (eq? 15 (apply v+ '(1 2 3 4 5)))))

(define (test-quote)
  (quote (/ 9 0))
  (quote (crash!))
  (all-true?
    (symbol? (quote a))
    (symbol? 'a)
    (string? '"abc")
    (list? '(1 2 3))))

(define (test-gensym)
  (all-true?
    (/= (gensym) (gensym))
    (/= (gensym) (gensym))
    (/= (gensym) (gensym))
    (/= (gensym) (gensym))
    (/= (gensym) (gensym))
    (/= (gensym) (gensym))
    (/= (gensym) (gensym))
    (symbol? (gensym))))

(define (test-seq)
  (all-true?
    (nothing? (seq 1))
    (nothing? (seq 'a))
    (nothing? (seq "abc"))
    (nothing? (seq 99.5))
    (nothing? (seq (lazy 6)))
    (nothing? (seq '()))
    (sequence? (seq (list 1 2 3 4 5)))
    (sequence? (seq (vector 1 2 3 4 5)))))

; If this does not crash, then we know that the expression was not evaluated.
(define (test-lazy-crash)
  ((lambda (x y) (lazy (/ x y))) 0 0) 
  (lazy (crash!)))

(define (test-lazy)
  (all-true?
    (lazy #f)
    (lazy #t)
    (eager (lazy #t))))

(define (test-eager)
  (all-true?
    (not (eager (lazy #f)))
    (eager (lazy #t))))

(define (test-partial)
  (all-true?
    (= ((partial + 0) 5) (+ 0 5))
    (= ((partial foldl + 0) (list 1 2 3 4 5))
        (foldl + 0 (list 1 2 3 4 5)))))

(define (test-nothing)
  (all-true?
    (nothing? (nothing 1))
    (nothing? (nothing 'a))
    (nothing? (nothing "abc"))
    (nothing? (nothing 99.5))
    (nothing? (nothing (lazy 6)))
    (nothing? (nothing '()))
    (nothing? (nothing (list 1 2 3 4 5)))
    (nothing? (nothing (vector 1 2 3 4 5)))))

(define (test-box)
  (let1 (b (box 5))
    (all-true?
      (box? b)
      (= (unbox b) 5)
      (int? (unbox b))
      (always-true (box-set! b 16))
      (box? b)
      (= (unbox b) 16)
      (int? (unbox b)))))

(define (test-unbox)
  (let1 (b (box 5))
    (all-true?
      (box? b)
      (= (unbox b) 5)
      (int? (unbox b))
      (always-true (box-set! b 16))
      (box? b)
      (= (unbox b) 16)
      (int? (unbox b)))))

(define (test-set-box)
  (let1 (b (box 5))
    (all-true?
      (box? b)
      (= (unbox b) 5)
      (int? (unbox b))
      (always-true (box-set! b 16))
      (box? b)
      (= (unbox b) 16)
      (int? (unbox b)))))

(def-type unwrappable a b c)

(define (test-unwrap)
    (all-true?
      (= (unwrap (box 5)) 5)
      (nothing? (unwrap Nothing))
      (let ((b (box 5))) (= (unbox b) (unwrap b)))
      (= 5 (unwrap 5))
      (vector-eq? [1 2 3] (unwrap (make-unwrappable 1 2 3)))
      ))

(define (test-read-string)
  (all-true?
    (nothing? (read-string "Nothing"))
    (list? (read-string "(a c b)"))
    (all? symbol? (read-string "(a c b)"))
    (vector? (read-string "[1 2 3 4 5 6]"))
    (boolean? (read-string "#t"))
    (boolean? (read-string "#f"))
    (int? (read-string "1"))
    (float? (read-string "0.7"))))

(define (test-eval)
  (all-true?
    (eval! #t)
    (not (eval! #f))
    (eval! (quote #t))
    (eval! (quote (= 2 2)))))

(define (test-measure)
  (float? (measure! 10 (lambda () #f))))

(define (test-=)
  (all-true?
    (= 1 1)
    (not (= 1 100))
    (= #t #t)
    (not (= #t 100))
    (= #f #f)
    (not (= #f 100))
    (= '() '())
    (not (= '() 100))
    (= [] [])
    (not (= [] 100))
    (= "a" "a")
    (not (= "a" 100))
    (= 's 's)
    (not (= 's 100))
    (= = =)
    (not (= = 100))))

(define (test-/=)
  (all-true?
    (/= 1 100)
    (not (/= 1 1))
    (/= #t 100)
    (not (/= #t #t))
    (/= #f 100)
    (not (/= #f #f))
    (/= '() 100)
    (not (/= '() '()))
    (/= [] 100)
    (not (/= [] []))
    (/= "a" 100)
    (not (/= "a" "a"))
    (/= 's 100)
    (not (/= 's 's))
    (/= = 100)
    (not (/= = =))))

(define (test-<)
  (all-true?
    (< 1 2)
    (< -1 0)
    (< "" "a")
    (< 0.5 1.2)
    (not (< 2 1))
    (not (< 0 -1))
    (not (< "a" ""))
    (not (< 1.2 0.5))
    (not (< 1 1))
    (not (< "" ""))))

(define (test->)
  (all-true?
    (> 2 1)
    (> 0 -1)
    (> "a" "")
    (> 1.2 0.5)
    (not (> 1 2))
    (not (> -1 0))
    (not (> "" "a"))
    (not (> 0.5 1.2))
    (not (> 1 1))
    (not (> "" ""))))

(define (test-<=)
  (all-true?
    (<= 1 2)
    (<= -1 0)
    (<= "" "a")
    (<= 0.5 1.2)
    (not (<= 2 1))
    (not (<= 0 -1))
    (not (<= "a" ""))
    (not (<= 1.2 0.5))
    (<= 1 1)
    (<= "" "")
    
    (≤ 1 2)
    (≤ -1 0)
    (≤ "" "a")
    (≤ 0.5 1.2)
    (not (≤ 2 1))
    (not (≤ 0 -1))
    (not (≤ "a" ""))
    (not (≤ 1.2 0.5))
    (≤ 1 1)
    (≤ "" "")))

(define (test->=)
  (all-true?
    (>= 2 1)
    (>= 0 -1)
    (>= "a" "")
    (>= 1.2 0.5)
    (not (>= 1 2))
    (not (>= -1 0))
    (not (>= "" "a"))
    (not (>= 0.5 1.2))
    (>= 1 1)
    (>= "" "")
    
    (≥ 2 1)
    (≥ 0 -1)
    (≥ "a" "")
    (≥ 1.2 0.5)
    (not (≥ 1 2))
    (not (≥ -1 0))
    (not (≥ "" "a"))
    (not (≥ 0.5 1.2))
    (≥ 1 1)
    (≥ "" "")))

(define (test-+)
  (all-true?
    (= 2 (+ 1 1))
    (= 3 (+ 2 1))
    (= 5 (+ 2 3))
    (= 1 (+ 0.5 0.5))
    (= 1.5 (+ 0.5 1))))

(define (test-v+)
  (all-true?
    (= 1 (v+ 1))
    (= 19 (v+ 1 1 17))
    (= 3 (v+ 2 1))
    (= 5 (v+ 2 3))
    (= 2.5 (v+ 0.5 0.5 0.5 0.5 0.5))
    (= 3 (v+ 0.5 1 0.5 1))))

(define (test-v-)
  (all-true?
    (= -1 (v- 1))
    (= -17 (v- 1 1 17))
    (= 1 (v- 2 1))
    (= -1 (v- 2 3))
    (= -1.5 (v- 0.5 0.5 0.5 0.5 0.5))
    (= -2 (v- 0.5 1 0.5 1))))

(define (test-v*)
  (all-true?
    (= 1 (v* 1))
    (= 17 (v* 1 1 17))
    (= -2 (v* 2 -1))
    (= 6 (v* 2 3))
    (= 0.03125 (v* 0.5 0.5 0.5 0.5 0.5))
    (= 1 (v* 0.5 2 0.5 2))))

(define (test-v/)
  (all-true?
    (= 1 (v/ 1))
    (= 0.125 (v/ 1.0 1 8))
    (= -2.0 (v/ 2 -1.0))
    (= 1.0 (v/ 2 2.0))
    (= 8.0 (v/ 0.5 0.5 0.5 0.5 0.5))
    (= 0.25 (v/ 0.5 2 0.5 2))))

(define (test-v%)
  (all-true?
    (= 2 (v% 2 10 3))
    (= 0.0 (v% 0.5 0.5))
    (= 0.0 (v% 10 2))))

(define (test--)
  (all-true?
    (= 0 (- 1 1))
    (= 1 (- 2 1))
    (= -1 (- 2 3))
    (= 0 (- 0.5 0.5))
    (= -0.5 (- 0.5 1))))

(define (test-*)
  (all-true?
    (= 1 (* 1 1))
    (= 2 (* 2 1))
    (= 6 (* 2 3))
    (= 0.25 (* 0.5 0.5))
    (= 0.5 (* 0.5 1))))

(define (test-/)
  (all-true?
    (= 2 (/ 4 2))
    (= 0 (/ 1 10))
    (= 0.1 (/ 1 10.0))
    (= 2 (/ 1 0.5))
    (= 4 (/ 1 0.25))))

(define (test-rem)
  (all-true?
    (= 0 (rem 4 2))
    (= 1 (rem 1 10))
    (= 1 (rem 1 10.0))
    (= 0 (rem 1 0.5))
    (= 0 (rem 1 0.25))))

(define (test-inc)
  (all-true?
    (= -1 (inc -2))
    (= 0 (inc -1))
    (= 1 (inc 0))
    (= 2 (inc 1))
    (= 3 (inc 2))))

(define (test-dec)
  (all-true?
    (= -3 (dec -2))
    (= -2 (dec -1))
    (= -1 (dec 0))
    (= 0 (dec 1))
    (= 1 (dec 2))))

(define (test-min)
  (all-true?
    (= 0 (min 0 1))
    (= 0 (min 1 0))
    (= 1 (min 1 1))
    (= 0 (min 0 0))
    (= 0 (min 0 1.5))
    (= 0.5 (min 1 0.5))
    (= 1 (min 1 1.5))
    (= 0 (min 0 0.5))
    (= "0" (min "0" "1"))
    (= "0" (min "1" "0"))
    (= "1" (min "1" "1"))
    (= "0" (min "0" "0"))))

(define (test-max)
  (all-true?
    (= 1 (max 0 1))
    (= 1 (max 1 0))
    (= 1 (max 1 1))
    (= 0 (max 0 0))
    (= 1.5 (max 0 1.5))
    (= 1 (max 1 0.5))
    (= 1.5 (max 1 1.5))
    (= 0.5 (max 0 0.5))
    (= "1" (max "0" "1"))
    (= "1" (max "1" "0"))
    (= "1" (max "1" "1"))
    (= "0" (max "0" "0"))))

(define (test-not)
  (all-true?
    (not #f)
    (not (not #t))
    (not (not 1))
    (not (not ""))
    (not (= 1 0))))

(define (test-and)
  (all-true?
    (not (and #f #f))
    (not (and #f #t))
    (not (and #t #f))
    (and #t #t)
    (not (and #f (crash!)))))

(define (test-or)
  (all-true?
    (not (or #f #f))
    (or #f #t)
    (or #t #f)
    (or #t #t)
    (or #t (crash!))))

(define (test-bit-and)
  (all-true?
    (= 0 (bit-and 0 0))
    (= 0 (bit-and 0 255))
    (= 0 (bit-and 255 0))
    (= 255 (bit-and 255 255))))

(define (test-bit-or)
  (all-true?
    (= 0 (bit-or 0 0))
    (= 255 (bit-or 0 255))
    (= 255 (bit-or 255 0))
    (= 255 (bit-or 255 255))))

(define (test-bit-xor)
  (all-true?
    (= 0 (bit-xor 0 0))
    (= 255 (bit-xor 0 255))
    (= 255 (bit-xor 255 0))
    (= 0 (bit-xor 255 255))))

(define (test-bit-shl)
  (all-true?
    (= 1 (bit-shl 1 0))
    (= 0 (bit-shl 0 1))
    (= 256 (bit-shl 1 8))
    (= 512 (bit-shl 1 9))
    (= 510 (bit-shl 255 1))
    (= 1020 (bit-shl 255 2))))

(define (test-bit-shr)
  (all-true?
    (= 1 (bit-shr 1 0))
    (= 0 (bit-shr 0 1))
    (= 0 (bit-shr 255 8))
    (= 0 (bit-shr 255 255))
    (= 63 (bit-shr 255 2))
    (= 127 (bit-shr 255 1))
    (= 255 (bit-shr 255 0))))

(define (test-defined?)
  (all-true?
    (defined? '=)
    (defined? 'foldr1)
    (not (defined? '!!!=!!!))
    (not (defined? 'foldr629))
    (not (defined? =))
    (not (defined? foldr1))))

(define (test-nothing?)
  (all-true?
    (nothing? Nothing)
    (nothing? (nothing))
    (nothing? (nothing 1 2 3))
    (not (nothing? '(nothing 1 2 3)))
    (not (nothing? 1))
    (not (nothing? "1"))
    (not (nothing? 'a))
    (not (nothing? '()))
    (nothing? (car '()))
    (not (nothing? (cdr '())))
    (not (nothing? '(1 2 3)))))

(define (test-null?)
  (all-true?
    (null? Nothing)
    (null? (nothing))
    (null? (nothing 1 2 3))
    (not (null? '(nothing 1 2 3)))
    (not (null? 1))
    (not (null? "1"))
    (not (null? 'a))
    (null? '())
    (null? (car '()))
    (null? (cdr '()))
    (not (null? '(1 2 3)))))

(define (test-collection?)
  (all-true?
    (not (collection? 1))
    (not (collection? 1.5))
    (not (collection? #t))
    (not (collection? #f))
    (not (collection? 'a))
    (not (collection? ""))
    (collection? '())
    (collection? '(1))
    (collection? (list))
    (collection? (list 1))
    (collection? [])
    (collection? [1])
    (collection? (vector))
    (collection? (vector 1))
    (collection? (set-of))
    (collection? (set-of 1))
    (collection? (map-of))
    (collection? (map-of [1 2]))))

(define (test-sequence?)
  (all-true?
    (not (sequence? 1))
    (not (sequence? 1.5))
    (not (sequence? #t))
    (not (sequence? #f))
    (not (sequence? 'a))
    (not (sequence? ""))
    (sequence? '())
    (sequence? '(1))
    (sequence? (list))
    (sequence? (list 1))
    (sequence? [])
    (sequence? [1])
    (sequence? (vector))
    (sequence? (vector 1))
    (not (sequence? (set-of)))
    (not (sequence? (set-of 1)))
    (not (sequence? (map-of)))
    (not (sequence? (map-of [1 2])))))

(define (test-list?)
  (all-true?
    (not (list? 1))
    (not (list? 1.5))
    (not (list? #t))
    (not (list? #f))
    (not (list? 'a))
    (not (list? ""))
    (list? '())
    (list? '(1))
    (list? (list))
    (list? (list 1))
    (not (list? []))
    (not (list? [1]))
    (not (list? (vector)))
    (not (list? (vector 1)))
    (not (list? (set-of)))
    (not (list? (set-of 1)))
    (not (list? (map-of)))
    (not (list? (map-of [1 2])))))

(define (test-vector?)
  (all-true?
    (not (vector? 1))
    (not (vector? 1.5))
    (not (vector? #t))
    (not (vector? #f))
    (not (vector? 'a))
    (not (vector? ""))
    (not (vector? '()))
    (not (vector? '(1)))
    (not (vector? (list)))
    (not (vector? (list 1)))
    (vector? [])
    (vector? [1])
    (vector? (vector))
    (vector? (vector 1))
    (not (vector? (set-of)))
    (not (vector? (set-of 1)))
    (not (vector? (map-of)))
    (not (vector? (map-of [1 2])))))

(define (test-int?)
  (all-true?
    (int? 1)
    (not (int? 1.5))
    (not (int? #t))
    (not (int? #f))
    (not (int? 'a))
    (not (int? ""))
    (not (int? '()))
    (not (int? '(1)))
    (not (int? (list)))
    (not (int? (list 1)))
    (not (int? []))
    (not (int? [1]))
    (not (int? (vector)))
    (not (int? (vector 1)))
    (not (int? (set-of)))
    (not (int? (set-of 1)))
    (not (int? (map-of)))
    (not (int? (map-of [1 2])))))

(define (test-float?)
  (all-true?
    (not (float? 1))
    (float? 1.5)
    (not (float? #t))
    (not (float? #f))
    (not (float? 'a))
    (not (float? ""))
    (not (float? '()))
    (not (float? '(1)))
    (not (float? (list)))
    (not (float? (list 1)))
    (not (float? []))
    (not (float? [1]))
    (not (float? (vector)))
    (not (float? (vector 1)))
    (not (float? (set-of)))
    (not (float? (set-of 1)))
    (not (float? (map-of)))
    (not (float? (map-of [1 2])))))

(define (test-string?)
  (all-true?
    (not (string? 1))
    (not (string? 1.5))
    (not (string? #t))
    (not (string? #f))
    (not (string? 'a))
    (string? "")
    (string? "1")
    (not (string? '()))
    (not (string? '(1)))
    (not (string? (list)))
    (not (string? (list 1)))
    (not (string? []))
    (not (string? [1]))
    (not (string? (vector)))
    (not (string? (vector 1)))
    (not (string? (set-of)))
    (not (string? (set-of 1)))
    (not (string? (map-of)))
    (not (string? (map-of [1 2])))))

(define (test-symbol?)
  (all-true?
    (not (symbol? 1))
    (not (symbol? 1.5))
    (not (symbol? #t))
    (not (symbol? #f))
    (symbol? 'a)
    (not (symbol? ""))
    (not (symbol? '()))
    (not (symbol? '(1)))
    (not (symbol? (list)))
    (not (symbol? (list 1)))
    (not (symbol? []))
    (not (symbol? [1]))
    (not (symbol? (vector)))
    (not (symbol? (vector 1)))
    (not (symbol? (set-of)))
    (not (symbol? (set-of 1)))
    (not (symbol? (map-of)))
    (not (symbol? (map-of [1 2])))))

(define (test-char?)
  (all-true?
    (not (char? 1))
    (not (char? 1.5))
    (not (char? #t))
    (not (char? #f))
    (not (char? 'a))
    (not (char? ""))
    (char? "1")
    (not (char? '()))
    (not (char? '(1)))
    (not (char? (list)))
    (not (char? (list 1)))
    (not (char? []))
    (not (char? [1]))
    (not (char? (vector)))
    (not (char? (vector 1)))
    (not (char? (set-of)))
    (not (char? (set-of 1)))
    (not (char? (map-of)))
    (not (char? (map-of [1 2])))))

(define (test-boolean?)
  (all-true?
    (not (boolean? 1))
    (not (boolean? 1.5))
    (boolean? #t)
    (boolean? #f)
    (not (boolean? 'a))
    (not (boolean? ""))
    (not (boolean? "1"))
    (not (boolean? '()))
    (not (boolean? '(1)))
    (not (boolean? (list)))
    (not (boolean? (list 1)))
    (not (boolean? []))
    (not (boolean? [1]))
    (not (boolean? (vector)))
    (not (boolean? (vector 1)))
    (not (boolean? (set-of)))
    (not (boolean? (set-of 1)))
    (not (boolean? (map-of)))
    (not (boolean? (map-of [1 2])))))

(define (test-map?)
  (all-true?
    (not (map? 1))
    (not (map? 1.5))
    (not (map? #t))
    (not (map? #f))
    (not (map? 'a))
    (not (map? ""))
    (not (map? "1"))
    (not (map? '()))
    (not (map? '(1)))
    (not (map? (list)))
    (not (map? (list 1)))
    (not (map? []))
    (not (map? [1]))
    (not (map? (vector)))
    (not (map? (vector 1)))
    (not (map? (set-of)))
    (not (map? (set-of 1)))
    (map? (map-of))
    (map? (map-of [1 2]))))

(define (test-set?)
  (all-true?
    (not (set? 1))
    (not (set? 1.5))
    (not (set? #t))
    (not (set? #f))
    (not (set? 'a))
    (not (set? ""))
    (not (set? "1"))
    (not (set? '()))
    (not (set? '(1)))
    (not (set? (list)))
    (not (set? (list 1)))
    (not (set? []))
    (not (set? [1]))
    (not (set? (vector)))
    (not (set? (vector 1)))
    (set? (set-of))
    (set? (set-of 1))
    (not (set? (map-of)))
    (not (set? (map-of [1 2])))))

(define (test-empty?)
  (all-true?
    (not (empty? 1))
    (not (empty? 1.5))
    (not (empty? #t))
    (not (empty? #f))
    (not (empty? 'a))
    (empty? "")
    (not (empty? "1"))
    (empty? '())
    (not (empty? '(1)))
    (empty? (list))
    (not (empty? (list 1)))
    (empty? [])
    (not (empty? [1]))
    (empty? (vector))
    (not (empty? (vector 1)))
    (empty? (set-of))
    (not (empty? (set-of 1)))
    (empty? (map-of))
    (not (empty? (map-of [1 2])))))

(define (test-compose)
  (all-true?
    ((compose odd? inc) 2)
    (= 4 ((compose inc inc) 2))
    (= "3" ((compose ->string inc) 2))
    ((compose nothing? ->int) '())

    ((⋅ odd? inc) 2)
    (= 4 ((⋅ inc inc) 2))
    (= "3" ((⋅ ->string inc) 2))
    ((⋅ nothing? ->int) '())

    ((§ odd? ⋅ inc) 2)
    (= 4 ((§ inc ⋅ inc) 2))
    (= "3" ((§ ->string ⋅ inc) 2))
    ((§ nothing? ⋅ ->int) '())))

(define (test-compose-and)
  (all-true?
    ((compose-and empty? vector?) [])
    ((compose-and int? number?) 5)
    (not ((compose-and (lambda (e) #f) (lambda (e) (crash!))) 0))))

(define (test-compose-or)
  (all-true?
    ((compose-or empty? list?) [])
    ((compose-or int? float?) 5)
    ((compose-or null? float?) 5.5)
    ((compose-or (lambda (e) #t) (lambda (e) (crash!))) 0)))

(define (test-complement)
  ((complement odd?) 2)
  ((~ odd?) 2))

(define (test-id)
  (all-true?
    (all?
      (lambda (e) (= e (id e)))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))
    (all?
      (lambda (e) (= (id e) (id e)))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))))

(define (test-id-fn)
  (all-true?
    (all?
      (lambda (e) (= e ((id-fn e))))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))
    (all?
      (lambda (e) (= (id e) ((id-fn e))))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))
    (all?
      (lambda (e) (= ((id-fn e)) ((id-fn e))))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))))

(define (test-hash)
  (all-true?
    (all?
      (lambda (e) (int? (hash e)))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))
    (all?
      (lambda (e) (= (hash e) (hash e)))
      (list 'a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))))

(define (test-eq?)
  (all?
    (lambda (e) (eq? e e))
    '('a 1 0.5 '() '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1")))

(define (test-->int)
  (all-true?
    (int? (->int 1))
    (= 1 (->int 1))
    (int? (->int 2.5))
    (= 2 (->int 2.5))
    (int? (->int "3"))
    (= 3 (->int "3"))
    (all?
      (lambda (e) (nothing? (->int e)))
      (list 'a "" "4.5" '() '(1) [] [1] (set-of) (set-of 1) (map-of) +))))

(define (test-->float)
  (all-true?
    (float? (->float 1))
    (= 1.0 (->float 1))
    (float? (->float 2.5))
    (= 2.5 (->float 2.5))
    (float? (->float "3"))
    (= 3.0 (->float "3"))
    (float? (->float "4.5"))
    (= 4.5 (->float "4.5"))
    (all?
      (lambda (e) (nothing? (->float e)))
      (list 'a "" '() '(1) [] [1] (set-of) (set-of 1) (map-of) +))))

(define (test-->string)
  (all-true?
    (= "" (->string ""))
    (= "" (->string Nothing))
    (= "()" (->string '()))
    (= "(1 2)" (->string '(1 2)))
    (= "[]" (->string []))
    (= "[1 2]" (->string [1 2]))
    (all?
      (lambda (e) (= (->string e) (->string e)))
      '('a "" '() '(1) [] [1] (set-of) (set-of 1) (map-of) +))))

(define (test-->bool)
  (and
    (all? ->bool
    (list #t 'a 1 0.5 '(1) [] [1] (set-of) (set-of 1) (map-of) + "" "1"))
    (none? ->bool
    (list #f '() Nothing))))

(define (test-->list)
  (all-true?
    (all? nothing?
      (map ->list (list 1 0.5 'a "a")))
    (all? (lambda (e) (and (empty? e) (list? e)))
      (map ->list (list '() [] (set-of) (map-of))))
    (all? (lambda (e) (and (list? e) (eq? '(1) e)))
      (map ->list (list '(1) [1] (set-of 1))))))

(define (test-->vector)
  (all-true?
    (all? nothing?
      (map ->vector (list 1 0.5 'a "a")))
    (all? (lambda (e) (and (empty? e) (vector? e)))
      (map ->vector (list '() [] (set-of) (map-of))))
    (all? (lambda (e) (and (vector? e) (eq? [1] e)))
      (map ->vector (list '(1) [1] (set-of 1))))))

(define (test-->char)
  (= "A" (->char 65)))

(define (test-->map)
  (all-true?
    (nothing? (->map 1))
    (empty? (->map '()))
    (eq? (map-of [1 2] [3 1]) (->map '(1 2 3 1)))
    (eq? (map-of [1 2] [3 1]) (->map [1 2 3 1]))))

(define (test-->set)
  (all-true?
    (all? nothing?
      (map ->set (list 1 0.5 'a "a")))
    (all? (lambda (e) (and (empty? e) (set? e)))
      (map ->set (list '() [] (set-of) (map-of))))
    (all? (lambda (e) (and (set? e) (eq? (set-of 1) e)))
      (map ->set (list '(1) [1] (set-of 1))))))

(define (test-list)
  (all-true?
    (empty? (list))
    (eq? (list 1 2 3) (list 1 2 3))
    (list? (list 1 2 3))
    (= 3 (list-size (list 1 2 3)))))

(define (test-list-size)
  (all-true?
    (= 0 (list-size (list)))
    (= 1 (list-size (list 1)))
    (= 2 (list-size (list 1 2)))))

(define (test-car)
  (all-true?
    (nothing? (car '()))
    (= 1 (car '(1)))
    (= 1 (car (list 1 2 3)))
    (eq? (list 1) (car (list (list 1))))
    (eq? 1 (car (car (list (list 1)))))))

(define (test-cdr)
  (all-true?
    (list? (cdr '()))
    (eq? '() (cdr '()))
    (eq? '() (cdr '(1)))
    (eq? '(2 3) (cdr (list 1 2 3)))
    (eq? '() (cdr (list (list 1))))))

(define (test-cons)
  (all-true?
    (eq? (list (list)) (cons '() '()))
    (eq? '(1 2) (cons 1 '(2)))
    (list? (cons 1 '(2)))
    (eq? (list (list 1 2 3)) (cons (list 1 2 3) (list)))))

(define (test-vector)
  (all-true?
    (empty? (vector))
    (eq? (vector 1 2 3) (vector 1 2 3))
    (vector? (vector 1 2 3))
    (= 3 (size (vector 1 2 3)))
    (empty? [])
    (eq? [1 2 3] [1 2 3])
    (vector? [1 2 3])
    (= 3 (size [1 2 3]))))

(define (test-vector-size)
  (all-true?
    (= 0 (size []))
    (= 0 (size (vector)))
    (= 1 (size [1]))
    (= 1 (size (vector 1)))
    (= 2 (size [1 2]))
    (= 2 (size (vector 1 2)))
    (= 3 (size [1 2 3]))
    (= 3 (size (vector 1 2 3)))))

(define (test-vector-nth)
  (all-true?
    (nothing? (vector-nth [] 0))
    (nothing? (vector-nth (vector) 0))
    (nothing? (vector-nth [] 1))
    (nothing? (vector-nth (vector) 1))
    (= 1 (vector-nth [1 2] 0))
    (= 1 (vector-nth (vector 1 2) 0))
    (= 2 (vector-nth [1 2] 1))
    (= 2 (vector-nth (vector 1 2) 1))
    (nothing? (vector-nth [1 2] 255))
    (nothing? (vector-nth (vector 1 2) 266))))

(define (test-vector-add)
  (all-true?
    (eq? [1] (vector-add [] 1))
    (eq? [1] (vector-add (vector) 1))
    (eq? [[]] (vector-add [] []))
    (eq? [[]] (vector-add (vector) []))
    (eq? [1 2 3] (vector-add [1 2] 3))
    (eq? [1 2 3] (vector-add (vector 1 2) 3))))

(define (test-vector-append)
  (all-true?
    (eq? [1] (vector-append [] [1]))
    (eq? [1] (vector-append (vector) (vector 1)))
    (eq? [] (vector-append [] []))
    (eq? [] (vector-append (vector) []))
    (eq? [1 2 3] (vector-append [1 2] [3]))
    (eq? [1 2 3] (vector-append (vector 1 2) [3]))))

(define (test-iterate-seq)
  (all-true?
    (= 6 (iterate-seq (lambda (acc e i) (inc acc)) 0 [1 2 3 4 5 6]))
    (= 21 (iterate-seq (lambda (acc e i) (+ acc e)) 0 [1 2 3 4 5 6]))
    (= "123" (iterate-seq (lambda (acc e i) (append acc (->string e))) "" [1 2 3]))

    (= 6 (iterate-seq (lambda (acc e i) (inc acc)) 0 '(1 2 3 4 5 6)))
    (= 21 (iterate-seq (lambda (acc e i) (+ acc e)) 0 '(1 2 3 4 5 6)))
    (= "123" (iterate-seq (lambda (acc e i) (append acc (->string e))) "" '(1 2 3)))))


(define (test-iterate-seq-p)
  (all-true?
    (= 6 (iterate-seq-p (lambda (acc e i) #t) (lambda (acc e i) (inc acc))
           0 [1 2 3 4 5 6]))
    (= 21 (iterate-seq-p (lambda (acc e i) #t) (lambda (acc e i) (+ acc e))
           0 [1 2 3 4 5 6]))
    (= "123" (iterate-seq-p (lambda (acc e i) #t) (lambda (acc e i) (append acc (->string e)))
           "" [1 2 3 4 5 6]))

    (= 6 (iterate-seq-p (lambda (acc e i) #t) (lambda (acc e i) (inc acc))
           0 '(1 2 3 4 5 6)))
    (= 21 (iterate-seq-p (lambda (acc e i) #t) (lambda (acc e i) (+ acc e))
           0 '(1 2 3 4 5 6)))
    (= "123" (iterate-seq-p
                (lambda (acc e i) #t)
                (lambda (acc e i) (append acc (->string e)))
                "" '(1 2 3))))

    ; Early break after 6 elements.
    (= 21 (iterate-seq-p (lambda (acc e i) (< i 6)) (lambda (acc e i) (+ acc e))
           0 '(1 2 3 4 5 6 7 8 9 10))))

(define (test-map-of)
  (all-true?
    (empty? (map-of))
    (map? (map-of))
    (eq? (map-keys (map-of [1 2] [3 4] [5 6]))
         (map-keys (map-of [1 2] [3 4] [5 6])))
    (eq? (map-of [1 2] [3 4] [5 6])
         (map-of [5 6] [3 4] [1 2]))))

(define (test-map-size)
  (all-true?
    (= 0 (size (map-of)))
    (= 1 (size (map-of [1 2])))
    (= 2 (size (map-of [1 2] [3 4])))
    (= 3 (size (map-of [1 2] [3 4] [5 6])))))

(define (test-map-get)
  (all-true?
    (nothing? (map-get (map-of) 1))
    (nothing? (map-get (map-of [55 2]) 1))
    (= 2 (map-get (map-of [1 2]) 1))
    (= 4 (map-get (map-of [1 2] [3 4]) 3))
    (= 2 (map-get (map-of [1 2] [3 4] [5 6]) 1))))

(define (test-map-set)
  (all-true?
    (eq? (map-of [1 2]) (map-set (map-of) 1 2))
    (eq? (map-of [1 3]) (map-set (map-of [1 2]) 1 3))
    (eq? (map-of [1 3] [13 2]) (map-set (map-of [13 2]) 1 3))
    (eq? (map-of [1 3] [13 2]) (map-set (map-of [1 3] [13 2]) 1 3))))

(define (test-map-remove)
  (all-true?
    (eq? (map-of) (map-remove (map-of) 1))
    (eq? (map-of) (map-remove (map-of [1 2]) 1))
    (eq? (map-of [13 2]) (map-remove (map-of [13 2]) 1))
    (eq? (map-of [13 2]) (map-remove (map-of [1 3] [13 2]) 1))))

(define (test-map-keys)
  (all-true?
    (eq? (map-keys (map-of [1 2] [3 4] [5 6]))
         (map-keys (map-of [1 2] [3 4] [5 6])))
    (= (size (map-of [1 2] [3 4] [5 6] [7 8]))
       (size (map-keys (map-of [1 2] [3 4] [5 6] [7 8]))))))

(define (test-map-merge)
  (all-true?
    (eq? (map-of [1 2]) (map-merge (map-of) (map-of [1 2])))
    (eq? (map-of) (map-merge (map-of) (map-of)))
    (eq? (map-of [1 2]) (map-merge (map-of [1 15]) (map-of [1 2])))
    (eq? (map-of [2 3] [1 2]) (map-merge (map-of [1 2]) (map-of [2 3])))
    (eq? (map-of [2 3] [1 2]) (map-merge (map-of [2 3]) (map-of [1 2])))))

(define (test-set-of)
  (all-true?
    (empty? (set-of))
    (eq? (set-of) (set-of))
    (eq? (set-of 1) (set-of 1 1 1 1))
    (eq? (set-of 1 2 3) (set-of 3 2 1))
    (= 0 (size (set-of)))
    (= 1 (size (set-of 1)))
    (= 1 (size (set-of 1 1 1 1)))
    (= 3 (size (set-of 1 2 3)))))

(define (test-set-size)
  (all-true?
    (= 0 (size (set-of)))
    (= 1 (size (set-of 1)))
    (= 1 (size (set-of 1 1 1 1)))
    (= 3 (size (set-of 1 2 3)))))

(define (test-set-add)
  (all-true?
    (eq? (set-of 1) (set-add (set-of) 1))
    (eq? (set-of 1 2) (set-add (set-of 1 2) 1))
    (eq? (set-of 3 1 2 4) (set-add (set-of 1 2 4) 3))
    (eq? (set-of (set-of)) (set-add (set-of) (set-of)))))

(define (test-set-union)
  (all-true?
    (eq? (set-of) (set-union (set-of) (set-of)))
    (eq? (set-of 1) (set-union (set-of 1 1 1) (set-of 1)))
    (eq? (set-of 1 2 3 4) (set-union (set-of 1 3) (set-of 2 4)))
    (eq? (set-of 66) (set-union (set-of 66) (set-of)))
    (eq? (set-of 66) (set-union (set-of) (set-of 66)))))

(define (test-set-difference)
  (all-true?
    (eq? (set-of) (set-difference (set-of) (set-of)))
    (eq? (set-of) (set-difference (set-of 1 1 1) (set-of 1)))
    (eq? (set-of 1 3) (set-difference (set-of 1 3) (set-of 2 4)))
    (eq? (set-of 66) (set-difference (set-of 66) (set-of)))
    (eq? (set-of) (set-difference (set-of) (set-of 66)))))

(define (test-set-intersection)
  (all-true?
    (eq? (set-of) (set-intersection (set-of) (set-of)))
    (eq? (set-of 1) (set-intersection (set-of 1 1 1) (set-of 1)))
    (eq? (set-of) (set-intersection (set-of 1 3) (set-of 2 4)))
    (eq? (set-of 1 2 3 4) (set-intersection (set-of 1 2 3 4 6) (set-of 1 2 3 4 5)))
    (eq? (set-of) (set-intersection (set-of 66) (set-of)))
    (eq? (set-of) (set-intersection (set-of) (set-of 66)))))

(define (test-set-includes?)
  (all-true?
    (not (includes? (set-of) 1))
    (includes? (set-of 1 1 1) 1)
    (includes? (set-of 1 3) 3)
    (includes? (set-of 1 2 3 4 6) 1)
    (includes? (set-of 1 2 3 4 6) 4)
    (not (includes? (set-of 1 2 3 4 6) 7))
    (includes? (set-of 66) 66)
    (not (includes? (set-of 66) 67))))

(define (test-set-subset?)
  (all-true?
    (set-subset? (set-of) (set-of))
    (set-subset? (set-of 1 1 1) (set-of 1))
    (set-subset? (set-of 2) (set-of 1 2 3))
    (set-subset? (set-of 1 3) (set-of 1 2 3))
    (not (set-subset? (set-of 1 5) (set-of 1 2 3)))
    (not (set-subset? (set-of 1 2) (set-of)))))

(define (test-set-true-subset?)
  (all-true?
    (not (set-true-subset? (set-of) (set-of)))
    (not (set-true-subset? (set-of 1 1 1) (set-of 1)))
    (set-true-subset? (set-of 2) (set-of 1 2 3))
    (set-true-subset? (set-of 1 3) (set-of 1 2 3))
    (not (set-true-subset? (set-of 1 5) (set-of 1 2 3)))
    (not (set-true-subset? (set-of 1 2) (set-of)))))

(define (test-set-superset?)
  (all-true?
    (set-superset? (set-of) (set-of))
    (set-superset? (set-of 1 1 1) (set-of 1))
    (set-superset? (set-of 1 2 3) (set-of 2))
    (set-superset? (set-of 1 2 3) (set-of 1 3))
    (not (set-superset? (set-of 1 2 3) (set-of 1 5)))
    (not (set-superset? (set-of) (set-of 1 2)))))

(define (test-set-true-superset?)
  (all-true?
    (not (set-true-superset? (set-of) (set-of)))
    (not (set-true-superset? (set-of 1 1 1) (set-of 1)))
    (set-true-superset? (set-of 1 2 3) (set-of 2))
    (set-true-superset? (set-of 1 2 3) (set-of 1 3))
    (not (set-true-superset? (set-of 1 2 3) (set-of 1 5)))
    (not (set-true-superset? (set-of) (set-of 1 2)))))

(define (test-begin)
  (all-true?
    (not (begin))
    (= 1 (begin 2 3 1))
    (let1 (b (box 0))
      (and
        (= @b 0)
        (begin (box-set! b 5) (= @b 5))))))

(define (test-comment)
  ; If the following are executed, the code will crash
  (comment (/ 0 0))
  (comment (no-such-function-exists))
  (comment this is not valid code)
  #t)

(define (test-size)
  (all-true?
    (= 0 (size '()))
    (= 0 (size []))
    (= 0 (size (set-of)))
    (= 0 (size (map-of)))
    (= 2 (size '(1 2)))
    (= 2 (size [1 2]))
    (= 2 (size (set-of 1 2)))
    (= 2 (size (map-of [1 2] [2 3])))))

(define (test-indices-of)
  (all-true?
    (eq? [] (indices-of '() 1))
    (eq? [] (indices-of [] 1))
    (eq? [0] (indices-of '(1 2) 1))
    (eq? [0] (indices-of [1 2] 1))
    (eq? [0 1 2 3] (indices-of '(1 1 1 1) 1))
    (eq? [0 1 2 3] (indices-of [1 1 1 1] 1))
    (eq? [0 1 3 4] (indices-of '(1 1 2 1 1) 1))
    (eq? [0 1 3 4] (indices-of [1 1 2 1 1] 1))))

(define (test-contains?)
  (all-true?
    (not (contains? '() 1))
    (not (contains? [] 1))
    (contains? '(1 2) 1)
    (contains? [1 2] 1)
    (contains? '(1 1 1 1) 1)
    (contains? [1 1 1 1] 1)
    (not (contains? '(1 1 2 1 1) 5))
    (not (contains? [1 1 2 1 1] 5))
    (contains? '(1 1 2 1 1) 2)
    (contains? [1 1 2 1 1] 2)
    
    (not (included? 1 '()))
    (not (included? 1 []))
    (included? 1 '(1 2))
    (included? 1 [1 2])
    (included? 1 '(1 1 1 1))
    (included? 1 [1 1 1 1])
    (not (included? 5 '(1 1 2 1 1)))
    (not (included? 5 [1 1 2 1 1]))
    (included? 2 '(1 1 2 1 1))
    (included? 2 [1 1 2 1 1])
    
    (not (member? 1 '()))
    (not (member? 1 []))
    (member? 1 '(1 2))
    (member? 1 [1 2])
    (member? 1 '(1 1 1 1))
    (member? 1 [1 1 1 1])
    (not (member? 5 '(1 1 2 1 1)))
    (not (member? 5 [1 1 2 1 1]))
    (member? 2 '(1 1 2 1 1))
    (member? 2 [1 1 2 1 1])
    
    (not (∈ 1 '()))
    (not (∈ 1 []))
    (∈ 1 '(1 2))
    (∈ 1 [1 2])
    (∈ 1 '(1 1 1 1))
    (∈ 1 [1 1 1 1])
    (not (∈ 5 '(1 1 2 1 1)))
    (not (∈ 5 [1 1 2 1 1]))
    (∈ 2 '(1 1 2 1 1))
    (∈ 2 [1 1 2 1 1])
    
    (∉ 1 '())
    (∉ 1 [])
    (not (∉ 1 '(1 2)))
    (not (∉ 1 [1 2]))
    (not (∉ 1 '(1 1 1 1)))
    (not (∉ 1 [1 1 1 1]))
    (∉ 5 '(1 1 2 1 1))
    (∉ 5 [1 1 2 1 1])
    (not (∉ 2 '(1 1 2 1 1)))
    (not (∉ 2 [1 1 2 1 1]))
    ))

(define (test-first)
  (all-true?
    (nothing? (first '()))
    (nothing? (first []))
    (= 1 (first '(1 2)))
    (= 1 (first [1 2]))
    (= 1 (first '(1 1 1 1)))
    (= 1 (first [1 1 1 1]))
    (= 1 (first '(1 1 2 1 1)))
    (= 1 (first [1 1 2 1 1]))
    (= 99 (first '(99 2 1 1)))
    (= 99 (first [99 2 1 1]))))

(define (test-rest)
  (all-true?
    (empty? (rest '()))
    (empty? (rest []))
    (eq? '(2) (rest '(1 2)))
    (eq? [2] (rest [1 2]))
    (eq? '(1 1 1) (rest '(1 1 1 1)))
    (eq? [1 1 1] (rest [1 1 1 1]))
    (eq? '(1 2 1 1) (rest '(1 1 2 1 1)))
    (eq? [1 2 1 1] (rest [1 1 2 1 1]))
    (eq? '(2 1 1) (rest '(99 2 1 1)))
    (eq? [2 1 1] (rest [99 2 1 1]))))

(define (test-last)
  (all-true?
    (nothing? (last '()))
    (nothing? (last []))
    (= 2 (last '(1 2)))
    (= 2 (last [1 2]))
    (= 1 (last '(1 1 1 1)))
    (= 1 (last [1 1 1 1]))
    (= 1 (last '(1 1 2 1 1)))
    (= 1 (last [1 1 2 1 1]))
    (= 0 (last '(99 2 1 1 0)))
    (= 0 (last [99 2 1 1 0]))))

(define (test-but-last)
  (all-true?
    (empty? (but-last '()))
    (empty? (but-last []))
    (eq? '(1) (but-last '(1 2)))
    (eq? [1] (but-last [1 2]))
    (eq? '(1 1 1) (but-last '(1 1 1 1)))
    (eq? [1 1 1] (but-last [1 1 1 1]))
    (eq? '(1 1 2 1) (but-last '(1 1 2 1 1)))
    (eq? [1 1 2 1] (but-last [1 1 2 1 1]))
    (eq? '(99 2 1) (but-last '(99 2 1 1)))
    (eq? [99 2 1] (but-last [99 2 1 1]))))

(define (test-append)
  (all-true?
    ; Appending strings
    (= "" (append "" ""))
    (= "1" (append "" "1"))
    (= "21" (append "2" "1"))
    
    ; Appending to string transforms the 2. element into a string
    (= "1" (append "" 1))
    (= "11" (append "" 11))
    (= "21" (append "2" 1))
    
    ; Appending empty sequences
    (empty? (append '() '()))
    (empty? (append [] []))
    (empty? (append '() []))
    (empty? (append [] '()))

    ; Appending sequences
    (eq? '(1 2 1 2) (append '(1 2) '(1 2)))
    (eq? [1 2 1 2] (append [1 2] [1 2]))
    (eq? '(1 2 1 2) (append '(1 2) [1 2]))
    (eq? [1 2 1 2] (append [1 2] '(1 2)))
    
    ; Appending any atom type will return Nothing
    (nothing? (append '(1 2) 88))
    (nothing? (append [1 2] 88))
    (nothing? (append 88 '(1 2)))
    (nothing? (append 88 [1 2]))
    (nothing? (append 88 88))))

(define (test-concat)
  (all-true?
    ; Appending empty sequences
    (empty? (concat '() '()))
    (empty? (concat [] []))
    (empty? (concat '() []))
    (empty? (concat [] '()))
    (empty? (concat '() '() '()))
    (empty? (concat [] [] []))
    (empty? (concat '() [] '()))
    (empty? (concat [] '() []))

    ; Appending sequences
    (eq? '(1 2 2 3) (concat '(1 2) '(2 3)))
    (eq? [1 2 2 3] (concat [1 2] [2 3]))
    (eq? '(1 2 2 3) (concat '(1 2) [2 3]))
    (eq? [1 2 2 3] (concat [1 2] '(2 3)))
    (eq? '(1 2 2 3 3 4) (concat '(1 2) '(2 3) '(3 4)))
    (eq? [1 2 2 3 3 4] (concat '(1 2) '(2 3) [3 4]))
    (eq? '(1 2 2 3 3 4) (concat '(1 2) [2 3] '(3 4)))
    (eq? [1 2 2 3 3 4] (concat [1 2] [2 3] [3 4]))
    
    ; Appending any atom type will return Nothing
    (nothing? (concat '(1 2) 88 0))
    (nothing? (concat 0 [1 2] 88))
    (nothing? (concat 88 []  '(1 2)))
    (nothing? (concat '() 88 [1 2]))
    (nothing? (concat 88 88 0))
    (nothing? (concat 88 0))))

(define (test-string-concat)
  (all-true?
    (= "" (string-concat "" ""))
    (= "1" (string-concat "" "1"))
    (= "21" (string-concat "2" "1"))
    (= "" (string-concat "" "" ""))
    (= "1" (string-concat "" "1" ""))
    (= "321" (string-concat "3" "2" "1"))
    
    ; Appending to string transforms the 2. element into a string
    (= "19" (string-concat "" 1 9))
    (= "11a" (string-concat "" 11 'a))
    (= "21" (string-concat "2" 1 ""))))
    
(define (test-nth)
  (all-true?
    (nothing? (nth '() 0))
    (nothing? (nth '(1 2 3) 15))
    (= 1 (nth '(1 2 3) 0))
    (= 2 (nth '(1 2 3) 1))
    (= 3 (nth '(1 2 3) 2))
    
    (nothing? (nth [] 0))
    (nothing? (nth [1 2 3] 15))
    (= 1 (nth [1 2 3] 0))
    (= 2 (nth [1 2 3] 1))
    (= 3 (nth [1 2 3] 2))))
   
(define (test-split)
  (all-true?
    (eq? '(()) (split 1 '()))
    (eq? '(()) (split 1 []))
    (eq? '(() (2)) (split 1 '(1 2)))
    (eq? '(() (2)) (split 1 [1 2]))
    (eq? '(() (2 3)) (split 1 '(1 2 3)))
    (eq? '(() (2 3)) (split 1 [1 2 3]))
    (eq? '((5) (2 3) (6)) (split 1 '(5 1 2 3 1 6)))
    (eq? '((5) (2 3) (6)) (split 1 [5 1 2 3 1 6]))))

(define (test-split-by)
  (all-true?
    (eq? '(()) (split-by (lambda (x) (< x 2)) '()))
    (eq? '(()) (split-by (lambda (x) (< x 2)) []))
    (eq? '(() (2)) (split-by (lambda (x) (< x 2)) '(1 2)))
    (eq? '(() (2)) (split-by (lambda (x) (< x 2)) [1 2]))
    (eq? '(() (2 3)) (split-by (lambda (x) (< x 2)) '(1 2 3)))
    (eq? '(() (2 3)) (split-by (lambda (x) (< x 2)) [1 2 3]))
    (eq? '((5) (2 3) (6)) (split-by (lambda (x) (< x 2)) '(5 1 2 3 1 6)))
    (eq? '((5) (2 3) (6)) (split-by (lambda (x) (< x 2)) [5 1 2 3 1 6]))
    
    (eq? '(()) (split-by (lambda (x) (> x 15)) '()))
    (eq? '(()) (split-by (lambda (x) (> x 15)) []))
    (eq? '(() (2)) (split-by (lambda (x) (< x 2)) '(-6 2)))
    (eq? '(() (2)) (split-by (lambda (x) (< x 2)) [-6 2]))
    (eq? '((5) (2 3) (6)) (split-by (lambda (x) (< x 2)) '(5 0 2 3 1 6)))
    (eq? '((5) (2 3) (6)) (split-by (lambda (x) (< x 2)) [5 0 2 3 1 6]))))

(define (test-but-last)
  (all-true?
    (empty? (but-last '()))
    (empty? (but-last []))
    (eq? '(1) (but-last '(1 2)))
    (eq? [1] (but-last [1 2]))
    (eq? '(1 1 1) (but-last '(1 1 1 1)))
    (eq? [1 1 1] (but-last [1 1 1 1]))
    (eq? '(1 1 2 1) (but-last '(1 1 2 1 1)))
    (eq? [1 1 2 1] (but-last [1 1 2 1 1]))
    (eq? '(99 2 1) (but-last '(99 2 1 1)))
    (eq? [99 2 1] (but-last [99 2 1 1]))))

(define (test-map)
  (all-true?
    (eq? (list) (map ->string (list)))
    (eq? (list 1 4 9 16 25) (map (lambda (n) (* n n)) (list 1 2 3 4 5)))
    (eq? (list "1" "2" "3") (map ->string (list 1 2 3)))
    (eq? (list "a" "b" "c") (map ->string (list "a" "b" "c")))
    
    (eq? [] (map ->string []))
    (eq? [1 4 9 16 25] (map (lambda (n) (* n n)) [1 2 3 4 5]))
    (eq? ["1" "2" "3"] (map ->string [1 2 3]))
    (eq? ["a" "b" "c"] (map ->string ["a" "b" "c"]))))

(define (test-map-indexed)
  (all-true?
    (eq? (list) (map-indexed (lambda (e i) (->string e)) (list)))
    (eq? (list 1 4 9 16 25) (map-indexed (lambda (n i) (* n n)) (list 1 2 3 4 5)))
    (eq? (list "1" "2" "3") (map-indexed (lambda (e i) (->string e)) (list 1 2 3)))
    (eq? (list "a" "b" "c") (map-indexed (lambda (e i) (->string e)) (list "a" "b" "c")))
    (eq? (list 1 2 3 4 5) (map-indexed (lambda (e i) e) (list 1 2 3 4 5)))
    (eq? (list 0 1 2 3 4) (map-indexed (lambda (e i) i) (list 1 2 3 4 5)))
    
    (eq? [] (map-indexed (lambda (e i) (->string e)) []))
    (eq? [1 4 9 16 25] (map-indexed (lambda (n i) (* n n)) [1 2 3 4 5]))
    (eq? ["1" "2" "3"] (map-indexed (lambda (e i) (->string e)) [1 2 3]))
    (eq? ["a" "b" "c"] (map-indexed (lambda (e i) (->string e)) ["a" "b" "c"]))
    (eq? [1 2 3 4 5] (map-indexed (lambda (e i) e) [1 2 3 4 5]))
    (eq? [0 1 2 3 4] (map-indexed (lambda (e i) i) [1 2 3 4 5]))))

(define (test-fmap)
  (all-true?
    (eq? (list)
      (fmap ->string (lambda (e) #t) (list)))
    (eq? (list 1 4 9 16 25)
      (fmap (lambda (n) (* n n)) (lambda (e) #t) (list 1 2 3 4 5)))
    (eq? (list 1 2 3 #t)
      (fmap id id (list 1 #f 2 #f 3 #t #f Nothing)))
    (eq? (list 1 9 25)
      (fmap (lambda (n) (* n n)) odd? (list 1 2 3 4 5 6)))
    
    (eq? []
      (fmap ->string (lambda (e) #t) []))
    (eq? [1 4 9 16 25]
      (fmap (lambda (n) (* n n)) (lambda (e) #t) [1 2 3 4 5]))
    (eq? [1 2 3 #t]
      (fmap id id [1 #f 2 #f 3 #t #f Nothing]))
    (eq? [1 9 25]
      (fmap (lambda (n) (* n n)) odd? [1 2 3 4 5 6]))))

(define (test-mapf)
  (all-true?
    (eq? (list)
      (mapf ->string (lambda (e) #t) (list)))
    (eq? (list 1 4 9 16 25)
      (mapf (lambda (n) (* n n)) (lambda (e) #t) (list 1 2 3 4 5)))
    (eq? (list 1 2 3 #t)
      (mapf id id (list 1 #f 2 #f 3 #t #f Nothing)))
    (eq? (list 1 9 25)
      (mapf (lambda (n) (* n n)) odd? (list 1 2 3 4 5 6)))
    
    (eq? []
      (mapf ->string (lambda (e) #t) []))
    (eq? [1 4 9 16 25]
      (mapf (lambda (n) (* n n)) (lambda (e) #t) [1 2 3 4 5]))
    (eq? [1 2 3 #t]
      (mapf id id [1 #f 2 #f 3 #t #f Nothing]))
    (eq? [1 9 25]
      (mapf (lambda (n) (* n n)) odd? [1 2 3 4 5 6]))))

(define (test-maplist)
  (eq? '(0 1 1)
      (maplist (lambda (x) (if (∈ (car x) (cdr x)) 0 1)) (list 'a 'b 'a))))

(define (test-mapcar)
  (all-true?
    (eq? '(1 2 3 4) (mapcar id '(1 2 3 4)))
    (eq? '(3 5 7 9) (mapcar + '(1 2 3 4) '(2 3 4 5)))
    (eq? '((1 2) (4 3)) (mapcar list '(1 4) '(2 3)))
    (eq? '((1 2) (4)) (mapcar list '(1 4) '(2)))
    (eq? '((1 2) (3)) (mapcar list '(1) '(2 3)))))

(define (test-mapcon)
  (all-true?
    (eq? '(((1 2 3 4)) ((2 3 4)) ((3 4)) ((4))) (maplist list '(1 2 3 4)))
    (eq? '((1 2 3 4) (2 3 4) (3 4) (4)) (mapcon list '(1 2 3 4)))))

(define (test-mapcat)
  (mapcat cdr '((1 2) (3 4) (5 6))))

(define (test-map-while)
  (all-true?
    (empty? (map-while inc (partial > 5) '()))
    (eq? '(2 3 4) (map-while inc (partial > 4) '(1 2 3 4 5 6 7)))
    (empty? (map-while inc (partial > 5) []))
    (eq? [2 3 4] (map-while inc (partial > 4) [1 2 3 4 5 6 7]))))

(define (test-map-until)
  (all-true?
    (empty? (map-until inc (partial > 5) '()))
    (eq? '(2 3 4 5) (map-until inc (partial < 4) '(1 2 3 4 5 6 7)))
    (empty? (map-until inc (partial > 5) []))
    (eq? [2 3 4 5] (map-until inc (partial < 4) [1 2 3 4 5 6 7]))))

(define (test-filter)
  (all-true?
    (empty? (filter odd? '()))
    (eq? '() (filter odd? '(2 4 6 8)))
    (eq? '(1 3 5 7) (filter odd? '(1 2 3 4 5 6 7 8)))
    (empty? (filter odd? []))
    (eq? [] (filter odd? [2 4 6 8]))
    (eq? [1 3 5 7] (filter odd? [1 2 3 4 5 6 7 8]))))

(define (test-filter-indexed)
  (all-true?
    (empty? (filter-indexed (lambda(e i) #t) '()))
    (empty? (filter-indexed (lambda(e i) #f) '(1 2 3 4 5 6)))
    (eq? '(1 3 5) (filter-indexed (lambda(e i) (odd? e)) '(1 2 3 4 5 6)))
    (eq? '(2 4 6) (filter-indexed (lambda(e i) (even? e)) '(1 2 3 4 5 6)))
    (eq? '(1 3 5) (filter-indexed (lambda(e i) (even? i)) '(1 2 3 4 5 6)))
    (eq? '(2 4 6) (filter-indexed (lambda(e i) (odd? i)) '(1 2 3 4 5 6)))))

(define (test-remove)
  (all-true?
    (empty? (remove even? '()))
    (eq? '() (remove even? '(2 4 6 8)))
    (eq? '(1 3 5 7) (remove even? '(1 2 3 4 5 6 7 8)))
    (empty? (remove even? []))
    (eq? [] (remove even? [2 4 6 8]))
    (eq? [1 3 5 7] (remove even? [1 2 3 4 5 6 7 8]))))

(define (test-remove-indexed)
  (all-true?
    (empty? (remove-indexed (lambda(e i) #f) '()))
    (empty? (remove-indexed (lambda(e i) #t) '(1 2 3 4 5 6)))
    (eq? '(2 4 6) (remove-indexed (lambda(e i) (odd? e)) '(1 2 3 4 5 6)))
    (eq? '(1 3 5) (remove-indexed (lambda(e i) (even? e)) '(1 2 3 4 5 6)))
    (eq? '(2 4 6) (remove-indexed (lambda(e i) (even? i)) '(1 2 3 4 5 6)))
    (eq? '(1 3 5) (remove-indexed (lambda(e i) (odd? i)) '(1 2 3 4 5 6)))))

(define (test-foldl)
  (all-true?
    (= 0 (foldl + 0 '()))
    (= 1 (foldl + 0 '(1)))
    (= 15 (foldl + 0 '(1 2 3 4 5)))
    (= 20 (foldl + 5 '(1 2 3 4 5)))
    (= 0 (foldl + 0 []))
    (= 1 (foldl + 0 [1]))
    (= 15 (foldl + 0 [1 2 3 4 5]))
    (= 20 (foldl + 5 [1 2 3 4 5]))))

(define (test-foldl1)
  (all-true?
    (nothing? (foldl1 + '()))
    (= 1 (foldl1 + '(1)))
    (= 15 (foldl1 + '(1 2 3 4 5)))
    (nothing? (foldl1 + []))
    (= 1 (foldl1 + [1]))
    (= 15 (foldl1 + [1 2 3 4 5]))))

(define (test-foldl-indexed)
  (all-true?
    (= 15 (foldl-indexed nothing 15 '()))
    (= 10 (foldl-indexed (lambda(s e i) (+ s i)) 0 '(1 2 3 4 5)))
    (= 25 (foldl-indexed (lambda(s e i) (v+ s e i)) 0 '(1 2 3 4 5)))
    (= 30 (foldl-indexed (lambda(s e i) (v+ s e i)) 5 '(1 2 3 4 5)))))

(define (test-foldr)
  (all-true?
    (= 0 (foldr + 0 '()))
    (= 1 (foldr + 0 '(1)))
    (= 15 (foldr + 0 '(1 2 3 4 5)))
    (= 20 (foldr + 5 '(1 2 3 4 5)))
    (= 0 (foldr + 0 []))
    (= 1 (foldr + 0 [1]))
    (= 15 (foldr + 0 [1 2 3 4 5]))
    (= 20 (foldr + 5 [1 2 3 4 5]))))

(define (test-foldr1)
  (all-true?
    (nothing? (foldr1 + '()))
    (= 1 (foldr1 + '(1)))
    (= 15 (foldr1 + '(1 2 3 4 5)))
    (nothing? (foldr1 + []))
    (= 1 (foldr1 + [1]))
    (= 15 (foldr1 + [1 2 3 4 5]))))

(define (test-foldr-indexed)
  (all-true?
    (= 15 (foldr-indexed nothing 15 '()))
    (= 10 (foldr-indexed (lambda(e s i) (+ s i)) 0 '(1 2 3 4 5)))
    (= 25 (foldr-indexed (lambda(e s i) (v+ s e i)) 0 '(1 2 3 4 5)))
    (= 30 (foldr-indexed (lambda(e s i) (v+ s e i)) 5 '(1 2 3 4 5)))))

(define (test-repeat)
  (all-true?
    (list? (repeat 7))
    (not (empty? (repeat 7)))
    (eq? '(7 7) (take 2 (repeat 7)))
    (all? function? (take 2 (repeat gensym)))))

(define (test-repeatedly)
  (let ((b (box 0)))
    (all-true?
      (list? (repeatedly gensym))
      (not (empty? (repeatedly gensym)))
      (= 2 (size (take 2 (repeatedly nothing))))
      (all? nothing? (take 2 (repeatedly nothing)))
      (eq? '(1 2 3 4 5) (take 5 (repeatedly (lambda () (box-set! b (inc @b)) @b))))
      )))

(define (test-iterate)
  (all-true?
    (list? (iterate (lambda (n) (* n 2)) 1))
    (not (empty? (iterate (lambda (n) (* n 2)) 1)))
    (eq? '(1 2 4 8 16) (take 5 (iterate (lambda (n) (* n 2)) 1)))
    (eq? '(1 1 1 1 1) (take 5 (drop 50 (iterate id 1))))))

(define (test-take)
  (all-true?
    (empty? (take 1 '()))
    (empty? (take 0 '(1 2 3 4 5)))
    (eq? '(1 2 3) (take 3 '(1 2 3 4 5)))
    (eq? '(1 2 3 4 5) (take 15 '(1 2 3 4 5)))
    (empty? (take 1 []))
    (empty? (take 0 [1 2 3 4 5]))
    (eq? [1 2 3] (take 3 [1 2 3 4 5]))
    (eq? [1 2 3 4 5] (take 15 [1 2 3 4 5]))))

(define (test-take-while)
  (all-true?
    (empty? (take-while (partial > 5) '()))
    (eq? '(1 2 3) (take-while (partial > 4) '(1 2 3 4 5 6 7)))
    (empty? (take-while (partial > 5) []))
    (eq? [1 2 3] (take-while (partial > 4) [1 2 3 4 5 6 7]))))

(define (test-take-until)
  (all-true?
    (empty? (take-until (partial > 5) '()))
    (eq? '(1 2 3 4) (take-until (partial < 4) '(1 2 3 4 5 6 7)))
    (empty? (take-until (partial > 5) []))
    (eq? [1 2 3 4] (take-until (partial < 4) [1 2 3 4 5 6 7]))))

(define (test-drop)
  (all-true?
    (empty? (drop 1 '()))
    (empty? (drop 15 '(1 2 3 4 5)))
    (eq? '(3 4 5) (drop 2 '(1 2 3 4 5)))
    (eq? '(1 2 3 4 5) (drop 0 '(1 2 3 4 5)))
    (empty? (drop 1 []))
    (empty? (drop 15 [1 2 3 4 5]))
    (eq? [3 4 5] (drop 2 [1 2 3 4 5]))
    (eq? [1 2 3 4 5] (drop 0 [1 2 3 4 5]))))

(define (test-drop-while)
  (all-true?
    (eq? '() (drop-while (partial > 5) '()))
    (eq? '(4 5 6 7) (drop-while (partial > 4) '(1 2 3 4 5 6 7)))
    (eq? '() (drop-while (partial > 5) []))
    (eq? [4 5 6 7] (drop-while (partial > 4) [1 2 3 4 5 6 7]))))

(define (test-drop-until)
  (all-true?
    (eq? '() (drop-until (partial > 5) '()))
    (eq? '(5 6 7) (drop-until (partial < 4) '(1 2 3 4 5 6 7)))
    (eq? '() (drop-until (partial > 5) []))
    (eq? '(5 6 7) (drop-until (partial < 4) [1 2 3 4 5 6 7]))))
  
(define (test-take-drop)
  (all-true?
    (eq? '(() ()) (take-drop 1 '()))
    (eq? '((1) (2)) (take-drop 1 '(1 2)))
    (eq? '((1 2) ()) (take-drop 2 '(1 2)))
    (eq? '((1 2) ()) (take-drop 3 '(1 2)))
    (eq? '(() (1 2)) (take-drop 0 '(1 2)))
    (eq? '((1 2) (3 4 5)) (take-drop 2 '(1 2 3 4 5)))))

(define (test-take-drop-while)
  (all-true?
    (eq? '(() ()) (take-drop-while (partial > 5) '()))
    (eq? '((1 2 3) (4 5 6 7)) (take-drop-while (partial > 4) '(1 2 3 4 5 6 7)))
    (eq? '(() ()) (take-drop-while (partial > 5) []))
    (eq? '((1 2 3) (4 5 6 7)) (take-drop-while (partial > 4) [1 2 3 4 5 6 7]))))

(define (test-take-drop-until)
  (all-true?
    (eq? '(() ()) (take-drop-until (partial > 5) '()))
    (eq? '((1 2 3 4) (5 6 7)) (take-drop-until (partial < 4) '(1 2 3 4 5 6 7)))
    (eq? '(() ()) (take-drop-until (partial > 5) []))
    (eq? '((1 2 3 4) (5 6 7)) (take-drop-until (partial < 4) [1 2 3 4 5 6 7]))))

(define (test-zip)
  (all-true?
    (empty? (zip '() '()))
    (empty? (zip '() '(1 2 3)))
    (empty? (zip '(1 2 3) '()))
    (eq? '((1 4) (2 5)) (zip '(1 2) '(4 5 6)))
    (eq? '((1 4) (2 5)) (zip '(1 2 3) '(4 5)))
    (eq? '((1 4) (2 5) (3 6)) (zip '(1 2 3) '(4 5 6)))
    
    (empty? (zip [] []))
    (empty? (zip [] [1 2 3]))
    (empty? (zip [1 2 3] []))
    (eq? '((1 4) (2 5)) (zip [1 2] [4 5 6]))
    (eq? '((1 4) (2 5)) (zip [1 2 3] [4 5]))
    (eq? '((1 4) (2 5) (3 6)) (zip [1 2 3] [4 5 6]))))

(define (test-zip-with)
  (all-true?
    (empty? (zip-with list '() '()))
    (empty? (zip-with list '() '(1 2 3)))
    (empty? (zip-with list '(1 2 3) '()))
    (empty? (zip-with list [] []))
    (empty? (zip-with list [] [1 2 3]))
    (empty? (zip-with list [1 2 3] []))

    (eq? '((1 4) (2 5)) (zip-with list '(1 2) '(4 5 6)))
    (eq? '((1 4) (2 5)) (zip-with list '(1 2 3) '(4 5)))
    (eq? '((1 4) (2 5) (3 6)) (zip-with list '(1 2 3) '(4 5 6)))
    (eq? '((1 4) (2 5)) (zip-with list [1 2] [4 5 6]))
    (eq? '((1 4) (2 5)) (zip-with list [1 2 3] [4 5]))
    (eq? '((1 4) (2 5) (3 6)) (zip-with list [1 2 3] [4 5 6]))
    
    (eq? '(5 7) (zip-with + '(1 2) '(4 5 6)))
    (eq? '(5 7) (zip-with + '(1 2 3) '(4 5)))
    (eq? '(5 7 9) (zip-with + '(1 2 3) '(4 5 6)))
    (eq? '(5 7) (zip-with + [1 2] [4 5 6]))
    (eq? '(5 7) (zip-with + [1 2 3] [4 5]))
    (eq? '(5 7 9) (zip-with + [1 2 3] [4 5 6]))))

(define (test-zip-to-index)
  (all-true?
    (empty? (zip-to-index '()))
    (empty? (zip-to-index []))

    (eq? '((0 4) (1 5) (2 6)) (zip-to-index '(4 5 6)))
    (eq? '((0 4) (1 5) (2 6)) (zip-to-index [4 5 6]))))

(define (test-all?)
  (all-true?
    (all? (partial > 5) '())
    (all? (partial > 6) '(1 2 3 4 5))
    (not (all? (partial > 3) '(1 2 3 4 5)))
    (not (all? (partial < 6) '(1 2 3 4 5)))
    
    (∀ (partial > 5) '())
    (∀ (partial > 6) '(1 2 3 4 5))
    (not (∀ (partial > 3) '(1 2 3 4 5)))
    (not (∀ (partial < 6) '(1 2 3 4 5)))))

(define (test-none?)
  (all-true?
    (none? (partial > 5) '())
    (not (none? (partial > 6) '(1 2 3 4 5)))
    (not (none? (partial > 3) '(1 2 3 4 5)))
    (none? (partial < 6) '(1 2 3 4 5))
    
    (∄ (partial > 5) '())
    (not (∄ (partial > 6) '(1 2 3 4 5)))
    (not (∄ (partial > 3) '(1 2 3 4 5)))
    (∄ (partial < 6) '(1 2 3 4 5))))

(define (test-any?)
  (all-true?
    (not (any? (partial > 5) '()))
    (any? (partial > 6) '(1 2 3 4 5))
    (any? (partial > 3) '(1 2 3 4 5))
    (not (any? (partial < 6) '(1 2 3 4 5)))
    
    (not (∃ (partial > 5) '()))
    (∃ (partial > 6) '(1 2 3 4 5))
    (∃ (partial > 3) '(1 2 3 4 5))
    (not (∃ (partial < 6) '(1 2 3 4 5)))))

(define (test-va-all?)
  (all-true?
    (va-all? (partial > 5))
    (va-all? (partial > 6) 1 2 3 4 5)
    (not (va-all? (partial > 3) 1 2 3 4 5))
    (not (va-all? (partial < 6) 1 2 3 4 5))))

(define (test-va-none?)
  (all-true?
    (va-none? (partial > 5))
    (not (va-none? (partial > 6) 1 2 3 4 5))
    (not (va-none? (partial > 3) 1 2 3 4 5))
    (va-none? (partial < 6) 1 2 3 4 5)))

(define (test-va-any?)
  (all-true?
    (not (va-any? (partial > 5)))
    (va-any? (partial > 6) 1 2 3 4 5)
    (va-any? (partial > 3) 1 2 3 4 5)
    (not (va-any? (partial < 6) 1 2 3 4 5))))

(define (test-reverse)
  (all-true?
    (empty? (reverse '()))
    (eq? '(1) (reverse '(1)))
    (eq? '(3 2 1) (reverse '(1 2 3)))
    (eq? '(3 (2 4) (1)) (reverse '((1) (2 4) 3)))))

(define (test-sum)
  (all-true?
    (= 0 (sum '()))
    (= 1 (sum '(1)))
    (= 15 (sum '(1 2 3 4 5)))
    (= 15.5 (sum '(1 2 0.5 3 4 5)))))

(define (test-product)
  (all-true?
    (= 1 (product '()))
    (= 2 (product '(2)))
    (= 120 (product '(1 2 3 4 5)))
    (= 60.0 (product '(1 2 0.5 3 4 5)))))

(define (test-minimum)
  (all-true?
    (nothing? (minimum '()))
    (= 1 (minimum '(1)))
    (= 1 (minimum '(2 1 3)))))

(define (test-maximum)
  (all-true?
    (nothing? (maximum '()))
    (= 1 (maximum '(1)))
    (= 3 (maximum '(2 1 3)))))

(define (test-bubblesort)
  (all-true?
    (empty? (bubblesort '()))
    (eq? '(1) (bubblesort '(1)))
    (eq? '(1 2 3) (bubblesort '(2 1 3)))
    (eq? '(0 1 2 3 4 5) (bubblesort '(5 2 1 3 4 0)))
    (eq? '(0 1 2 3 4 5) (bubblesort '(0 1 2 3 4 5)))
    (eq? '(0 1 2 3 4 5) (bubblesort '(5 4 3 2 1 0)))
    (eq? '(-4 -2 0 1 3 5) (bubblesort '(5 -2 1 3 -4 0)))
    (eq? '(-4 -2 0 1 3 5) (bubblesort '(-4 -2 0 1 3 5)))
    (eq? '(-4 -2 0 1 3 5) (bubblesort '(5 3 1 0 -2 -4)))))

(define (test-mergesort)
  (all-true?
    (empty? (mergesort '()))
    (eq? '(1) (mergesort '(1)))
    (eq? '(1 2 3) (mergesort '(2 1 3)))
    (eq? '(0 1 2 3 4 5) (mergesort '(5 2 1 3 4 0)))
    (eq? '(0 1 2 3 4 5) (mergesort '(0 1 2 3 4 5)))
    (eq? '(0 1 2 3 4 5) (mergesort '(5 4 3 2 1 0)))
    (eq? '(-4 -2 0 1 3 5) (mergesort '(5 -2 1 3 -4 0)))
    (eq? '(-4 -2 0 1 3 5) (mergesort '(-4 -2 0 1 3 5)))
    (eq? '(-4 -2 0 1 3 5) (mergesort '(5 3 1 0 -2 -4)))))

(define (test-sort)
  (all-true?
    (empty? (sort '()))
    (eq? '(1) (sort '(1)))
    (eq? '(1 2 3) (sort '(2 1 3)))
    (eq? '(0 1 2 3 4 5) (sort '(5 2 1 3 4 0)))
    (eq? '(0 1 2 3 4 5) (sort '(0 1 2 3 4 5)))
    (eq? '(0 1 2 3 4 5) (sort '(5 4 3 2 1 0)))
    (eq? '(-4 -2 0 1 3 5) (sort '(5 -2 1 3 -4 0)))
    (eq? '(-4 -2 0 1 3 5) (sort '(-4 -2 0 1 3 5)))
    (eq? '(-4 -2 0 1 3 5) (sort '(5 3 1 0 -2 -4)))))

(define (test-sort-compare)
  (let ((odd-is-less (lambda (x y) (if (odd? x) (if (odd? y) (compare x y) -1) (if (even? y) (compare x y) 1))))
        (rev-compare (lambda (x y) (* -1 (compare x y)))))
  (all-true?
    (empty? (sort-compare compare '()))
    (eq? '(1) (sort-compare compare '(1)))
    (eq? '(1 2 3) (sort-compare compare '(2 1 3)))
    (eq? (sort '(5 2 1 3 4 0)) (sort-compare compare '(5 2 1 3 4 0)))
    (eq? (sort '(0 1 2 3 4 5)) (sort-compare compare '(0 1 2 3 4 5)))
    (eq? (reverse (sort '(5 2 1 3 4 0))) (sort-compare rev-compare '(5 2 1 3 4 0)))
    (eq? (reverse (sort '(0 1 2 3 4 5))) (sort-compare rev-compare '(0 1 2 3 4 5)))
    (eq? '(1 3 5 0 2 4) (sort-compare odd-is-less '(0 1 2 3 4 5)))
    (eq? '(1 3 5 0 2 4) (sort-compare odd-is-less '(1 3 5 0 2 4))))))

(define (test-mergesort-compare)
  (let ((odd-is-less (lambda (x y) (if (odd? x) (if (odd? y) (compare x y) -1) (if (even? y) (compare x y) 1))))
        (rev-compare (lambda (x y) (* -1 (compare x y)))))
  (all-true?
    (empty? (mergesort-compare compare '()))
    (eq? '(1) (mergesort-compare compare '(1)))
    (eq? '(1 2 3) (mergesort-compare compare '(2 1 3)))
    (eq? (sort '(5 2 1 3 4 0)) (mergesort-compare compare '(5 2 1 3 4 0)))
    (eq? (sort '(0 1 2 3 4 5)) (mergesort-compare compare '(0 1 2 3 4 5)))
    (eq? (reverse (sort '(5 2 1 3 4 0))) (mergesort-compare rev-compare '(5 2 1 3 4 0)))
    (eq? (reverse (sort '(0 1 2 3 4 5))) (mergesort-compare rev-compare '(0 1 2 3 4 5)))
    (eq? '(1 3 5 0 2 4) (mergesort-compare odd-is-less '(0 1 2 3 4 5)))
    (eq? '(1 3 5 0 2 4) (mergesort-compare odd-is-less '(1 3 5 0 2 4))))))

(define (test-random)
  (all-true?
    (= (random 500) (random 500))
    (int? (random 500))
    (<= 0 (random 500))
    (= (random 12345) (random 12345))
    (int? (random 12345))
    (<= 0 (random 12345))
    (= (random 3405691582) (random 3405691582))
    (int? (random 3405691582))
    (<= 0 (random 3405691582))))

(define (test-xorshift64s)
  (all-true?
    (= (xorshift64s 500) (xorshift64s 500))
    (int? (xorshift64s 500))
    (<= 0 (xorshift64s 500))
    (= (xorshift64s 12345) (xorshift64s 12345))
    (int? (xorshift64s 12345))
    (<= 0 (xorshift64s 12345))
    (= (xorshift64s 3405691582) (xorshift64s 3405691582))
    (int? (xorshift64s 3405691582))
    (<= 0 (xorshift64s 3405691582))
    (/= (xorshift64s 5001) (xorshift64s 5002))
    (/= (xorshift64s 5002) (xorshift64s 5003))
    (/= (xorshift64s 5003) (xorshift64s 5004))))

(define (test-xorshift64)
  (all-true?
    (= (xorshift64 500) (xorshift64 500))
    (int? (xorshift64 500))
    (<= 0 (xorshift64 500))
    (= (xorshift64 12345) (xorshift64 12345))
    (int? (xorshift64 12345))
    (<= 0 (xorshift64 12345))
    (= (xorshift64 3405691582) (xorshift64 3405691582))
    (int? (xorshift64 3405691582))
    (<= 0 (xorshift64 3405691582))
    (/= (xorshift64 5001) (xorshift64 5002))
    (/= (xorshift64 5002) (xorshift64 5003))
    (/= (xorshift64 5003) (xorshift64 5004))))

(define (test-xorshift32)
  (all-true?
    (= (xorshift32 500) (xorshift32 500))
    (int? (xorshift32 500))
    (<= 0 (xorshift32 500))
    (= (xorshift32 12345) (xorshift32 12345))
    (int? (xorshift32 12345))
    (<= 0 (xorshift32 12345))
    (= (xorshift32 3405691582) (xorshift32 3405691582))
    (int? (xorshift32 3405691582))
    (<= 0 (xorshift32 3405691582))
    (/= (xorshift32 5001) (xorshift32 5002))
    (/= (xorshift32 5002) (xorshift32 5003))
    (/= (xorshift32 5003) (xorshift32 5004))))

(define (test-lfsr)
  (all-true?
    (= (lfsr 500) (lfsr 500))
    (int? (lfsr 500))
    (<= 0 (lfsr 500))
    (= (lfsr 12345) (lfsr 12345))
    (int? (lfsr 12345))
    (<= 0 (lfsr 12345))
    (= (lfsr 3405691582) (lfsr 3405691582))
    (int? (lfsr 3405691582))
    (<= 0 (lfsr 3405691582))
    (/= (lfsr 5001) (lfsr 5002))
    (/= (lfsr 5002) (lfsr 5003))
    (/= (lfsr 5003) (lfsr 5004))))

(define (test-random-nums)
  (let* ((s (random-nums 3405691582))
         (first-100 (take 100 s)))
    (all-true? 
      (list? s)
      (all? int? first-100)
      (= (size (->set first-100)) (size first-100)) ; All unique?
      )))

(define (test-xorshift64s-seq)
  (let* ((s (xorshift64s-seq 3405691582))
         (first-100 (take 100 s)))
    (all-true? 
      (list? s)
      (all? int? first-100)
      (= (size (->set first-100)) (size first-100)) ; All unique?
      )))

(define (test-xorshift64-seq)
  (let* ((s (xorshift64-seq 3405691582))
         (first-100 (take 100 s)))
    (all-true? 
      (list? s)
      (all? int? first-100)
      (= (size (->set first-100)) (size first-100)) ; All unique?
      )))

(define (test-xorshift32-seq)
  (let* ((s (xorshift32-seq 3405691582))
         (first-100 (take 100 s)))
    (all-true? 
      (list? s)
      (all? int? first-100)
      (= (size (->set first-100)) (size first-100)) ; All unique?
      )))

(define (test-lfsr32-seq)
  (let* ((s (lfsr32-seq 3405691582))
         (first-100 (take 100 s)))
    (all-true? 
      (list? s)
      (all? int? first-100)
      (= (size (->set first-100)) (size first-100)) ; All unique?
      )))

(define (test-with-bounds)
  (let* ((s (with-bounds (random-nums 3405691582) -100 100))
         (first-100 (take 100 s)))
    (all-true? 
      (list? s)
      (all? int? first-100)
      (all? (lambda (x) (>= x -100)) first-100)
      (all? (lambda (x) (<= x 100)) first-100)
      )))

(define (test-shuffle)
  (all-true?
    (empty? (shuffle '() 3405691582))
    (= 1 (size (shuffle '(5) 3405691582)))
    (eq? (shuffle (take 20 (random-nums 3405691582)) 3405691582) (shuffle (take 20 (random-nums 3405691582)) 3405691582))
    (= 20 (size (shuffle (take 20 (random-nums 3405691582)) 3405691582)))))

;;;; Function which runs a test
(define (run-test! test-fn)
  (let1 (res (test-fn))
    (println!
      (append
        (ljust test-fn 25) 
        (cond ((= res 'TODO) "TODO") ; Test not implemented
              (res "Success!")
              (#t "Failure!")
              )))))

(define (run-tests & fns)
  (let ((results
          (foldl
            (lambda (res f)
              (let ((r (f)))
                (cond
                  ((= r 'TODO)
                    (list (car res) (cadr res) (cons f (caddr res))))
                  (r
                    (list (cons f (car res)) (cadr res) (caddr res)))
                  (else
                    (list (car res) (cons f (cadr res)) (caddr res))))))
            '(() () ())
            fns)))
    (string-concat
      "Ran " (foldl + 0 [(size (car results)) (size (cadr results)) (size (caddr results))]) " tests.\n- "
      (size (car results)) " Successful.\n- "
      (size (cadr results)) " Failed: " (cadr results) "\n- "
      (size (caddr results)) " Not implemented: " (caddr results))))

(define (run-all-tests)
  (run-tests
  'test-lambda 'test-cond 'test-if 'test-spread 'test-apply
  'test-quote 'test-gensym 'test-seq 'test-lazy-crash
  'test-lazy 'test-eager 'test-partial 'test-nothing
  'test-box 'test-unbox 'test-set-box 'test-read-string
  'test-eval 'test-measure 'test-= 'test-/= 'test-<
  'test-> 'test-<= 'test->= 'test-+ 'test-- 'test-* 'test-/ 'test-rem 
  'test-v+ 'test-v- 'test-v* 'test-v/ 'test-v% 'test-set? 'test-map?
  'test-inc 'test-dec 'test-min 'test-max 'test-map 
  'test-not 'test-and 'test-or 'test-bit-and 'test-bit-or 
  'test-bit-xor 'test-bit-shl 'test-bit-shr 'test-defined?
  'test-nothing? 'test-null? 'test-collection? 'test-sequence?
  'test-list? 'test-vector? 'test-int? 'test-float?
  'test-string? 'test-symbol? 'test-char? 'test-boolean?
  'test-set? 'test-empty? 'test-compose 'test-compose-and
  'test-compose-or 'test-complement 'test-id 'test-id-fn
  'test-hash 'test-eq? 'test-->int 'test-->float
  'test-->string 'test-->bool 'test-->list 'test-->vector
  'test-->char 'test-->map 'test-->set 'test-list
  'test-list-size 'test-car 'test-cdr 'test-cons 'test-vector
  'test-vector-size 'test-vector-nth 'test-vector-add 
  'test-vector-append 'test-iterate-seq 'test-iterate-seq-p
  'test-map-of 'test-map-size 'test-map-get 'test-map-set
  'test-map-remove  'test-map-keys 'test-map-merge 'test-set-of
  'test-set-size 'test-set-add 'test-set-union 'test-any? 
  'test-set-difference 'test-set-intersection 'test-bubblesort
  'test-mergesort 'test-sort 'test-sort-compare 'test-mergesort-compare
  'test-set-includes? 'test-set-subset? 'test-set-true-subset?
  'test-set-superset? 'test-set-true-superset? 'test-begin
  'test-comment 'test-size 'test-indices-of 'test-contains?
  'test-first 'test-rest 'test-last 'test-but-last 'test-append
  'test-concat 'test-string-concat 'test-nth 'test-split 'test-split-by
  'test-maplist 'test-mapcar 'test-mapcon 'test-mapcon
  'test-map-indexed 'test-fmap 'test-mapf 'test-mapcat 
  'test-map-while 'test-map-until 'test-filter 'test-filter-indexed 
  'test-remove 'test-remove-indexed 'test-foldl 'test-foldl1 
  'test-foldl-indexed 'test-foldr 'test-foldr1 'test-foldr-indexed 
  'test-repeat 'test-repeatedly 'test-take 'test-take-while 
  'test-take-until 'test-drop 'test-drop-while 'test-drop-until 
  'test-take-drop 'test-take-drop-while 'test-take-drop-until
  'test-zip 'test-zip-with 'test-zip-to-index 'test-all? 'test-none?
  'test-va-all? 'test-va-none? 'test-va-any? 'test-reverse 
  'test-sum 'test-minimum 'test-maximum 'test-unwrap 'test-iterate
  'test-random 'test-xorshift64s 'test-xorshift64 'test-xorshift32 'test-lfsr
  'test-random-nums 'test-xorshift64s-seq 'test-xorshift64-seq 
  'test-xorshift32-seq 'test-lfsr32-seq 'test-with-bounds 'test-shuffle
  'test-product
  ))

)

(println! (run-tests))



