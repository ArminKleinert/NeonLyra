(module lyra.core
  ()

;;; SECTION: Some core things

;## Macro: lambda
;# lambda : list|vector -> [expr]* -> expr
;# Simplified lambda* which auto-generates a name.
;# The rest is the same. Does not require any special functions, only buildins.
(defmacro (lambda binds & body)
  (cons 'lambda* (cons (gensym 'lambda) (cons binds body))))

;## Macro: λ
;# λ : list|vector -> [expr]* -> expr
;# Plain alias for lambda.
(defmacro (λ bindings & body)
  (cons 'lambda (cons bindings body)))

;## Macro: cond
;# cond : [expr]* -> expr
;# `if` with multiple arguments.
;# `(cond a b c d else e)` is equivalent to `(if a b (if c d (if else e Nothing)))`.
;# `(cond a b c d e)` if equivalent to `(if a b (if c d e))`.
(defmacro (cond & cases)
  (if cases
    (if (cdr cases)
      (list 'if (car cases) (car (cdr cases)) (cons 'cond (cdr (cdr cases))))
      (car cases))
    Nothing))

;## Macro: lazy-seq
;# lazy-seq : expr -> [expr]* -> expr
;# Generates a lazy list.
;# This allows for infinite sequences. Lyra does not understand the simpler syntax that languages like Clojure and Scheme have.
;# Example: `(define (iterate f start) (lazy-seq start (iterate f (f start))))`
(defmacro (lazy-seq x & body)
  (list 'cons x (cons 'lambda (cons '() body))))

;## Macro: comment
;# comment : [expr]* -> Nothing
;# Take any number arguments and return Nothing.
(defmacro (comment & _) (nothing))

;## Function: unwrap
;# unwrap : box -> any
;# unbox a box or unpack a user-defined type. Can be overridden.
(def-generic x (unwrap x) buildin-unwrap)

(define (%foldr f s xs)
  (if (atom? xs)
    Nothing
    (if (empty? xs)
      s
      (f (first xs) (%foldr f s (rest xs))))))

(define (%foldl f s xs)
  (if (atom? xs)
    Nothing
    (if (empty? xs)
      s
      (%foldl f (f s (first xs)) (rest xs)))))

;## Function: foldr
;# foldr : function -> any? -> collection -> any?
;# Generics for foldr and foldl.
(def-generic xs (foldr f v xs) %foldr)

;## Function: foldl
;# foldl : function -> any? -> collection -> any?
;# Generic for foldl.
(def-generic xs (foldl f v xs) %foldl)

(define (%add xs y)
  (append xs (list y)))

(define (%contains? xs e)
  (cond (empty? xs) #f
        (eq? (first xs) e) #t
        else (%contains? (rest xs) e)))

;## Function: append
;# append : collection -> collection -> collection
;# Append all elements from a sequence ys to collection xs. Requires: ->list.
(def-generic xs (append xs ys) (lambda (xs ys) (buildin-append (->list xs) (->list ys))))

;## Function: prepend
;# prepend : collection -> collection -> collection 
;# Reverse append. (append xs to ys).
(def-generic xs (prepend xs ys) (lambda (xs ys) (buildin-append ys xs)))

;## Function: add
;# add : collection -> any -> collection 
;# Add an element y to the end of a collection xs.
(def-generic xs (add xs y) %add)

;## Function: conj
;# conj : collection -> any+ -> collection
;# Add a number of elements to the end of a list.
(define (conj c x & xs)
  (foldl add c (cons x xs)))

;## Function: add-front
;# add-front : collection -> any -> collection
;# Add an element y to the front of a sequence xs.
;# Default implementation requires ->list and returns a list.
(def-generic xs (add-front xs y) (lambda (xs y) (cons y (->list xs))))

;## Function: contains?
;# contains? : collection -> any -> bool
;# Check whether the collection xs contains the element e.
(def-generic xs (contains? xs e) %contains?)

;## Function: nth
;# nth : collection -> int -> any
;# Get element from sequence xs at index i (starts at 0). Requires ->list.
;# Returns Nothing if the element cannot be found.
(def-generic xs (nth xs i)
  (lambda (xs i)
    (if (atom? xs)
      Nothing
      (let* ((xs0 (->list xs)))
          (if (or (empty? xs0) (<= i 0))
            (first xs0)
            (recur (rest xs0) (- i 1)))))))

;## Function: get
;# get : collection -> any -> any
;# Get an element in a collection xs by its key k.
;# The default behaviour uses nth, but it has to be overridden for maps and sets.
(def-generic xs (get xs k) nth)

;## Function: rnth
;# rnth : int -> collection -> any
;# Reverse of nth. Takes the collection first and the key second.
(define (rnth i xs) (nth xs i))

;## Function: rget
;# rget : any -> collection -> any
;# Reverse of get. Takes the collection first and the key second.
(define (rget k xs)(get xs k))

;## Function: index-of
;# index-of : any -> collection -> int
;# Tries to find the index of the element from the collection xs. Returns -1 if the element could not be found.
(define (index-of v xs)
  (let* ((%iof (lambda (i xs)
            (if (empty? xs)
              -1
              (let* ((c (first xs)))
                (if (eq? c v)
                  i
                  (recur (+ i 1) (rest xs))))))))
    (%iof 0 xs)))

;## Function: find
;# find : any -> collection -> any
;# Find associated key or value for an element. The type of return value depends on the type of the collection.
;# index-of for lists and vectors, true or false for sets.
(def-generic xs (find v xs) (lambda (v xs) (index-of v (seq xs))))

;## Function: ->symbol
;# ->symbol : any -> symbol
;# Try to make an element into a symbol. Returns Nothing on error.
(def-generic x (->symbol x) buildin->symbol)

;## Function: ->int
;# ->int : any -> int
;# Tries to make an element into an int. Requires ->float. Returns Nothing on error.
(def-generic x (->int x) (lambda (x) (buildin->int (->float x))))

;## Function: ->float
;# ->float : any -> float
;# Tries to make an element into a float. Returns Nothing on error.
(def-generic x (->float x) buildin->float)

;## Function: ->rational
;# ->rational : any -> rational
;# Tries to make an element into a ratonal. Returns Nothing on error.
(def-generic x (->rational x) (lambda (x) (buildin->rational (->float x))))

;## Function: ->string
;# ->string : any -> string
;# Tries to make an element into a string. Returns an unreadable string on error.
(def-generic x (->string x) buildin->string) ; TODO

;## Function: ->list
;# ->list : any -> list
;# Tries to make a list from an element. Returns Nothing on error.
(def-generic x (->list x) buildin->list)

;## Function: ->vector
;# ->vector : any -> vector
;# Try to make an element into a vector. The default uses ->list and a native function. Returns Nothing on error.
(def-generic x (->vector x) (lambda (x) (list->vector (->list x))))

;## Function: ->char
;# ->char : any -> char
;# Tries to make a char from an element. Returns Nothing on error.
(def-generic x (->char x) buildin->char)

;## Function: ->map
;# ->map : any -> map
;# Tries to make a map from an element. The default uses ->list and a native helper. Even the default might fail. Returns Nothing on error.
;# If the default is used, the list must have the format `((k v)*)`
(def-generic x (->map x) (lambda (x) (buildin->map (->list x))))

;## Function: ->set
;# ->set : any -> set
;# Try to make an element into a set. The default uses ->list and a native function. Returns Nothing on error.
(def-generic x (->set x) (lambda (x) (list->set (->list x))))

;## Function: ->keyword
;# ->keyword : any -> keyword
;# Try to make an element into a keyword. Returns Nothing on error.
(def-generic x (->keyword x) buildin->keyword)

;## Function: eq?
;# eq? : any -> any -> bool
;# More general equality function. Defaults to = but uses seq-eq? if sequence? is true for both x and y.
(def-generic x (eq? x y) (lambda (x y) (if (and (sequence? x) (sequence? y)) (seq-eq? x y) (= x y))))

;## Function: size
;# size : collection -> int
;# Get the size of a collection xs. Default requires ->list.
;# Return 0 for types which are not convertable to list.
;# The result can become an infinite loop for infinite sequences.
(def-generic xs (size xs) (lambda (xs) (let* ((l (->list xs))) (if l (list-size l) 0))))

;## Function: rest
;# rest : collection -> collection
;# Get the rest of the elements of a collection.
;# Default requires ->list. If ->list is not available, returns Nothing.
(def-generic xs (rest xs) (lambda (xs) (let* ((l (->list xs))) (if l (cdr l) Nothing))))

;## Function: first
;# first : collection -> any
;# Get the first element of a collection.
;# Default requires ->list. If ->list is not available, returns Nothing.
(def-generic xs (first xs) (lambda (xs) (let* ((l (->list xs))) (if l (car l) Nothing))))

;## Function: second
;# second : collection -> any
;# Get second element of a collection. Default requires first and rest.
;# The default is (first (rest xs)).
(def-generic xs (second xs) (lambda (xs) (first (rest xs))))

;## Function: reverse
;# reverse : collection -> collection
;# Reverse a collection.
;# The default requires foldl and returns a list.
(def-generic xs (reverse xs) (lambda (xs) (foldl (lambda (a b) (cons b a)) '() xs)))

;## Function: compare
;# compare : any -> any -> bool
;# Compare two variables x and y. Returns 0 if (= x y), -1 if (< x y) or 1 otherwise.
;# The default requires = and < to work for x and y.
(def-generic x (compare x y) (lambda (x y) (if (= x y) 0 (if (< x y) -1 1))))

;## Function: inc
;# inc : number -> number
;# Increment number by 1 (using +)
(define (inc n) (+ n 1))

;## Function: dec
;# dec : number -> number
;# Decrement number by 1 (using -)
(define (dec n) (- n 1))

;## Function: succ
;# succ : any -> any
;# Calculate successor of a variable.
;# For numbers, this defaults to inc.
;# chars have their internal value incremented by 1.
;# Other variables are their own successors (eg. a function has no successor).
(def-generic x (succ x) id)
(def-impl ::integer succ inc)
(def-impl ::float succ inc)
(def-impl ::rational succ inc)
(def-impl ::char succ (lambda (c) (int->char (inc (char->int c)))))

;## Function: sequence?
;# sequence? : any -> bool
;# Check whether a variable is a sequence. 
;# Needs to be implemented for sequence types or some functions might not work.
(def-generic x (sequence? x)
  (lambda (xs) (list? xs)))

;## Function: seq?
;# seq? : any -> bool
;# Alias for sequence?
(define seq? sequence?)

;## Function: collection?
;# collection? : any -> bool
;# Check whether a variable is a collection.
;# By default, a variable is a collection if it is a sequence or if it is convertable to a list.
(def-generic x (collection? x)
  (lambda (xs) (or (or (sequence? xs) (map? xs)) (not (nothing? (->list xs))))))

;## Function: number?
;# number? : any -> bool
;# Check whether a variable is a number.
(def-generic x (number? x)
  (lambda (xs) (or (int? xs) (or (float? xs) (rational? xs)))))

;## Function: delete-at
;# delete-at : int -> collection -> collection
;# Delete element at index i in a collection xs. 
;# If xs is a collection, use a linear implementation for lists and return a lazy sequence.
;# Otherwise, return Nothing.
(def-generic xs (delete-at i xs)
  (lambda (i xs)
    (if (collection? xs)
      (let*((xs (->list xs)))
        (cond
          (= i 0) (cdr xs)
          (< i 0) xs
          else (lazy-seq (car xs) (delete-at (dec i) (cdr xs)))))
      Nothing)))

;;; SECTION: Printing

(define (%print! xs)
  (cond xs (let*() (buildin-print! (->string (car xs))) (%print! (cdr xs))) Nothing))
;## Function: print!
;# print! : any* -> Nothing
;# Printing. Can take any number of arguments (variadic and requires ->string to work correctly.
;# (print! 1 2 3) ;=> prints "123"
(define (print! & xs)
  (%print! xs))
;## Function: println!
;# println! : any* -> Nothing
;# Like print! but appends a linebreak.
;# (println! "abc" "abc" "abc") ;=> prints "abcabcabc\n"
(define (println! & xs)
  (%print! xs)
  (buildin-print! "\n"))

;## Function: log!
;# log! : any* -> list
;# As println!, but returns the input as a list.
(define (log! & xs)
  (%println! xs)
  xs)
;## Function: log1!
;# log1! : any -> any
;# As println!, but takes only one argument and returns it after printing.
(define (log1! x)
  (%println! x)
  x)

;;; Utility functions

;## Function: flip
;# flip : function -> function
;# Take a function f, which takes two arguments and returns a new function which takes the arguments reversed.
(define (flip f)
  (lambda (x y) (f y x)))
;## Function: fst
;# fst : any -> any -> any
;# Take 2 arguments, return the first.
(define (fst x y) x)
;## Function: snd
;# snd : any -> any -> any
;# Take 2 arguments, return the second.
(define (snd x y) y)

;## Function: list
;# list : any* -> list
;# Take any number of arguments and return a list of them.
;# (list 1 2 3) ;=> (1 2 3)
(define (list & xs)
  xs)

;## Macro: let1
;# let1 : list|vector -> [expr]* -> expr
;# Simpler let for a single binding.
;# (let1 (a 1) a) is equivalent to (let*((a 1)) a)
(defmacro (let1 bindings & body)
  (xcons 'let*(list bindings) body))

;## Function: nth#map
;# nth#map : map -> int -> vector
;# Implementation of nth for maps. This converts the map into a sequence and then returns the pair (key, value).
(def-impl ::map nth (lambda (x i) (vector-nth (->vector x) i)))

;## Function: get#map
;# get#map : map -> any -> any
;# Special implementation for get for map.
(def-impl ::map get map-get)

;## Function: contains?#list
;# contains?#list : list -> any -> bool
;# Implementation for contains?.
(def-impl ::list contains? buildin-contains?)
;## Function: contains?#map
;# contains?#map : map -> any -> bool
;# Implementation for contains?.
(def-impl ::map contains? buildin-contains?)

;## Function: append#map
;# append#map : map -> collection -> collection
;# Implementation for append.
(def-impl ::map append buildin-append)

;## Function: ->vector#list
;# ->vector#list : list -> vector
;# Implementation for ->vector
(def-impl ::list ->vector buildin->vector)
;## Function: ->vector#map
;# ->vector#map : map -> vector
;# Implementation for ->vector
(def-impl ::map ->vector buildin->vector)

;## Function: ->set#list
;# ->set#list : list -> set
;# Implementation for ->set
(def-impl ::list ->set buildin->set)
;## Function: ->set#map
;# ->set#map : map -> set
;# Implementation for ->set
(def-impl ::map ->set buildin->set)

;## Function: ->map#list
;# ->map#list : list -> map
;# Implementation for ->set
(def-impl ::list ->map buildin->map)
;## Function: ->map#map
;# ->map#map : map -> map
;# Implementation. Since the input is already a map, this returns the element itself.
(def-impl ::map ->map id)

;## Function: ->string#list
;# ->string#list : list -> map
;# Implementation for ->string.
(def-impl ::list ->string (lambda (xs) (buildin->string (map-eager ->string xs))))
;## Function: ->string#map
;# ->string#map : map -> string
;# Implementation for ->string.
(def-impl ::map ->string (lambda (xs) (buildin->string xs)))

;## Function: size#list
;# size#list : list -> int
;# Implementation for size.
(def-impl ::list size list-size)
;## Function: size#map
;# size#map : map -> int
;# Implementation for size.
(def-impl ::map size map-size)

;## Function: first#list
;# first#list : list -> any
;# Implementation for first.
(def-impl ::list first car)
;## Function: first#map
;# first#map : map -> any
;# Returns the first key in the map.
(def-impl ::map first (lambda (m) (vector-nth (map->vector m) 0)))

;## Function: rest#list
;# rest#list : list -> list
;# Implementation for rest.
(def-impl ::list rest cdr)
;## Function: rest#map
;# rest#map : map -> sequence
;# Implementation for rest.
(def-impl ::map rest (lambda (m) (let*((v (map->vector m))) (vector-range 1 (vector-size v) v))))

;## Function: reverse#map
;# reverse#map : map -> map
;# Special implementation of reverse for maps.
;# Since maps are unordered, they are their own reversals.
(def-impl ::map reverse id)

;## Function: add#map
;# add#map : map -> sequence -> map
;# Implementation for add. The sequence must have a size of 2.
(def-impl ::map add (lambda (m kv) (map-set (first kv) (second kv))))

;## Function: add-front#list
;# add-front#list : list -> any -> list
;# Implementation for add-front.
(def-impl ::list add-front (lambda (l o) (cons o l)))
;## Function: add-front#map
;# add-front#map : map -> sequence -> map
;# Implementation for add-front. Same as add. The sequence must have a size of 2.
(def-impl ::map add-front (lambda (m kv) (map-set m (first kv) (second kv))))

;## Function: ->int#int
;# ->int#int : int -> int
;# Implementation for ->int. Does nothing for ints.
(def-impl ::integer ->int id)
;## Function: ->int#float
;# ->int#float : float -> ->int
;# Implementation for ->int. Rounds down.
(def-impl ::float ->int buildin->int)
;## Function: ->int#rational
;# ->int#rational : rational -> int
;# Implementation for ->int. Rounds down.
(def-impl ::rational ->int buildin->int)
;## Function: ->int#char
;# ->int#char : char -> int
;# Implementation for ->int.Gets the utf-8 code of the char.
(def-impl ::char ->int buildin->int)

;## Function: ->rational#int
;# ->rational#int : int -> rational
;# Implementation for ->rational.
(def-impl ::integer ->rational buildin->rational)
;## Function: ->rational#float
;# ->rational#float : float -> rational
;# Implementation for ->rational.
(def-impl ::float ->rational buildin->rational)
;## Function: ->rational#rational
;# ->rational#rational : rational -> rational
;# Implementation for ->rational.
(def-impl ::rational ->rational id)
;## Function: ->rational#char
;# ->rational#char : char -> rational
;# Implementation for ->rational.
(def-impl ::char ->rational buildin->rational)

;## Function: foldr#list
;# foldr#list : (any -> any -> any) -> any -> list -> any
;# Implementation for foldr.
(def-impl ::list foldr buildin-foldr)

;## Function: foldr#map
;# foldr#map : (any -> any -> any) -> any -> map -> any
;# Implementation for foldr.
(def-impl ::map foldr buildin-foldr)

;## Function: foldl#list
;# foldl#list : (any -> any -> any) -> any -> list -> any
;# Implementation for foldl.
(def-impl ::list foldl buildin-foldl)

;## Function: foldl#map
;# foldl#map : (any -> any -> any) -> any -> map -> any
;# Implementation for foldl.
(def-impl ::map foldl buildin-foldl)

;## Function: last
;# last : collection -> any
;# Get last element of a collection.
;# Default implementation requires ->list, first, rest, size.
(def-generic xs (last xs)
  (lambda (xs)
    (let*((l (->list xs))) (if (list? l) (first (drop (dec (size l)) l)) (nothing)))))

;## Function: but-last
;# but-last : collection -> list
;# Get all elements, except for the last one from a collection. Requires ->list, first, rest, size.
(define (but-last xs)
  (let*((l (->list xs)))
    (if (list? l) (take (dec (size l)) l) (nothing))))

;## Function: empty?
;# empty? : collection -> bool
;# Check whether a variable is empty, according to the following rules:
;#   lists are empty if null? is true for them (true for empty list and Nothing).
;#   collections are empty if their size is 0.
;#   The special value Nothing is empty.
;#   Other non-collections are not empty.
(define (empty? xs)
  (cond (list? xs) (null? xs)
        (collection? xs) (= (size xs) 0)
        (nothing? xs) #t
        else #f))

;## Function: included?
;# included? : any -> collection -> bool
;# Check whether value e is in a collection xs. This is the reverse of contains?
(define (included? e xs) (contains? xs e))

;## Function: seq-eq?
;# seq-eq? : sequence -> sequence -> bool
;# Check whether 2 sequences are equal. They need to support empty?, first and rest
(define (seq-eq? l0 l1)
  (cond (empty? l0) (empty? l1)
        (eq? (first l0) (first l1)) (seq-eq? (rest l0) (rest l1))
        else #f))

;## Function: eq?#list
;# eq?#list : list -> sequence -> bool
;# Implementation of eq? for lists.
(def-impl ::list eq? seq-eq?)

;## Function: eq?#map
;# eq?#map : map -> map -> bool
;# Implementation of eq? for maps.
(def-impl ::map eq? map-eq?)

;## Function: not-eq?
;# not-eq? : any -> any -> bool
;# Check for non-equality. This is the reverse of eq?.
(define (not-eq? x y) (not (eq? x y)))

;## Function: symbol
;# symbol : any -> symbol
;# Alias for ->symbol.
(define symbol ->symbol)

;## Function: else
;# else : bool
;# Nicer-to-read alias for #t.
(define else #t)

;## Macro: and
;# and : expr -> expr -> expr
;# Macro for lazy `and`.
;#  (and x y) returns y if x is #t or returns #f if x is not true.
(defmacro (and x y) (list 'if x y #f))
;## Macro: or
;# or : expr -> expr -> expr
;# Macro for lazy `or`.
;#  (or x y) returns x if x is truthy or y if x is not truthy.
(defmacro (or x y) (let*((s (gensym 'x))) (list 'let*(list (list s x)) (list 'if s s y))))

;## Function: odd?
;# odd? : number -> bool
;# Check whether a number is odd or even. Requires ->int.
(define (odd? n) (= 1 (rem (->int n) 2)))

;## Function: even?
;# even? : number -> bool
;# Check whether a number is odd or even. Requires ->int.
(define (even? n) (= 0 (rem (->int n) 2)))

;## Function: name
;# name : any -> string
;# Turns symbols and keywords into strings. strings are unchanged. for all other types, the function returns Nothing.
(define (name x)
  (case x
    symbol? (->string x)
    keyword? (->string (keyword-name x))
    string? x
    Nothing))

;## Function: foldl1
;# foldl1 : (any -> any -> any) -> collection -> any
;# (foldl1 + '()) ;=> Nothing
;# (foldl1 + '(1)) ;=> 1 (if only 1 element is given, return it.
;# (foldl1 + '(1 2 3)) ;=> 6
;# Requires: empty?, size, first, rest, foldl
(define (foldl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (foldl f (first xs) (rest xs))))

;## Function: foldl-indexed
;# foldl-indexed : (any -> any -> int -> any) -> any -> collection -> any
;# foldl with index.
;# Requires: empty?, first, rest
(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

;## Function: foldr1
;# foldr1 : (any -> any -> any) -> collection -> any
;# Similar to foldr1.
;# Requires empty?, size, first, rest
(define (foldr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (f (first xs) (foldr1 f (rest xs)))))

(define (%foldr-indexed f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (%foldr-indexed f v (inc i) (rest xs)) i)))
;## Function: foldr-indexed
;# foldr-indexed : (any -> any -> int -> any) -> any -> collection -> any
;# foldr with index.
;# Requires: empty?, first, rest
(define (foldr-indexed f v xs)
  (%foldr-indexed f v 0 xs))

;## Function: scanl
;# scanl : (any -> any -> any) -> any -> collection -> list
;# scan left. (known as reductions in clojure)
;# Return intermediate results of foldl as a list.
;# Requires empty?, first, rest
(define (scanl f v xs)
  (let*((%scanl
        (lambda (r a ys)
          (if (empty? ys)
            r
            (let*((b (f a (first ys)))) (%scanl (cons b r) b (rest ys)))))))
    (reverse (%scanl (list v) v xs))))

;## Function: scanl
;# scanl : (any -> any -> any) -> collection -> list
;# scan left with no accumulator.
;# Requires empty?, size, first, rest.
(define (scanl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) xs
        else (scanl f (first xs) (rest xs))))

;## Function: compose
;# compose : (any -> any) -> (any -> any) -> (any -> any)
;# Function composition
(define (compose f g)
  (lambda (x & xs) (f (apply-to g (cons x xs)))))
;## Function: comp
;# comp : (any -> any) -> (any -> any) -> (any -> any)
;# Alias for compose.
(define comp compose)

;## Function: compose2
;# compose2 : (any -> any) -> (any -> any -> any) -> (any -> any -> any)
;# Function composition, but the function g (which is applied first) takes 2 arguments.
(define (compose2 f g)
  (lambda (x y) (f (g x y))))

;## Function: compose-n
;# compose-n : (any -> any) -> ([any]+ -> any) -> ([any]+ -> any)
;# Function composition, but the function g (which is applied first) takes 2 arguments.
(define (compose-n f g)
  (lambda (x & xs) (f (apply-to g (cons x xs)))))

;## Function: compose-or
;# compose-or : (any -> bool) -> (any -> bool) -> (any -> bool)
;# Function composition using or.
;# ((compose-or sequence? number?) x) ;=> (or (sequence? x) (number? x))
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

;## Function: compose-any
;# compose-any : (any -> bool) -> (any -> bool) -> (any -> bool)
;# Function composition using and.
;# ((compose-or sequence? empty?) x) ;=> (or (sequence? x) (empty? x))
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

;## Function: complement
;# complement : (any -> bool) -> (any -> bool)
;# Function complement
(define (complement p)
  (lambda (x) (not (p x))))

;## Macro: begin
;# begin : [expr]* -> expr
;# Perform operations sequencially.
(defmacro (begin & exprs)
  (xcons 'let* '() exprs))

;## Macro: def-memo
;# def-memo : list|vector -> [expr]* -> (any* -> any)
;# define memoized function.
(defmacro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (xcons 'lambda (cdr name-bindings) body))))

;## Function: spread
;# spread : sequence -> sequence
;# Expand the last element of a sequence and returns a list.
;# (spread (list 1 2 3 '(9 7 5))) ;=> (1 2 3 9 7 5)
;# Requires: split-at, size
(define (spread xs)
  ((lambda (ys) (append (car ys) (caadr ys))) (split-at (dec (size xs)) xs)))

;## Function: apply
;# apply : ([any]* -> any) -> [any]* -> any
;# Apply a function to a variable number of arguments with the last one being expanded using spread.
;# (apply list 1 2 3 '(9 7 5)) ;=> (list 1 2 3 9 7 5) ;=> (1 2 3 9 7 5)
(define (apply f & xs)
  (apply-to f (spread xs)))

;## Function: eval-seq!
;# eval-seq! : collection -> collection
;# Forces a sequence to be evaluated. The sequence is then returned as it was.
(define (eval-seq! xs)
  (foldl fst xs xs))

;## Function: map
;# map : (any -> any) -> collection -> list
;# Lazy map requires empty?, first, rest
(define (map f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs)) (map f (rest xs)))))

;## Function: map-split
;# map-split : ([any]* -> any) -> collection -> list
;# Takes a sequence of sequences and maps over each sub-sequence.
;# (map-split + '((1 2) (3 4) (5 6))) ;=> (3 7 11)
(define (map-split f xs)
  (if (empty? xs)
    '()
    (lazy-seq (apply-to f (first xs)) (map-split f (rest xs)))))

;## Function: map-eager
;# map-eager : (any -> any) -> collection -> list
;# Same as map, but works eagerly, not lazy.
(define (map-eager f xs)
  (if (empty? xs)
    '()
    (cons (f (first xs)) (map-eager f (rest xs)))))

(define (%map-indexed f xs i)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs) i) (%map-indexed f (rest xs) (inc i)))))
;## Function: map-indexed
;# map-indexed : (any -> int -> any) -> collection -> list
;# map with index.
;# Requires empty?, first, rest.
(define (map-indexed f xs) (%map-indexed f xs 0))

;## Function: map-while
;# map-while : (any -> any) -> (any -> bool) -> collection -> list
;# map while a predicate if true. Uses map and take-whilel.
(define (map-while f p xs) (map f (take-while p xs)))
;## Function: map-until
;# map-until : (any -> any) -> (any -> bool) -> collection -> list
;# map until a predicate if true. Uses map and take-until.
(define (map-until f p xs) (map f (take-until p xs)))

;## Function: maplist
;# maplist : (collection -> any) -> collection -> list
;# map but use the rest of the list.
;# (maplist size '(1 2 3)) ;=> (3 2 1)
;#   Like (list (size '(1 2 3)) (size '(2 3)) (size '(3)))
;# Requires: empty?, rest
(define (maplist f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f xs) (maplist f (rest xs)))))

(define (%mapcar f ys)
  (if (any? empty? ys)
    '()
    (lazy-seq (apply-to f (map first ys)) (%mapcar f (map rest ys)))))
;## Function: mapcar
;# mapcar : ([any]+ -> any) -> [collection]* -> list
;# Take any number of collections and map their first elements until all are empty.
;#   (mapcar list '(1 2 3) '(4 5 6) '(7 8 9)) ;=> ((1 4 7) (2 5 8) (3 6 9))
;#   (mapcar + '(1 2 3) '(4 5 6) '(7 8 9)) ;=> (12 15 18)
;#   (mapcar + '(1 2 3) '(4 5) '(7 8 9)) ;=> (12 15 12)
;# Required: v-zip-with to work correctly with all inputs.
(define (mapcar f & ys)
  (%mapcar f ys))

;## Function: mapcon
;# mapcon : (any -> collection) -> collection -> collection
;# maplist and append.
(define (mapcon f xs)
  (foldr append '() (maplist f xs)))

;## Function: mapcat
;# mapcat : (any -> collection) -> collection -> list
;# map and then append (lazy).
(define (mapcat f xs)
  (if (empty? xs)
    '()
    (let* ((x (f (first xs))))
      (lazy-seq (first x) (list-concat (rest x) (mapcat f (rest xs)))))))

;## Function: juxt
;# juxt : [(any -> any)]+ -> (any -> any)
;# See https://clojuredocs.org/clojure.core/juxt
;# (juxt identity name) is effectively equivalent to (lambda (x) (list (identity x) (name x)))
(define (juxt f & fs)
  (lambda (x) (mapv (lambda (g) (g x)) (cons f fs))))

;## Function: filter
;# filter : (any -> bool) -> collection -> list
;# Lazy filter.
;# Required: empty?, first, rest
(define (filter p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (first xs) (filter p (rest xs)))
        else (filter p (rest xs))))

(define (%filter-indexed p xs i)
  (cond (empty? xs) '()
        (p (first xs) i) (lazy-seq (first xs) (%filter-indexed p (rest xs) (inc i)))
        else (%filter-indexed p (rest xs) (inc i))))
;## Function: filter-indexed
;# filter-indexed : (any -> int -> bool) -> collection -> list
;# Filter lazily with index.
;# Required: empty?, first, rest
(define (filter-indexed p xs) (%filter-indexed p xs 0))

;## Function: remove
;# remove : (any -> bool) -> collection -> list
;# Filter with complement of p
(define (remove p xs) (filter (complement p) xs))
;## Function: remove-indexed
;# remove-indexed : (any -> int -> bool) -> collection -> list
;# Filter with index with complement of p
(define (remove-indexed p xs)
  (filter-indexed (lambda (x i) (not (p x i))) xs))

;## Function: every-pred
;# every-pred : [(any -> bool)]+ -> (any -> bool)
;# Check whether all predicates are true on a given element
(define (every-pred p & ps)
  (compose (partial all? id) (apply-to juxt (cons p ps))))

;## Function: fmap
;# fmap : (any -> any) -> (any -> bool) -> collection -> list
;# Filter, then map.
;# (fmap f p xs) is equivalent to (filter p (map f xs))
;# Required: empty?, first, rest
(define (fmap f p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (f (first xs)) (fmap f p (rest xs)))
        else (fmap f p (rest xs))))
;## Function: mapf
;# mapf : (any -> any) -> (any -> bool) -> collection -> list
;# map, then filter
;# (mapf f p xs) is equivalent to (map f (filter p xs))
;# Required: empty?, first, rest
(define (mapf f p xs)
  (if (empty? xs)
    '()
    (let*((y (f (first xs))))
      (if (p y)
        (lazy-seq y (mapf f p (rest xs)))
        (mapf f p (rest xs))))))

;## Function: split
;# split : int -> collection -> list
;# Split a sequence into 2 parts: From index 0 to n and the rest.
;# (split n xs) is equivalent to (list (take n xs) (drop n xs))
;# Required: empty?, ->list (for the rest), first, rest
(define (%split-at n st en)
  (if (or (= n 0) (empty? en))
    (list (reverse (->list st)) (->list en))
    (%split-at (dec n) (cons (first en) st) (rest en))))
(define (split-at n xs)
  (%split-at n '() xs))

(define (%split-unless p st en)
  (if (or (empty? en) (p (first en)))
    (list (reverse (->list st)) (->list en))
    (%split-unless p (cons (first en) st) (rest en))))
;## Function: split-unless
;# split-unless : (any -> bool) -> collection -> list
;# (split-unless p xs) is equivalent to (list (take-until p xs) (drop-until p xs))
;# Required: empty?, first, rest
(define (split-unless p xs)
  (%split-unless p '() xs))

;## Function: split-if
;# split-if : (any -> bool) -> collection -> list
;# (split-if p xs) is equivalent to (list (take-while p xs) (drop-while p xs))
;# Required: empty?, first, rest
(define (split-if p xs)
  (%split-unless (complement p) '() xs))

(define (%take n xs)
  (if (or (= 0 n) (empty? xs))
    '()
    (lazy-seq (first xs) (%take (dec n) (rest xs)))))
;## Function: take
;# take : int -> collection -> list
;# Take the first n elements of a collection xs or the whole collection, if its size is greater than n.
;# Returns Nothing for atoms. Otherwise, the output is always a list.
;# Requires: empty?, first, rest
(define (take n xs)
  (cond
    (empty? xs) '()
    else (%take n xs)))

;## Function: take-while
;# take-while : (any -> bool) -> collection -> list
;# Take while a predicate is true.
;# Required: empty?, first, rest
(define (take-while p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (first xs) (take-while p (rest xs)))
        else '()))

;## Function: take-until
;# take-until : (any -> bool) -> collection -> list
;# Take until a predicate is true.
;# Required: empty?, first, rest
(define (take-until p xs)
  (cond (empty? xs) '()
        (p (first xs)) '()
        else (lazy-seq (first xs) (take-until p (rest xs)))))

;## Function: take-nth
;# take-nth : int -> collection -> list
;# Take every nth item.
(define (take-nth n xs)
  (cond (empty? xs) '()
        else (lazy-seq (first xs) (take-nth n (drop n xs)))))

;## Function: drop
;# drop : int -> collection -> sequence
;# Drop the first n elements of a collection xs.
;# Returns Nothing for atoms.
;# Requires: empty?, first, rest
(define (drop n xs)
  (cond (<= n 0) xs
        (empty? xs) xs
        else (drop (- n 1) (rest xs))))

;## Function: drop-while
;# drop-while : (any -> bool) -> collection -> sequence
;# Drop the elements of a collection xs until a predicate is false.
;# Returns Nothing for atoms.
;# Requires: empty?, first, rest
(define (drop-while p xs)
  (cond (empty? xs) xs
        (p (first xs)) (drop-while p (rest xs))
        else xs))

;## Function: drop-until
;# drop-until : (any -> bool) -> collection -> sequence
;# Drop the elements of a collection xs until a predicate is true.
;# Returns Nothing for atoms.
;# Requires: empty?, first, rest
(define (drop-until p xs)
  (cond (empty? xs) xs
        (p (first xs)) xs
        else (drop-until p (rest xs))))

;## Function: subseq
;# subseq : int -> int -> collection -> list
;# Returns a sub-sequence of a sequence.
;# Equivalent to (take length (drop start xs))
(define (subseq start length xs)
  (take length (drop start xs)))

;## Function: replace-subseq
;# replace-subseq : int -> int -> sequence -> sequence
;# Replaces a sub-sequence in a sequence.
;#   (replace-subseq 0 4 '() '(1 2 3 4)) ;=> ()
;#   (replace-subseq 1 2 '(3 4) '(1 2 3 4)) ;=> (1 3 4 4)
;#   (replace-subseq 1 2 '(3 4 5 6) '(1 2 3 4)) ;=> (1 3 4 5 6 6)
;# Requires split-at to work correctly.
(define (replace-subseq start length replacement xs)
  (let*((t (split-at start xs)))
    (concat (car t) replacement (drop length (cadr t)))))

;## Function: all?
;# all? : (any -> bool) -> collection -> bool
;# Check whether a predicate is true for all elements in a collection xs.
;# Requires empty?, first, rest and drop-while/drop-until to work.
(define (all? p xs)
  (empty? (drop-while p xs)))

;## Function: none?
;# none? : (any -> bool) -> collection -> bool
;# Check whether a predicate is true for no elements in a collection xs.
;# Requires empty?, first, rest and drop-while/drop-until to work.
(define (none? p xs)
  (empty? (drop-until p xs)))

;## Function: any?
;# any? : (any -> bool) -> collection -> bool
;# Check whether a predicate is true for at least 1 element in a collection xs.
;# Requires empty?, first, rest and drop-while/drop-until to work.
(define (any? p xs)
  (cond (empty? xs) #f
        (p (first xs)) #t
        else (any? p (rest xs))))

;## Function: count-by
;# count-by : (any -> bool) -> collection -> int
;# Count how many elements in xs satisfy predicate p.
;# Required: foldl
(define (count-by p xs)
  (foldl (lambda (res x) (if (p x) (+ res 1) res)) 0 xs))

;## Function: most?
;# most? : (any -> bool) -> collection -> bool
;# Check whether more than half of the elements of a collection satisfy a predicate p.
;# Required: size, count-by
(define (most? p xs)
  (> (count-by p xs) (/ (size xs) 2)))

;## Function: zip-with
;# zip-with : (any -> any -> any) -> sequence -> sequence -> list
;# zip the elements of two collections with a function.
;#   (zip-with + '(1 2 3) '(4 5 6)) ;=> (5 7 9)
;#   (zip-with list '(1 2 3) '(4 5 6)) ;=> ((1 4) (2 5) (3 6))
;# Required for both l0 and l1: empty?, first, rest
(define (zip-with f l0 l1)
  (if (or (empty? l0) (empty? l1))
    '()
    (lazy-seq (f (first l0) (first l1)) (zip-with f (rest l0) (rest l1)))))

;## Function: zip
;# zip : sequence -> sequence -> list
;# zip the elements of two collections using list.
;#   (zip '(1 2 3) '(4 5 6)) ;=> ((1 4) (2 5) (3 6))
;# Required for both l0 and l1: empty?, first, rest
(define (zip l0 l1)
  (zip-with list l0 l1))
  
;## Function: zip-to-index
;# zip-to-index : sequence -> list
;# zip the elements of a collection to their indices.
;#   (zip-to-index '(9 8 7)) ;=> ((0 9) (1 8) (2 7))
;# Requires map-indexedd to work.
(define (zip-to-index xs)
  (map-indexed (lambda (x i) (list i x)) xs))

;## Function: v-zip-with
;# v-zip-with : ([any]* -> any) -> sequence -> list
;# Similar to zip, but takes a sequence of sequences to zip.
;# The output is always a list.
;# Stops when all sequences are empty.
;#  (v-zip-with v+ '((1 2 3) (4 5 6) (7 8 9))) ;=> (12 15 18)
;#  (v-zip-with v+ '((1 2 3) (4) (7 8 9))) ;=> (12 10 12)
;#  (v-zip-with v+ '((1 2 3) (4 5 6 10) (7 8 9))) ;=> (12 15 18 10)
;# Required for xs: map-eager, all?
;# Required for inner sequences: first, empty?, rest
(define (v-zip-with f xs)
  (if (all? empty? xs)
    '()
    (cons (apply-to f (map-eager first xs)) (v-zip-with f (remove empty? (map-eager rest xs))))))

;## Function: split-by
;# split-by : (any -> bool) -> sequence -> list
;# Split a sequence each time as predicate is true for the current element.
;# Always returns a list.
;#   (split-by (lambda (x) (= x 1)) '(5 1 2 3 1 6)) ;=> ((5) (2 3) (6))
;# Required: foldr
(define (split-by f xs)
  (foldr
    (lambda (x v) (if (f x) (cons '() v) (cons (cons x (car v)) (cdr v))))
    (list '())
    xs))

;## Function: split
;# split : any -> sequence -> list
;# Split at each occurance of v in xs.
;# Requires split-by to work for xs.
;# Requires eq? to be defined for v.
(define (split v xs)
  (split-by (lambda (x) (eq? v x)) xs))

;## Function: repeatedly
;# repeatedly : (() -> any) -> list
;# Repeatedly execute f in a lazy sequence.
(define (repeatedly f)
  (lazy-seq (f) (repeatedly f)))

;## Function: repeat
;# repeat : any -> list
;# Create an infinite sequence of the same element e.
(define (repeat e)
  (lazy-seq e (repeat e)))

;## Function: iterate
;# iterate : (any -> any) -> any -> list
;# Typical iterate function creating an infinite sequence.
;#   (take 5 (iterate inc 0) => (0 1 2 3 4)
;#   (take 3 (iterate list '()) => (() (()) ((())))
(define (iterate f e)
  (lazy-seq e (iterate f (f e))))

;## Function: cycle
;# cycle : sequence -> list
;# Create an infinite sequence repeating the elements of xs.
;#   (take 5 (cycle '(1 2)))) ;=> (1 2 1 2 1)
;# Required: empty?, first, rest
(define (cycle xs)
  (if (empty? xs)
    '()
    (lazy-seq (first xs) (list-concat (rest xs) (cycle xs)))))

; Variadic variant for all?
;## Function: va-all?
;# va-all? : (any -> bool) -> [any]* -> bool

(define (va-all? p & xs) (all? p xs))
; Variadic variant for none?
;## Function: va-none?
;# va-none? : (any -> bool) -> [any]* -> bool

(define (va-none? p & xs) (none? p xs))
; Variadic variant for any?
;## Function: va-any?
;# va-any? : (any -> bool) -> [any]* -> bool
(define (va-any? p & xs) (any? p xs))

;## Function: concat
;# concat : collection -> [collection]* -> list
;# Append any number of sequences to each other.
;# Required: append, foldr1
(define (concat x & xs)
  (if (list? (car xs))
    (apply-to list-concat (cons x xs))
    (foldr1 append (cons x xs))))

;## Function: divmod
;# divmod : any -> any -> list
;# (divmod x y) ;=> (list (/ x y) (rem x y))
(define (divmod x y) (list (/ x y) (rem x y)))

;## Function: constantly
;# constantly : any -> ([any]* -> any)
;# Returns a function which always returns x.
(define (constantly x) (lambda (& ys) x))

;## Function: const
;# const : any -> ([any]* -> any)
;# Alias for constantly.
(define const constantly)

;## Function: T
;# T : ([any]* -> bool)
;# Always true
(define T (constantly #t))

;## Function: F
;# F : ([any]* -> bool)
;# Always false
(define F (constantly #f))


(define (%interleave xss)
  (if (all? empty? xss)
    '()
    (let*((ys (map first xss)))
      (lazy-seq (car ys) (concat (cdr ys) (%interleave (map rest xss)))))))
;## Function: interleave
;# interleave : collection -> [collection]* -> list
(define (interleave xs & xss)
  (%interleave (cons xs xss)))

;## Function: min
;# min : any -> any -> any
;# Get minimum of n m (using < or >)
(define (min n m) (if (< n m) n m))
;## Function: max
;# max : any -> any -> any
;# Get maximum of n m (using < or >)
(define (max n m) (if (< n m) m n))

(define (%dedupe prev xs)
  (cond (empty? xs) '()
        (eq? (first xs) prev) (%dedupe prev (rest xs))
        else (lazy-seq (first xs) (%dedupe (first xs) (rest xs)))))
;# dedupe : collection -> collection
;# Remove consecutive duplicates from a sequence.
;# If either set? or map? is true for xs, do nothing and return xs.
;# Required: empty?, first, rest
(define (dedupe xs)
  (cond (or (set? xs) (map? xs)) xs
        (empty? xs) '()
        else (lazy-seq (first xs) (%dedupe (first xs) (rest xs)))))

;## Function: cartesian-product
;# cartesian-product : sequence -> sequence -> list
(define (cartesian-product lst0 lst1)
  (mapcat (lambda (x) (zip (repeat x) lst1)) lst0))

;## Function: partition-by
;# partition-by : (any -> any) -> collection -> list
(define (partition-by f coll)
  (if (empty? coll)
    '()
    (let* ((lst1 (->list coll))
           (expect (f (car coll)))
           (%partition-by (lambda (res lst)
            (cond
              (empty? lst) (reverse res)
              (eq? (f (car lst)) expect)
                (%partition-by (cons (car lst) res) (cdr lst))
              else (reverse res))))
           (pb-head (%partition-by '() lst1)))
      (lazy-seq pb-head (partition-by f (drop (size pb-head) lst1))))))

;; case macro

(define (%case e n cases)
  (let* ((fc (first cases)))
    (cond
      (empty? cases) Nothing
      (= 1 (size cases)) (first cases)
      (and (not (symbol? (first cases))) (atom? (first cases)))
        (list 'if (list 'eq? fc e) (second cases) (%case e n (rest (rest cases))))
      (and (not (list? (first cases))) (collection? (first cases)))
        (list 'if (list 'contains? fc e) (second cases) (%case e n (rest (rest cases))))
      else
        (list 'let* (list (list n (first cases)))
          (list 'cond
            (list 'and (list 'collection? n) (list 'contains? n e)) (second cases)
            (list 'and (list 'function? n) (list n e)) (second cases)
            (list 'eq? n e) (second cases)
            'else (%case e n (rest (rest cases))))))))

;## Macro: case
;# case : expr -> [any, expr]* -> expr
(defmacro (case e & cases)
  (let* ((n (gensym 'case))
        (e-name (gensym 'case-elem)))
    (list 'let* (list (list e-name e)) (%case e-name n cases))))




;;; SECTION: List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

;## Function: xcons
;# xcons : [any]* -> list
;# repeatedly apply cons to a list.
;# (xcons 1 2 3 4 '(5 6)) ;=> (1 2 3 4 5 6)
;# (xcons 1 2 '(3)) is equivalent to (cons 1 (cons 2 '(3)))
(define (xcons & args) (foldr1 cons args))

;## Function: flatten
;# flatten : collection -> list
;# Flatten a collection.
;# Required: collection?, foldr, append
;# Could use some optimization
(define (flatten xs)
  (if (collection? xs)
    (foldr append '() (map flatten xs))
    (list xs)))

;## Function: flatten1
;# flatten1 : collection -> list
;# Flatten by one level.
;# Required: map
;# Could use some optimization
(define (flatten1 xs)
  (apply-to list-concat (map (lambda (x) (if (collection? x) (->list x) (list x))) xs)))

;## Function: range
;# range : int -> int -> list
;# Lazily create a range of the numbers between from and to (inclusive)
(define (range from to)
  (if (> from to)
    '()
    (lazy-seq from (range (inc from) to))))

;## Function: indices-of
;# indices-of : sequence -> any -> list
;# Get the indices of all occuranges of elem in seq.
;# Required for seq: foldr-indexed
;# Required for elements in seq: eq?
(define (indices-of seq elem)
  (foldr-indexed
    (lambda (c acc i) (if (eq? c elem) (cons i acc) acc))
    '() seq))

;## Function: doall!
;# doall! : collection -> list
;# Evaluate a list
(define (doall! xs)
  (let* ((ys (->list xs)))
    (if (empty? ys)
      ys
      (doall! (cdr ys))))
  xs)

;## Function: fact-seq
;# fact-seq : () -> list
;# Sequence of the factorial numbers, starting at 0.
;# (yes, it says 1, but starts at 0)
(define (fact-seq)
  (map cadr
    (iterate
      (lambda (p)
        (list (inc (car p)) (* (car p) (cadr p))))
      '(1 1))))


;## Function: scanr
;# scanr : (any -> any -> any) -> any -> collection -> list
;# Intermediate results of foldr as a lazy sequence
;#   (scanr + 5 '(1 2 3 4)) ;=> (15 14 12 9 5)
;# Required: empty?, first, rest
(define (scanr f v xs)
  (if (empty? xs)
    (list v)
    (let* ((r (scanr f v (rest xs))))
      (lazy-seq (f (first xs) (first r)) r))))

;## Function: scanr1
;# scanr : (any -> any -> any) -> collection -> list
;# Intermediate results of foldr1 as a lazy sequence
;#   (scanr1 + '(1 2 3 4 5)) ;=> (15 14 12 9 5)
;# Required: empty?, first, rest, size
(define (scanr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (list (first xs))
        else (let* ((r (scanr1 f (rest xs))))
              (lazy-seq (f (first xs) (first r)) r))))

;## Function: frequencies
;# frequencies : collection -> map
;# Map of the number of occurances of each item in a collection.
;# Required: foldl
(define (frequencies xs)
  (foldl
    (lambda (acc x)
      (let* ((v (or (map-get acc x) 0)))
        (map-set acc x (inc v))))
    {} xs))

(define (%unique xs acc vals)
  (cond (empty? xs) acc
        (contains? vals (first xs)) (%unique (rest xs) acc vals)
        else (%unique (rest xs) (lazy-seq (first xs) acc) (set-add vals (first xs)))))
;## Function: unique
;# unique : collection -> list
;# Get a sequence with its duplicates removed.
;# Required: empty?, first, rest
(define (unique xs)
  (reverse (%unique xs '() (set-of))))

; Check whether (eq? xs (unique xs))
; Required: eq? 
;## Function: unique?
;# unique? : collection -> bool
(define (unique? xs)
  (eq? xs (unique xs)))

;## Function: tuples
;# tuples : int -> collection -> list
;# (tuples 3 '(1 2 3 4 5)) ;=> ((1 2 3) (2 3 4) (3 4 5))
;# Required: size, take, rest
(define (tuples n xs)
  (cond 
    (= n 0) '()
    (< (size xs) n) '()
    else (lazy-seq (take n xs) (tuples n (rest xs)))))

;## Function: slices
;# slices : int -> collection -> list
;# (slices 3 '(1 2 3 4 5 6)) ;=> ((1 2 3) (4 5 6))
;# Required: size, take, drop
(define (slices n xs)
  (cond
    (= n 0) '()
    (< (size xs) n) '()
    else (lazy-seq (take n xs) (slices n (drop n xs)))))

;## Function: partition-all
;# partition-all : int -> collection -> list
;# (partition-all 2 [0 1 2 3 4 5])) ;=> ((0 1) (2 3) (4 5))
;# Required: empty?, take, drop
(define (partition-all n xs)
  (cond
    (= n 0) '()
    (empty? xs) '()
    else (lazy-seq (take n xs) (partition-all n (drop n xs)))))

; Helper for permutations
(define (%insert l n e)
  (if (= 0 n)
    (cons e l)
    (cons (car l) 
          (%insert (cdr l) (- n 1) e))))
;## Function: permutations
;# permutations : sequence -> list
;# Calculate all permutations of a collection.
;# Requires only ->list to be defined.
(define (permutations l0)
  (let* ((l (->list l0)))
    (if (null? l)
      '(())
      (apply-to concat
        (map (lambda (p)
              (map (lambda (n)
                      (%insert p n (car l)))
                    (range 0 (size p))))
            (permutations (cdr l)))))))

;## Function: get-in
;# get-in : collection -> sequence -> any
;# Get an item from xs after calling get on it for each item in ks.
;#   (get-in [1 [2 [3]]] '(0)) ;=> 1
;#   (get-in [1 [2 [3]]] '(1 0)) ;=> 2
;#   (get-in [1 [2 [3]]] '(1 1)) ;=> [3]
;#   (get-in [1 [2 [3]]] '(1 1 0)) ;=> 3
;# Required for xs: get
;# Required for ks: empty?, first, rest
(define (get-in xs ks)
  (cond (empty? ks) xs
        (get-in (get xs (first ks)) (rest ks))))

(define (%condp p e cases)
  (let* ((c (first cases)))
    (cond 
      (empty? cases) Nothing
      (= 1 (size cases)) c
      else (list 'if
            (list p c e) (second cases)
            (%condp p e (rest (rest cases)))))))
;## Macro: condp
;# condp : (any -> any -> bool) -> expr -> [(expr, expr)]* -> expr´
;# (let* ((f0 (lambda (e) (condp <= e  1 0  5 9  11))))
;#   (f0 0) ; 0
;#   (f0 1) ; 0
;#   (f0 3) ; 9
;#   (f0 6)) ; 11 ; default
(defmacro (condp p e & cases)
  (let* ((n (gensym 'condp)))
    (list 'let* (list (list n e)) (%condp p n cases))))

;;; SECTION: Flow control macros

;## Macro: ->
;# -> : expr -> [expr]* -> expr
;# As in Clojure.
(defmacro (-> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (xcons (car expr) acc (cdr expr)) (list expr acc))) x exprs))

;## Macro: ->>
;# ->> : expr -> [expr]* -> expr
;# As in Clojure.
(defmacro (->> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (append expr (list acc)) (list expr acc))) x exprs))

(define (%as-> name x exprs)
  (if (empty? exprs)
    x
    (list 'let* (list (list name x)) (%as-> name (car exprs) (cdr exprs)))))
;## Macro: as->
;# as-> : symbol -> expr -> [expr]* -> expr
;# As in Clojure.
(defmacro (as-> name x & exprs)
  (%as-> name x exprs))

;## Macro: compute*->
;# compute*-> : expr -> expr -> expr -> [expr]* -> expr
;# Similar to '->> but stops when the value becomes
;# Nothing or an exception is thrown.
;# if the value becomes nothing, default is returned.
;# if an error is thrown, error-default is returned
;#   (compute*-> 'default 'error 1 inc inc inc)  ; => 4
;#   (compute*-> 'default 'error 1 (+ 3) inc))   ; => 5
;#   (compute*-> 'default 'error 1 ->list first) ; => default
;#   (compute*-> 'default 'error 0 throw! inc)   ; => error
;#   (compute*-> 'default 'error "r")            ; => "r"
(defmacro (compute*-> default error-default m & funcs)
  (let* ((n (gensym 'compute)))
    (cond
      (not funcs) m
      m `(try*
          (let* ((~n ~m))
            (if ~n
              ~(xcons 'compute*-> default error-default
                (if (list? (car funcs))
                  (list-concat (car funcs) (list n))
                  (list (car funcs) n))
                (cdr funcs))
              ~default))
          (catch id e ~error-default))
      else default)))
      

;## Macro: compute->
;# compute-> : expr -> [expr]* -> expr
;# Like compute*-> but the special cases all return Nothing.
;#   (compute-> 1 inc inc inc)  ; => 4
;#   (compute-> 1 (+ 3) inc))   ; => 5
;#   (compute-> 1 ->list first) ; => Nothing
;#   (compute-> 0 throw! inc)   ; => Nothing
;#   (compute-> "r")            ; => "r"
(defmacro (compute-> m & funcs)
  `(compute*-> Nothing Nothing ~m ~@funcs))

;;; SECTION: quasiquote

;## Macro: quasiquote
;# quasiquote : expr -> expr
;# Quotes an expression. Sub-sxpressions can be unquoted using unquote and unquote-splicing.
(defmacro (quasiquote expr)
  (cond
    (not expr)
      '()
    (not (list? expr))
      (list 'quote expr)
    else
      (let* ((fst (car expr)))
        (cond
          (= fst 'unquote)
            (cadr expr)
          (and (list? fst) (= (car fst) 'unquote-splicing)) 
            (list 'concat (second fst) (list 'quasiquote (cdr expr)))
          else
            (list 'cons (list 'quasiquote (car expr)) (list 'quasiquote (cdr expr)))))))

;;; SECTION: case-lambda

(define (%cl-arg-nums args)
  (if (and (> (size args) 2) (= (nth args (- (size args) 2)) '&))
    (list (- (size args) 2) -1)
    (list (size args) (size args))))

(define (%cl-form form arg-name)
  (let* ((form-args (car form))
         (arg-nums (%cl-arg-nums form-args)))
    (if (list? (car form))
      (cond
        (= (cadr arg-nums) 0)
          `((= (size ~arg-name) 0) (begin ~@(cdr form)))
        (= (cadr arg-nums) -1)
          `((>= (size ~arg-name) ~(car arg-nums)) (let ((~form-args ~arg-name))  ~@(cdr form)))
        else
          `((= (size ~arg-name) ~(car arg-nums)) (let ((~form-args ~arg-name)) ~@(cdr form))))
      `(else (let ((~form-args ~arg-name)) ~@(cdr form))))))

(define (%case-lambda cl-name forms)
  (let* ((args (gensym 'cl-args)))
  `(lambda* ~cl-name
      (& ~args)
      (cond
        ~@(mapcat (lambda (form) (%cl-form form args)) forms)
        else (error! (string-concat "invalid number of arguments for function " ~cl-name ". Got " (size ~args)) 'syntax)))))

;## Macro: case-lambda
;# case-lambda : (expr, expr) -> [(expr, expr)]* -> expr
;# case-lambda* without a necessary name. Supports destructuring.
(defmacro (case-lambda form1 & forms)
  (%case-lambda (gensym 'case-lambda) (cons form1 forms)))

;## Macro: case-lambda*
;# case-lambda* : symbol -> (expr, expr) -> [(expr, expr)]* -> expr
;# Create a multi-function:
;# (define f (case-lambda* f
;#   (() "0") ; 0 args
;#   ((x) "1") ; 1 arg
;#   ((x y) "2") ; 2 args
;#   ((w x y z & zs) "4 or more") ; 4+ args
;#   (default "3"))) ; Varargs going into a list called 'default
;# When called, the function decides which function to call by the number of arguments it got.
;# (list (f) (f 6) (f 6 7) (f 6 7 8 9) (f 5 4 3)) ; ("0" "1" "2" "4 or more" "3")
(defmacro (case-lambda* cl-name form1 & forms)
  (%case-lambda cl-name (cons form1 forms)))

;;; SECTION Utilities using case-lambda

;## Function: sum
;# sum : collection -> number
;# sum : (number -> number) -> collection -> number
;# Sum up elements of a collection using +.
;# Required: foldl, map
(define sum
  (case-lambda* sum
    ((coll) (foldl + 0 coll))
    ((f coll) (foldl + 0 (map f coll)))))

;## Function: product
;# product : collection -> number
;# product : (number -> number) -> collection -> number
;# Calculate the product of the elements of a collection using *.
;# Required: foldl, map
(define product
  (case-lambda* product
    ((coll) (foldl * 1 coll))
    ((f coll) (foldl * 1 (map f coll)))))

;## Function: minimum
;# minimum : collection -> any
;# minimum : (any -> any) -> collection -> any
;# Get minimum of the elements in a sequence using min/max.
;# Required: foldl1, map
(define minimum
  (case-lambda* minimum
    ((coll) (foldl1 min coll))
    ((f coll) (min (map f coll)))))
;## Function: minimum
;# minimum : collection -> any
;# minimum : (any -> any) -> collection -> any
;# Get maximum of the elements in a sequence using min/max.
;# Required: foldl1, map
(define maximum
  (case-lambda* maximum
    ((coll) (foldl1 max coll))
    ((f coll) (max (map f coll)))))

;## Function: xrange
;# xrange : () -> list
;# xrange : int -> list
;# xrange : int -> int -> list
;# xrange : int -> int -> int -> list
;# Extended range function.
;# Takes 0 to 3 input numbers.
;# Arity | Output
;# 0     | Infinite sequence starting at 0 and counting up.
;# 1     | Infinite sequence starting at from.
;# 2     | Lazy sequence counting from 'from' to 'to'.
;# 3     | Lazy sequence counting from 'from' to 'to'
;#       | If stop is a function, it is repeatedly applied to the current value of from until (>= from to).
;#       | Otherwise, step is repeatedly added to from using +.
(define xrange
  (case-lambda* xrange
    (() (iterate inc 0))
    ((from) (iterate inc from))
    ((from to) (xrange from to inc))
    ((from to step)
      (cond
        (>= from to) '()
        (function? step) (lazy-seq from (xrange (step from) to step))
        else (lazy-seq from (xrange (+ from step) to step))))))

;## Function: into
;# into : () -> list
;# into : collection -> collection
;# into : collection -> collection -> collection
;# into : collection -> (collection -> collection) -> collection -> collection
;# Add items from 'from' to 'to', keeping the type of 'to'. (if add is correctly defined)
;#   (into) ;=> () ; empty input -> empty list
;#   (into '(1 2)) ;=> (1 2)
;#   (into [1 2] '(3 4)) ;=> [1 2 3 4]
;#   (into [1 2] unique '(3 3 4 3)) ;=> [1 2 3 4]
;# The last case works well for partials:
;#   (let* ((f (partial into [1 2] unique))) ...)
;# Required: foldl, add
(define into
  (case-lambda* into
    (() '())
    ((to) to)
    ((to from) (foldl add to from))
    ((to f from) (foldl add to (f from)))))

(define (%partition n step pad xs)
  (cond
    (= n 0) '()
    (< (size xs) n) ; FIXME / TODO: Does not work for infinite sequences!
      (if (empty? pad)
        '()
        (list (list-concat xs (take (- n (size xs)) pad))))
    else (lazy-seq (take n xs) (%partition n step pad (drop step xs)))))
;## Function: partition
;# partition : int -> collection -> list
;# partition : int -> int -> collection -> list
;# partition : int -> int -> collection -> collection -> list
;# Partition function
;# Required: size, take, drop
;#  (partition 3 [1 2 3 4])) ;=> ((1 2 3))
;#  (partition 3 [1 2 3 4 5 6])) ;=> ((1 2 3) (4 5 6))
;#  (partition 1 [1 2 3 4 5 6])) ;=> ((1) (2) (3) (4) (5) (6))
;#  (partition 0 [1 2 3 4 5 6])))) ;=> ()
(define partition
  (case-lambda* partition
    ((n xs) (%partition n n '() xs))
    ((n step xs) (%partition n step '() xs))
    ((n step pad xs) (%partition n step pad xs))))

;;; SECTION: try-catch-finally

;## Macro: try
;# try : expr -> [expr]* -> expr
;# Extended try*-catch with finally.
;# Can handle multiple catch-clauses.
;# (try (error! 'h 'not-that)
;#   (catch (lambda (e) (eq? 'syntax (error-info e))) e 'error1)
;#   (catch _ e 'error2)
;#   (finally (box-set! b 25)))
;#   ;=> 'error2
(defmacro (try f0 & fs)
  (let* ((forms (split-unless
                (lambda (f) (and (list? f) (eq? (car f) 'catch)))
                (cons f0 fs)))
         (body (car forms))
         (_ (if (all?
                (lambda (f)
                  (and
                    (list? f)
                    (or (eq? (car f) 'catch)
                      (eq? (car f) 'finally))))
                (cadr forms))
              #t
              (error! "Syntax error: Invalid format for try-catch-finally" 'syntax)))
         (catch-finally (split-unless
                        (lambda (f) (eq? (car f) 'finally))
                        (cadr forms)))
         (catch-clauses (car catch-finally))
         (finally-clause (cadr catch-finally))
         (res-name (gensym 'try))
         (err-name (gensym 'error)))
    `(try*
      (let* ((~res-name 
        ~(foldl (lambda (bd ct) (list 'try* bd ct)) `(begin ~@body) catch-clauses)))
        ~(if (empty? finally-clause) Nothing `(begin ~@(cdar finally-clause)))
        ~res-name)
      (catch ~(constantly #t) ~err-name
        ~(if (empty? finally-clause) Nothing `(begin ~@(cdar finally-clause)))
        (error! (error-msg ~err-name) (error-info ~err-name) (error-trace ~err-name))))
    ))

;;; SECTION: loop macros

;## Macro: loop
;# loop : list|vector -> [expr]* -> expr
;# loop macro similar to clojure. Supports destructuring.
;# (loop [(a b) '(1 2) res 0]
;#   (if (> res 0) res (recur '() (+ a b))))
;# ;=> 3
(defmacro (loop bindings & body)
  (let*((binds (if (vector? bindings) (slices 2 bindings) bindings))
        (name (gensym 'loop))
        (args (map first binds))
        (vals (map second binds)))
    (if (any? (comp (partial /= 2) size) binds)
      (error! "Invalid number of members in loop binding." 'syntax)
      `((lambda' ~name ~args ~@body)
        ~@vals))))

;## Macro: loop
;# loop : list|vector -> [expr]* -> expr
;# Simplified loop without destructuring
(defmacro (loop1 bindings & body)
  (let*((binds (if (vector? bindings) (slices 2 bindings) bindings)))
    (if (any? (comp (partial /= 2) size) binds)
      (error! "Invalid number of members in loop binding." 'syntax)
      `((lambda* ~(gensym 'loop) ~(map first binds) ~@body)
        ~@(map second binds)))))

;## Function: times
;# times : (any -> any) -> int -> (any -> any)
;# Creates a function which takes one argument and applies f to it n times.
;# (let* ((f (times inc 6)))
;#   (f 9) ;=> 15
;#   ((times inc 0) 9)) ;=> 9
(define (times f n)
  (lambda (x) (loop ((n1 n) (y x)) (if (<= n1 0) y (recur (dec n1) (f y))))))


(define (%walk-with-path f coll _path)
  (cond
    (vector? coll)
    (->vector
      (map-indexed
        (lambda (v i)
          (let* ((path (cons i _path)))
            (%walk-with-path f (f v path) path)))
        coll))

    (sequence? coll)
    (map-indexed
      (lambda (v i)
        (let*((path (cons i _path)))
          (%walk-with-path f (f v path) path)))
      coll)

    (set? coll)
    (->set
    (map-indexed
      (lambda (v i)
        (let*((path (cons i _path)))
          (%walk-with-path f (f v path) path)))
      coll))

    (map? coll)
    (->map (flatten1
    (map-indexed
      (lambda (v i)
        (let*((path (cons i _path)))
          (%walk-with-path f (f v path) path)))
      coll)))

    ; coll is not a collection
    else (f coll _path)
    ))
;## Function: walk-with-path
;# walk-with-path : (any -> list) -> collection -> collection
;# Not even in testing yet!
(define (walk-with-path f xs)
  (%walk-with-path f xs '()))


;;; SECTION: for macro

(define (%combinations x xs)
  (cond
    (empty? xs) (list x)
    (empty? (rest xs)) (map (lambda (y) (cons y x)) (first xs))
    else (mapcat (lambda (a) (%combinations (cons a x) (rest xs))) (first xs))))

;## Function: combinations
;# combinations : [sequence]* -> list
;# Lazily calculates all combinations of any number of lists while preserving order:
;# (combinations '(1 2) '(3 4) '(5 6)) 
;# => ((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))
(define (combinations & xs1)
  (let*((xs (remove empty? xs1)))
    (if (empty? xs)
      '()
      (map reverse (mapcat (lambda (x) (%combinations (list x) (rest xs))) (first xs))))))

(define (%for-lazy-take xs)
  (if (empty? xs)
    '()
    (let*((x (car xs)))
      (cond
        (car x) '() ; Ended with while
        (cadr x) (%for-lazy-take (cdr xs)) ; Ignores with when
        else (lazy-seq (caddr x) (%for-lazy-take (cdr xs)))))))
(define (%for-binds bindings)
  (if (vector? bindings)
    (if (odd? (size bindings))
      (error! "Syntax error: for must have an even number of bindings." 'syntax)
      (%for-binds (slices 2 bindings)))
    (let*((lets (map cadr (filter (lambda (b) (= (car b) :let)) bindings)))
          (whiles (map cadr (filter (lambda (b) (= (car b) :while)) bindings)))
          (whens (map cadr (filter (lambda (b) (= (car b) :when)) bindings)))
          (defs (remove (lambda (b) (set-includes? #{:let :while :when} (car b))) bindings)))
      (list defs lets whiles whens))))
(define (%for bindings body)
  (let* ((binds (%for-binds bindings))
          (defs (car binds))
          
          (lets (cadr binds))
          (whiles (caddr binds))
          (whens (cadddr binds)))
  `(~%for-lazy-take
    (map-split
      (lambda' ~(gensym 'for) ~(map car defs)
        (let ~(mapcat ->list lets)
          (cond
            ~@(concat
              (if (empty? whiles)
                '()
                (list
                  (list any? not (cons 'list whiles))
                  (list list #t Nothing Nothing)))
              (if (empty? whens)
                '()
                (list
                  (list any? not (cons 'list whens))
                  (list list #f #t Nothing)))
              (list else (cons 'list (list #f #f body)))))))
      (combinations ~@(map cadr defs))
      ))
      ))
;## Macro: for
;# for : list -> expr -> expr
(defmacro (for bindings body)
  (%for bindings body))

;;; SECTION: Destructuring macros

(define (%can-destructure? left)
  (cond (not (vector? left)) #t
        (not (map? left))    #t
        (not (list? left))   #t
        else                 #f))
(define (%let-destructure-list seq1 seq2 namestack)
  (let ((sym (gensym 'des)))
  (cond
    (not seq1) '()
    (= (car seq1) '&) (list (list (cadr seq1) seq2))
    (%can-destructure? (car seq1))
      (cons
        (list sym seq2)
        (concat
          (%let-destructure (car seq1) (list 'first sym)) ; Recursive inner destructure
          (%let-destructure-list (cdr seq1) (list 'rest sym) (cons sym namestack))))
    else
      (cons
        (list sym seq2)
        (cons (list (first seq1) (list 'first sym))
          (%let-destructure-list (cdr seq1) (list 'rest sym) (cons sym namestack)))))))

(define (%let-destructure-map m1 m2)
  (if (empty? m1)
    res
    (mapcat (lambda (e) (%let-destructure (second e) (list 'map-get m2 (first e)))) (->list m1))))

(define (%let-destructure left right)
  (cond
    (symbol? left)
      (list (list left right))
    (and (sequence? left) (not (empty? left)))
      (%let-destructure-list (->list left) right '())
    (and (map? left) (not (empty? left)))
      (%let-destructure-map left right)
    else
      (error! "parameter must be symbol, list, vector or map" 'syntax)))

;## Function: destructure
;# destructure : list -> list
;# (destructure (('(a b) '(1 2)))) ;=> ((sym0 '(1 2)) (a (first sym0)) (sym1 (rest sym0)) (b (first sym1)))
(define (destructure binds)
  (mapcat
    (lambda (e) (%let-destructure (first e) (second e)))
    binds))

;## Macro: let
;# let : list|vector -> [expr]* -> expr
(defmacro (let binds & body) ; let* with destructuring. Does not support :as yet.
  (if (vector? binds)
    (if (odd? (size binds))
      (error! "odd number of bindings for let" 'syntax)
      `(let ~(slices 2 binds) ~@body)) ; recursive call
    `(let* ~(destructure binds) ~@body)
    ))

;## Macro: define*
;# define* : [list|vector] -> [expr]* -> expr
;# Extended define.
;# Supports destructuring.
;# Will support keyword arguments in the future
(defmacro (define* binds & body)
  (let* ((bind-aliases (map #(gensym 'bind) (cdr binds))))
    `(define (~(car binds) ~@bind-aliases) (let ~(zip (cdr binds) bind-aliases) ~@body))))
    


;## Macro: lambda'
;# lambda' : list -> [expr]* -> expr
;# lambda' : symbol -> list -> [expr]* -> expr
;# Supports destructuring.
(defmacro (lambda' binds body1 & body)
  (let* ((named (symbol? binds))
        (name (if named binds (gensym 'lambda)))
        (binds (if named body1 binds))
        (body (if named body (cons body1 body)))
        (bind-aliases (map #(if (= %1 '&) '& (gensym 'bind)) binds)))
    (eval-seq! bind-aliases)
    `(lambda* ~name ~bind-aliases (let ~(remove #(= (car %1) '&) (zip binds bind-aliases)) ~@body))))
    

;;; SECTION: Parallel stuff

;## Function: par
;# par : [(() -> any)]* -> list
;# Run functions in parallel. Returns a list of delay objects
(define (par f0 & fs)
  (map delay (cons f0 fs)))

;## Macro par'
;# par' : [expr]* -> expr
;# Takes a list of expressions and wraps each in a lambda. These functions are then evaluated by the par function.
(defmacro (par' expr1 & exprs)
  `(par (lambda () ~expr1) ~@(map (lambda (e) `(lambda () ~e)) exprs)))

;## Macro par-with-timeout'
;# par-with-timeout' : expr -> [expr]* -> expr
;# Takes a number (timeout) and a list of expressions and wraps each in a lambda. These functions are then evaluated by the par-with-timeout function. Timeouts <= 0 mean an infinite timeout. (Might as well use par')
(defmacro (par-with-timeout' timeout expr1 & exprs)
  `(map (lambda (f) (delay-timeout ~timeout (delay f))) ((lambda () ~expr1) ~@(map (lambda (e) `(lambda () ~e)) exprs))))

;## Function: pmap'
;# pmap' : (any -> any) -> collection -> list
;# Parallel map. Returns a (lazy) list of delays.
(define (pmap' f xs)
  (map
    (lambda (x) (delay (lambda () (f x))))
    xs))

;## Function: pmap
;# pmap : (any -> any) -> collection -> list
;# Parallel map. Like pmap', but returns values, not delays.
;# Please do not use this yet. The current implementation is hopelessly broken
(define (pmap f xs)
  (map eager (chunk-map 8 (lambda (x) (delay (lambda () (f x)))) xs)))

;## Function: chunk-map
;# chunk-map : int -> (any -> any) -> collection -> list
;# Operates like map, but eagerly calculates each "chunk" once requested.
(define (chunk-map chunk-size f xs)
  (if (empty? xs)
    '()
    (let ((ys (map-eager f (take chunk-size xs))))
      (lazy-seq (car ys) (list-concat (cdr ys) (chunk-map chunk-size f (drop chunk-size xs))))
      )))

;## Macro: plet
;# plet : expr -> [expr]* -> expr
;# Parallel let. Supports destructuring.
(defmacro (plet binds & body)
  (let* ((names (map first binds))
         (vals (map second binds))
         (name-syms (map #(gensym 'name) names)))
    `(let ~(list-concat (zip name-syms vals) (zip names name-syms)) ~@body)))

;## Function: map-invert
;# map-invert : map -> map
;# Makes a map of key-value pairs into a map of value-key pairs.
;# This may loose information, so the following might not always hold:
;# (eq? m (map-invert (map-invert m)))
;# However, this feature is used often enough that including it makes sense.
(define (map-invert m)
  (foldl
    (lambda (res kv) (map-set res (second kv) (first kv)))
    (map-of) m))

;## Function: split-with
;# split-with : (any -> bool) -> sequence -> sequence
;# (split-with p xs) is the same as (list (take-while p xs) (drop-while p xs)).
(define (split-with p xs)
  (list (take-while p xs) (drop-while p xs)))

;## Function: group-by
;# group-by : (any -> any) -> collection -> map
(define (group-by f xs)
(foldl
  (lambda (acc x)
    (let ((y (f x)))
      (map-set acc y
        (if (map-has-key? acc y)
          (add (map-get acc y) x)
          (list x)))))
  (map-of)
  xs))

;## Function: scalar?
;# scalar? : any -> bool
;# Short for (and (atom? x) (not (symbol? x))).
(define (scalar? x)
  (and (atom? x) (not (symbol? x))))

;## Macro: letfn
;# letfn : sequence -> expr* -> expr
(defmacro (letfn binds & exprs)
  `(let ~(map (lambda (bind) (list (first bind) (cons lambda' bind))) binds) ~@exprs))

)

(load! "string.lyra")
(load! "vector.lyra")
(load! "set.lyra")

(cons 'core (list (import! "lyra.core.string", "") (import! "lyra.core.vector" "") (import! "lyra.core.set" "")))

