;;; Some core things

(define (list & xs)
  xs)

(def-macro (comment & xs) (nothing))

(def-macro (λ bindings & body)
  (cons 'lambda (cons bindings body)))

(define else #t)

(define (not x) (if x #f #t))
(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (list 'let1 (list 'x0 x) (list 'if 'x0 'x0 y)))

(define (odd? n) (= 1 (rem (->int n) 2)))
(define (even? n) (= 0 (rem (->int n) 2)))

(define (foldl f v xs)
  (if (empty? xs)
    v
    (foldl f (f v (first xs)) (rest xs))))

(define (foldl1 f xs)
  (cond ((empty? xs) Nothing)
        ((= (size xs) 1) (first xs))
        (else (foldl f (first xs) (rest xs)))))

(define (foldr f v xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr f v (rest xs)))))

(define (foldr1 f xs)
  (cond ((empty? xs) Nothing)
        ((= (size xs) 1) (first xs))
        (else (foldr f (first xs) (rest xs)))))

(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

(define (foldr-idx-helper f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr-idx-helper f v (inc i) (rest xs)) i)))
(define (foldr-indexed f v xs)
  (foldr-idx-helper f v 0 xs))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (not (p x))))

(def-macro (begin & exprs)
  (cons 'let (cons '() exprs)))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (cons 'lambda (cons (cdr name-bindings) body)))))

(define (map f xs) (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (mapcat f xs & ys) (foldr append '() (map f xs)))
(define (map-indexed f xs) (foldr-indexed (lambda (x v i) (cons (f x i) v)) '() xs))

(define (map-while f p xs) (map f (take-while p xs)))
(define (map-until f p xs) (map f (take-until p xs)))

(define (filter p xs) (foldr (lambda (x v) (if (p x) (cons x v) v)) '() xs))
(define (remove p xs) (filter (complement p) xs))

(define (filter-indexed p xs)
  (foldr-indexed (lambda (x v i) (if (p x i) (cons x v) v)) '() xs))
(define (remove-indexed p xs)
  (filter-indexed (lambda (x i) (not (p x i))) xs))

(define (fmap f p xs)
 (foldr
  (lambda (x v)
    (if (p x) (cons (f x) v) v))
  '() xs))
(define (mapf f p xs)
 (foldr
  (lambda (x v)
    (let1 (z (f x)) (if (p z) (cons z v) v)))
  '() xs))

(define (take-drop-h n st en)
  (if (or (= n 0) (empty? en))
    (list (->list st) (->list en))
    (take-drop-h (dec n) (vector-add st (first en)) (rest en))))
(define (take-drop n xs)
  (take-drop-h n [] xs))
  
(define (take-drop-until-h p st en)
  (if (or (empty? en) (p (first en)))
    (list (->list st) (->list en))
    (take-drop-until-h p (vector-add st (first en)) (rest en))))
(define (take-drop-until p xs)
  (take-drop-until-h p [] xs))

(define (take-drop-while p xs)
  (take-drop-until-h (complement p) [] xs))

(define (take n xs)
  (cond ((= n 0) '())
        ((empty? xs) '())
        (else (cons (first xs) (take (- n 1) (rest xs))))))
(define (take-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (cons (first xs) (take-while p (rest xs))))
        (else '())))
(define (take-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) '())
        (else (cons (first xs) (take-until p (rest xs))))))

(define (drop n xs)
  (cond ((= n 0) xs)
        ((empty? xs) '())
        (else (drop (- n 1) (rest xs)))))
(define (drop-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (drop-while p (rest xs)))
        (else xs)))
(define (drop-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) xs)
        (else (drop-until p (rest xs)))))

(define (all? p xs)
  (= (size (drop-while p xs)) 0))
(define (none? p xs)
  (= (size (drop-until p xs)) 0))
(define (any? p xs)
  (cond ((empty? xs) #f)
        ((p (first xs)) #t)
        (else (any? p (rest xs)))))

(define (zip-with f l0 l1)
  (if (or (empty? l0) (empty? l1))
    '()
    (cons (f (first l0) (first l1)) (zip-with f (rest l0) (rest l1)))))

(define (zip l0 l1)
  (zip-with list l0 l1))

(define (included? e s)
  (contains? s e))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

(define (concat & xs)
  (cond ((empty? xs) '())
        ((list? (first xs)) (foldr append '() xs))
        ((null? (first xs)) (foldr append '() xs))
        (else (foldl1 append xs))))

(define (v+ & xs) (foldl + 0 xs))

(define (fs x y) x)
(define (rs x y) y)

;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (reverse xs)
  (foldl (lambda (a b) (cons b a)) '() xs))

(define sum (partial foldl + 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))
(define (minimum xs) (foldl1 min xs))
(define (maximum xs) (foldl1 max xs))

(define (range from to)
  (if (> from to)
    '()
    (cons from (range (inc from) to))))

(define (indices-of seq elem)
  (foldr-indexed
    (lambda (c acc i) (if (eq? c elem) (cons i acc) acc))
    '() seq))

(define (bubble-up xs)
    (if (empty? (cdr xs))   
        xs
        (if (< (car xs) (cadr xs))
            (cons (car xs) (bubble-up (cdr xs)))   
            (cons (cadr xs) (bubble-up (cons (car xs) (cddr xs)))))))

(define (bubble-sort-aux n xs)    
  (let ((xs (->list xs)))
    (cond ((= n 1) (bubble-up xs))   
          (else (bubble-sort-aux (- n 1) (bubble-up xs))))))

(define (bubblesort xs)
  (if (or (empty? xs) (= 1 (size xs)))
    xs
    (bubble-sort-aux (size xs) xs)))

;;; Aliases
(define includes? contains?)
(define require! load!)
(define fold foldr)
(define reduce foldl)

(define ~ complement)
(define ⋅ compose)
(define ∀ all?)
(define ∃ any?)
(define ∄ none?)
(define ≥ >=)
(define ≤ <=)

(define ∈ included?)
(define ∉ (lambda (e s) (not (included? e s))))

;;; Aliases for Clojure devs.

(def-macro (when p & body)
  (list 'if p (cons 'begin (cons Nothing body)) (nothing)))

(def-macro (def name val)
  (list 'define name val))

(def-macro (defn name bindings & body)
  (cons 'define (cons (cons name (->list bindings)) body)))

(def-macro (fn bindings & body)
  (cons 'lambda (cons (->list bindings) body)))

(define do begin)
(define slurp! file-read!)
(define spit! file-write!)


'ok





