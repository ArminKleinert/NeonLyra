;;; Some core things

(def-macro (comment & xs) (nothing))

(define (list & xs)
  xs)

(define (not x) (if x #f #t))
(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (list 'let1 (list 'x0 x) (list 'if 'x0 'x0 y)))

(define (foldl f v xs)
  (if (empty? xs)
    v
    (foldl f (f v (first xs)) (rest xs))))

(define (foldr f v xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr f v (rest xs)))))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (p x)))

(def-macro (begin & exprs)
  (cons 'let (cons '() exprs)))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (cons 'lambda (cons (cdr name-bindings) body)))))

(define (map f xs) (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (filter p xs) (foldr (lambda (x v) (if (p x) (cons x v) v)) '() xs))
(define (remove p xs) (filter (complement p) xs))

(define (fmap f p xs)
 (foldr
  (lambda (x v)
    (if (p x) (cons (f x) v) v))
  '() xs))
(define (mapf f p xs)
 (foldr
  (lambda (x v)
    (let1 (z (f x)) (if (p z) (cons z v) v)))
  '() xs))

(define (take n xs)
  (cond ((= n 0) '())
        ((empty? xs) '())
        (#t (cons (first xs) (take (- n 1) (rest xs))))))
(define (take-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (cons (first xs) (take-while p (rest xs))))
        (#t '())))
(define (take-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) '())
        (#t (cons (first xs) (take-until p (rest xs))))))

(define (drop n xs)
  (cond ((= n 0) xs)
        ((empty? xs) '())
        (#t (drop (- n 1) (rest xs)))))
(define (drop-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (drop-while p (rest xs)))
        (#t xs)))
(define (drop-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) xs)
        (#t (drop-until p (rest xs)))))

(define (all? p xs)
  (= (size (drop-while p xs)) 0))
(define (none? p xs)
  (= (size (drop-until p xs)) 0))
(define (any? p xs)
  (cond ((empty? xs) #f)
        ((p (first xs)) #t)
        (#t (any? p (rest xs)))))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (reverse xs)
  (foldl (lambda (a b) (cons b a)) '() xs))

(define sum (partial foldl + 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))

(define (range from to)
  (if (> from to)
    '()
    (cons from (range (inc from) to))))

(define (bubble-up L)
    (if (empty? (cdr L))   
        L    
        (if (< (car L) (cadr L))
            (cons (car L) (bubble-up (cdr L)))   
            (cons (cadr L) (bubble-up (cons (car L) (cddr L)))))))

(define (bubble-sort-aux N L)    
  (let1 (xs (->list L))
    (cond ((= N 1) (bubble-up xs))   
          (#t (bubble-sort-aux (- N 1) (bubble-up xs))))))

(define (bubblesort xs)
  (bubble-sort-aux (size xs) xs))

;;; Aliases
(define includes? contains?)
(define require! load!)
(define fold foldr)
(define reduce foldl)

;;; Aliases for Clojure devs.

(def-macro (when p & body)
  (list 'if p (cons 'begin (cons Nothing body)) (nothing)))

(def-macro (def name val)
  (list 'define name val))

(def-macro (defn name bindings & body)
  (cons 'define (cons (cons name (->list bindings)) body)))

(def-macro (fn bindings & body)
  (cons 'lambda (cons (->list bindings) body)))

(define do begin)
(define slurp! file-read!)
(define spit! file-write!)

'ok

;(println! (bubblesort [6 4 3 2 1 7]))
