;;; Some core things

(def-macro (comment & xs) (nothing))

; Take 2 arguments, return the first
(define (fst x y) x)
; Take 2 arguments, return the second
(define (snd x y) y)

(define (list & xs)
  xs)

(def-generic xs (size xs) nothing)
(define ::list size list-size)
(define ::vector size vector-size)
(define ::string size string-size)
(define ::set size set-size)
(define ::map size map-size)

(def-generic xs (first xs) nothing)
(define ::list first car)
(define ::vector first (lambda (v) (vector-nth v 0)))
(define ::string first (lambda (v) (string-nth v 0)))
(define ::set first (lambda (s) (vector-nth (set->vector s) 0)))
(define ::map first (lambda (m) (vector-nth (map->vector m) 0)))

(def-generic xs (rest xs) nothing)
(define ::list rest cdr)
(define ::vector rest (lambda (v) (vector-range v 1 (vector-size v))))
(define ::string rest (lambda (v) (string-range v 1 (string-size v))))
(define ::set rest (lambda (s) (let ((v (set->vector s))) (vector-range v 1 (vector-size v)))))
(define ::map rest (lambda (m) (let ((v (mao->vector m))) (vector-range v 1 (vector-size v)))))

(def-generic xs (second xs) (lambda (xs) (first (rest xs))))

(def-generic xs (foldr f v xs) native-foldr)
(def-generic xs (foldl f v xs) native-foldl)

(define (last xs)
  (let ((l (->list xs)))
    (if (list? l) (first (drop (dec (size l)) l)) (nothing))))
(define (but-last xs)
  (let ((l (->list xs)))
    (if (list? l) (take (dec (size l)) l) (nothing))))

(define (empty? xs) (or (nothing? xs) (= (size xs) 0)))

(def-generic xs (append xs ys) native-append)
(def-generic xs (contains? xs e) native-contains?)
(def-generic xs (nth xs i) native-nth)

(define (seq-eq? l0 l1)
  (if (empty? l0)
    (empty? l1)
    (and (and (not (empty? l1)) (= (first l0) (first l1)))
         (seq-eq? (rest l0) (rest l1)))))

(def-generic x (eq? x y) =)
(define ::list eq? seq-eq?)
(define ::vector eq? (lambda (v o) (vector-eq? v (->vector o))))
(define ::set eq? set-eq?)
(define ::map eq? map-eq?)
(define ::string eq? string-eq?)

(def-generic x (->symbol x) native->symbol)
(def-generic x (->int x) native->int)
(def-generic x (->float x) native->float)
(def-generic x (->string x) native->string)
(def-generic x (->bool x) native->bool)
(def-generic x (->list x) native->list)
(def-generic x (->vector x) native->vector)
(def-generic x (->char x) native->char)
(def-generic x (->map x) native->map)
(def-generic x (->set x) native->set)

(def-generic x (collection? x)
  (lambda (xs) (or (list? xs) (or (vector? xs) (or (map? xs) (set? xs))))))
(def-generic x (sequence? x)
  (lambda (xs) (or (list? xs) (vector? xs))))
(def-generic x (number? x)
  (lambda (xs) (or (int? xs) (float? xs))))

(define symbol ->symbol)

(define else #t)

(define (not x) (if x #f #t))
(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (list 'let1 (list 'x0 x) (list 'if 'x0 'x0 y)))

(define (odd? n) (= 1 (rem (->int n) 2)))
(define (even? n) (= 0 (rem (->int n) 2)))

(define (foldl1 f xs)
  (cond ((empty? xs) Nothing)
        ((= (size xs) 1) (first xs))
        (else (foldl f (first xs) (rest xs)))))

(define (foldr1 f xs)
  (cond ((empty? xs) Nothing)
        ((= (size xs) 1) (first xs))
        (else (foldr f (first xs) (rest xs)))))

(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

(define (foldr-idx-helper f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr-idx-helper f v (inc i) (rest xs)) i)))
(define (foldr-indexed f v xs)
  (foldr-idx-helper f v 0 xs))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (not (p x))))

(def-macro (begin & exprs)
  (cons 'let (cons '() exprs)))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (cons 'lambda (cons (cdr name-bindings) body)))))

(define (spread xs)
  ((lambda (ys) (append (car ys) (caadr ys))) (take-drop (dec (size xs)) xs)))

(define (apply f & xs)
  (apply-to f (spread xs)))

(define (map f xs) (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (map-indexed f xs) (foldr-indexed (lambda (x v i) (cons (f x i) v)) '() xs))

(define (map-while f p xs) (map f (take-while p xs)))
(define (map-until f p xs) (map f (take-until p xs)))

(define (maplist f xs)
  (if (empty? xs)
    '()
    (cons (f xs) (maplist f (rest xs)))))

(define (mapcar f & ys)
  (let ((xs (remove empty? ys)))
    (if (empty? xs)
      '()
      (cons (apply f (map first xs)) (apply mapcar f (map rest xs))))))

(define (mapcon f xs)
  (foldr append '() (maplist f xs)))

(define (mapcat f xs)
  (foldr append '() (map f xs)))

(define (filter p xs) (foldr (lambda (x v) (if (p x) (cons x v) v)) '() xs))
(define (remove p xs) (filter (complement p) xs))

(define (filter-indexed p xs)
  (foldr-indexed (lambda (x v i) (if (p x i) (cons x v) v)) '() xs))
(define (remove-indexed p xs)
  (filter-indexed (lambda (x i) (not (p x i))) xs))

(define (fmap f p xs)
 (foldr
  (lambda (x v)
    (if (p x) (cons (f x) v) v))
  '() xs))
(define (mapf f p xs)
 (foldr
  (lambda (x v)
    (let1 (z (f x)) (if (p z) (cons z v) v)))
  '() xs))

(define (take-drop-h n st en)
  (if (or (= n 0) (empty? en))
    (list (->list st) (->list en))
    (take-drop-h (dec n) (vector-add st (first en)) (rest en))))
(define (take-drop n xs)
  (take-drop-h n [] xs))
  
(define (take-drop-until-h p st en)
  (if (or (empty? en) (p (first en)))
    (list (->list st) (->list en))
    (take-drop-until-h p (vector-add st (first en)) (rest en))))
(define (take-drop-until p xs)
  (take-drop-until-h p [] xs))

(define (take-drop-while p xs)
  (take-drop-until-h (complement p) [] xs))

(define (take n xs)
  (cond ((<= n 0) '())
        ((empty? xs) '())
        (else (cons (first xs) (take (- n 1) (rest xs))))))
(define (take-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (cons (first xs) (take-while p (rest xs))))
        (else '())))
(define (take-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) '())
        (else (cons (first xs) (take-until p (rest xs))))))

(define (drop n xs)
  (cond ((<= n 0) xs)
        ((empty? xs) '())
        (else (drop (- n 1) (rest xs)))))
(define (drop-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (drop-while p (rest xs)))
        (else xs)))
(define (drop-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) xs)
        (else (drop-until p (rest xs)))))

(define (all? p xs)
  (= (size (drop-while p xs)) 0))
(define (none? p xs)
  (= (size (drop-until p xs)) 0))
(define (any? p xs)
  (cond ((empty? xs) #f)
        ((p (first xs)) #t)
        (else (any? p (rest xs)))))

(define (v-zip-with f xs)
  (if (all? empty? xs)
    '()
    (cons (apply-to f (map first xs)) (v-zip-with f (map rest xs)))))

(define (zip-with f l0 l1)
  (if (or (empty? l0) (empty? l1))
    '()
    (cons (f (first l0) (first l1)) (zip-with f (rest l0) (rest l1)))))

(define (zip l0 l1)
  (zip-with list l0 l1))
  
(define (zip-to-index xs)
  (map-indexed (lambda (x i) (list i x)) xs))

(define (split-by f xs)
  (foldr
    (lambda (x v) (if (f x) (cons '() v) (cons (cons x (car v)) (cdr v))))
    (list '())
    xs))

(define (split v xs)
  (split-by (lambda (x) (eq? v x)) xs))

(define (included? e s)
  (contains? s e))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

(define (concat & xs)
  (foldl1 append xs))

(define (v+ & xs) (foldl + 0 xs))

;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (reverse xs)
  (foldl (lambda (a b) (cons b a)) '() xs))

(define sum (partial foldl + 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))
(define (minimum xs) (foldl1 min xs))
(define (maximum xs) (foldl1 max xs))

(define (range from to)
  (if (> from to)
    '()
    (cons from (range (inc from) to))))

(define (indices-of seq elem)
  (foldr-indexed
    (lambda (c acc i) (if (eq? c elem) (cons i acc) acc))
    '() seq))


;;; Aliases
(define includes? contains?)
(define require! load!)
(define fold foldr)

(def-macro (λ bindings & body)
  (cons 'lambda (cons bindings body)))

(define ~ complement)
(define ⋅ compose)
(define ∀ all?)
(define ∃ any?)
(define ∄ none?)
(define ≥ >=)
(define ≤ <=)

(define ∈ included?)
(define ∉ (lambda (e s) (not (included? e s))))

(require! "sort.lyra")

'ok

