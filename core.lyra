(module core
  (cond lambda T comment unwrap foldr foldl append contains? nth ->symbol ->int ->float ->rational ->string ->bool ->list ->vector ->char ->map ->set eq? size rest first second reverse compare collection? sequence? seq? number? print! println! flip fst snd list let1 (list-nth nth) last but-last empty? included? seq-eq? not-eq? symbol else and or odd? even? foldl1 foldl-indexed foldr1 foldr-indexed compose compose-or compose-and (comp compose) complement begin def-memo spread apply map map-split map-eager map-indexed map-while map-until maplist mapcar mapcon mapcat filter filter-indexed remove remove-indexed fmap mapf take-drop take-drop-until take-drop-while take take-while take-until drop drop-while drop-until subseq replace-subseq all? none? any? zip-with zip zip-to-index v-zip-with split-by split repeatedly repeat iterate va-all? va-none? va-any? concat v+ v- v* v/ v% caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr flatten flatten1 sum product inc dec min max minimum maximum range indices-of λ doall! fact-seq -> ->> as-> divmod constantly const case cycle case-lambda scanl scanl1 scanr scanr1 condp case-lambda* frequencies unique unique? add compose2 slices tuples partition-all xrange succ try count-by most? loop1 loop xcons v= v/= v< v> v<= v>= partition dedupe times prepend add-front permutations walk-with-path get get-in combinations for juxt every-pred find index-of cartesian-product delete-at quasiquote lazy-seq partition-by plet let lambda' conj take-nth interleave destructure name compute*-> compute->)

;;; Some core things

(defmacro (lambda binds & body)
  (cons 'lambda* (cons (gensym 'lambda) (cons binds body))))

(defmacro (cond & cases)
  (if cases
    (if (cdr cases)
      (list 'if (car cases) (car (cdr cases)) (cons 'cond (cdr (cdr cases))))
      (car cases))
    Nothing))

(defmacro (lazy-seq x & body)
  (list 'cons x (cons 'lambda (cons '() body))))

;(defmacro (if p t e) (list 'cond p t #t e))

; Take any arguments and return Nothing.
(defmacro (comment & _) (nothing))

; unbox a box or unpack a user-defined type.
; Can be overridden.
(def-generic x (unwrap x) buildin-unwrap)

; Standard implementation for foldr. Returns Nothing for atoms.
; Requires: empty?, first, rest
(define (%foldr f s xs)
  (if (atom? xs)
    Nothing
    (if (empty? xs)
      s
      (f (first xs) (%foldr f s (rest xs))))))

; Standard implementation for foldl. Returns Nothing for atoms.
; Requires: empty?, first, rest
(define (%foldl f s xs)
  (if (atom? xs)
    Nothing
    (if (empty? xs)
      s
      (%foldl f (f s (first xs)) (rest xs)))))

; Generics for foldr and foldl
(def-generic xs (foldr f v xs) %foldr)
(def-generic xs (foldl f v xs) %foldl)

; Standard implementation for add.
; Requires: append
(define (%add xs y)
  (append xs (list y)))

; Check whether a sequence xs contains an element e.
; Requires: empty?, first, rest
(define (%contains? xs e)
  (cond (empty? xs) #f
        (eq? (first xs) e) #t
        else (%contains? (rest xs) e)))

; Append all elements from a sequence ys to collection xs. Requires: ->list
(def-generic xs (append xs ys) (lambda (xs ys) (buildin-append (->list xs) (->list ys))))

; Reverse append. (append xs to ys)
(def-generic xs (prepend xs ys) (lambda (xs ys) (buildin-append ys xs)))

; Add an element y to the end of a collection xs.
(def-generic xs (add xs y) %add)

(define (conj c x & xs)
  (foldl add c (cons x xs)))

; Add an element y to the front of a sequence xs.
; Default implementation requires returns a list.
(def-generic xs (add-front xs y) (lambda (xs y) (cons y (->list xs))))

; Check whether the collection xs contains the element e.
(def-generic xs (contains? xs e) %contains?)

; Get element from sequence xs at index i (starts at 0). Requires ->list.
(def-generic xs (nth xs i)
  (lambda (xs i)
    (if (atom? xs)
      Nothing
      (let* ((xs0 (->list xs)))
          (if (or (empty? xs0) (<= i 0))
            (first xs0)
            (recur (rest xs0) (- i 1)))))))

; Get an element in a collection xs by its key k.
; The default behaviour uses nth, but it has to be overridden for maps and sets.
(def-generic xs (get xs k) nth)

(define (index-of v xs)
  (let* ((%iof (lambda (i xs)
            (if (empty? xs)
              0
              (let* ((c (first xs)))
                (if (eq? c v)
                  i
                  (recur (+ i 1) (rest xs))))))))
    (%iof 0 xs)))

; Find associated key or value for an element.
; index-of for lists and vectors, true or false for sets.
(def-generic xs (find v xs) (lambda (v xs) (index-of (seq xs))))

; Type conversions.
; Default conversions to collections require ->float to be implemented,
; Default conversions to collections require ->list.
(def-generic x (->symbol x) buildin->symbol)
(def-generic x (->int x) (lambda (x) (buildin->int (buildin->float x))))
(def-generic x (->float x) buildin->float)
(def-generic x (->rational x) (lambda (x) (buildin->rational (buildin->float x))))
(def-generic x (->string x) buildin->string) ; TODO
(def-generic x (->bool x) buildin->bool)
(def-generic x (->list x) buildin->list)
(def-generic x (->vector x) (lambda (x) (list->vector (->list x))))
(def-generic x (->char x) buildin->char)
(def-generic x (->map x) (lambda (x) (buildin->map (->list x))))
(def-generic x (->set x) (lambda (x) (list->set (->list x))))
(def-generic x (->keyword x) buildin->keyword)

; More general equality function. Defaults to = but uses seq-eq? if sequence? is true for both x and y.
(def-generic x (eq? x y) (lambda (x y) (if (and (sequence? x) (sequence? y)) (seq-eq? x y) (= x y))))

; Get the size of a collection xs. Default requires ->list.
; Return 0 for types which are not convertable to list.
(def-generic xs (size xs) (lambda (xs) (let* ((l (->list xs))) (if l (list-size l) 0))))

; Get the rest of the elements of a collection.
; Default requires ->list. If ->list is not available, returns Nothing.
(def-generic xs (rest xs) (lambda (xs) (let* ((l (->list xs))) (if l (cdr l) Nothing))))

; Get the first element of a collection.
; Default requires -list. If ->list is not available, returns Nothing.
(def-generic xs (first xs) (lambda (xs) (let* ((l (->list xs))) (if l (car l) Nothing))))

; Get second element of a collection. Default requires first and rest.
(def-generic xs (second xs) (lambda (xs) (first (rest xs))))

; Reverse a collection.
; The default requires foldl and returns a list.
(def-generic xs (reverse xs) (lambda (xs) (foldl (lambda (a b) (cons b a)) '() xs)))

; Compare two variables x and y. Returns 0 if (= x y), -1 if (< x y) or 1 otherwise.
; The default requires = and < to work for x and y.
(def-generic x (compare x y) (lambda (x y) (if (= x y) 0 (if (< x y) -1 1))))

; Increment number by 1 (using +)
(define (inc n) (+ n 1))
; Decrement number by 1 (using -)
(define (dec n) (- n 1))

; Calculate successor of a variable.
; For numbers, this defaults to inc.
; chars have their internal value incremented by 1.
; Other variables are their own successors (eg. a function has no successor).
(def-generic x (succ x) id)
(def-impl ::integer succ inc)
(def-impl ::float succ inc)
(def-impl ::rational succ inc)
(def-impl ::char succ (lambda (c) (int->char (inc (char->int c)))))

; Check whether a variable is a sequence. 
; Needs to be implemented for sequence types or some functions might not work.
(def-generic x (sequence? x)
  (lambda (xs) (list? xs)))
(define seq? sequence?)

; Check whether a variable is a collection.
; By default, a variable is a collection if it is a sequence or if it is 
; convertable to a list.
(def-generic x (collection? x)
  (lambda (xs) (or (or (sequence? xs) (map? xs)) (not (nothing? (->list xs))))))

; Check whether a variable is a number.
(def-generic x (number? x)
  (lambda (xs) (or (int? xs) (or (float? xs) (rational? xs)))))

; Delete element at index i in a collection xs. 
; If xs is a collection, use a linear implementation for lists and return a lazy sequence.
; Otherwise, return Nothing.
(def-generic xs (delete-at i xs)
  (lambda (i xs)
    (if (collection? xs)
      (let*((xs (->list xs)))
        (cond
          (= i 0) (cdr xs)
          (< i 0) xs
          else (lazy-seq (car xs) (delete-at (dec i) (cdr xs)))))
      Nothing)))

; Printing. %print! should not be used directly.
; These functions can take any number of arguments (variadic and requires ->string 
; to work correctly.
; (print! 1 2 3) ;=> prints "123"
; (println! "abc" "abc" "abc") ;=> prints "abcabcabc"
(define (%print! xs)
  (cond xs (let*() (buildin-print! (->string (car xs))) (%print! (cdr xs))) Nothing))
(define (print! & xs)
  (%print! xs))
(define (println! & xs)
  (%print! xs)
  (buildin-print! "\n"))

; Take a function f, which takes two arguments and returns a new function which takes
; the arguments reversed.
; (let*((rsub (flip -)))
;   (- 2 1) ;=> 1
;   (rsub 2 1)) ;=> -1
(define (flip f)
  (lambda (x y) (f y x)))
; Take 2 arguments, return the first
(define (fst x y) x)
; Take 2 arguments, return the second
(define (snd x y) y)

; Take any number of arguments and return a list of them.
; (list 1 2 3) ;=> (1 2 3)
(define (list & xs)
  xs)

; Simpler Let for a single binding.
; (let1 (a 1) a) is equivalent to (let*((a 1)) a)
(defmacro (let1 bindings & body)
  (xcons 'let*(list bindings) body))

; Implementations for nth.
(def-impl ::map nth (lambda (x i) (vector-nth (->vector x) i)))

; Special implementation for get for map.
(def-impl ::map get map-get)

; Implementations for contains?.
(def-impl ::list contains? buildin-contains?)
(def-impl ::map contains? buildin-contains?)

; Implementations for append.
(def-impl ::map append buildin-append)

; Implementations for ->vector
(def-impl ::list ->vector buildin->vector)
(def-impl ::map ->vector buildin->vector)

; Implementations for ->set
(def-impl ::list ->set buildin->set)
(def-impl ::map ->set buildin->set)

; Implementations for ->map
(def-impl ::list ->map buildin->map)
(def-impl ::map ->map id)

; Implementations for ->string.
(def-impl ::list ->string (lambda (xs) (buildin->string (map-eager ->string xs))))
(def-impl ::map ->string (lambda (xs) (buildin->string xs)))

; Implementations for size.
(def-impl ::list size list-size)
(def-impl ::map size map-size)

; Implementations for first.
(def-impl ::list first car)
(def-impl ::map first (lambda (m) (vector-nth (map->vector m) 0)))

; Implementations for rest.
(def-impl ::list rest cdr)
(def-impl ::map rest (lambda (m) (let*((v (map->vector m))) (vector-range v 1 (vector-size v)))))

; Special implementations for reverse for sets and maps.
; Since sets and maps are unordered, they are their own reversals.
(def-impl ::map reverse id)

; Implementations for add.
(def-impl ::map add (lambda (m kv) (map-set (first kv) (second kv))))

; Implementations for add-front.
(def-impl ::list add-front (lambda (l o) (cons o l)))
(def-impl ::map add-front (lambda (m kv) (map-set (first kv) (second kv))))

; Implementations for ->int.
(def-impl ::integer ->int id)
(def-impl ::float ->int buildin->int)
(def-impl ::rational ->int buildin->int)
(def-impl ::char ->int buildin->int)

; Implementations for ->rational.
(def-impl ::integer ->rational buildin->rational)
(def-impl ::float ->rational buildin->rational)
(def-impl ::rational ->rational id)
(def-impl ::char ->rational buildin->rational)

; Implementations for foldr
(def-impl ::list foldr buildin-foldr)
(def-impl ::map foldr buildin-foldr)

; Implementations for foldl
(def-impl ::list foldl buildin-foldl)
(def-impl ::map foldl buildin-foldl)

; Get last element of a collection.
; Default implementation requires ->list, first, rest, size.
(def-generic xs (last xs)
  (lambda (xs)
    (let*((l (->list xs))) (if (list? l) (first (drop (dec (size l)) l)) (nothing)))))

; Get the last element of a collection. Requires ->list, first, rest, size.
(define (but-last xs)
  (let*((l (->list xs)))
    (if (list? l) (take (dec (size l)) l) (nothing))))

; Check whether a variable is empty, according to the following rules:
;   lists are empty if null? is true for them (true for empty list and Nothing).
;   collections are empty if their size is 0.
;   The special value Nothing is empty.
;   Other non-collections are not empty.
(define (empty? xs)
  (cond (list? xs) (null? xs)
        (collection? xs) (= (size xs) 0)
        (nothing? xs) #t
        else #f))

; Check whether value e is in a collection xs. This is the reverse of contains?
(define (included? e xs) (contains? xs e))

(define (seq-eq? l0 l1)
  (cond (empty? l0) (empty? l1)
        (eq? (first l0) (first l1)) (seq-eq? (rest l0) (rest l1))
        else #f))

; Implementations for eq?.
(def-impl ::list eq? seq-eq?)
(def-impl ::map eq? map-eq?)

; Check for non-equality. This is the reverse of eq?.
(define (not-eq? x y) (not (eq? x y)))

; Alias for ->symbol.
(define symbol ->symbol)

; Nicer-to-read alias for #t.
(define else #t)

; Macros for lazy `and` and `or`.
;  (and x y) returns y if x is #t or returns #f if x is not true.
(defmacro (and x y) (list 'if x y #f))
;  (or x y) returns x if x is truthy or y if x is not truthy.
(defmacro (or x y) (let*((s (gensym 'x))) (list 'let*(list (list s x)) (list 'if s s y))))

; Check whether a number is odd or even. Requires ->int.
(define (odd? n) (= 1 (rem (->int n) 2)))
(define (even? n) (= 0 (rem (->int n) 2)))

(define (name x)
  (case x
    symbol? (->string x)
    keyword? (->string (keyword-name x))
    string? x
    Nothing))

; foldl1
; (foldl1 + '()) ;=> Nothing
; (foldl1 + '(1)) ;=> 1 (if only 1 element is given, return it.
; (foldl1 + '(1 2 3)) ;=> 6
; Requires: empty?, size, first, rest, foldl
(define (foldl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (foldl f (first xs) (rest xs))))

; foldl with index.
; Requires: empty?, first, rest
(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

; foldr1
; Similar to foldl1. 
; Requires empty?, size, first, rest
(define (foldr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (f (first xs) (foldr1 f (rest xs)))))

; foldr with index.
; Requires: empty?, first, rest
(define (%foldr-indexed f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (%foldr-indexed f v (inc i) (rest xs)) i)))
(define (foldr-indexed f v xs)
  (%foldr-indexed f v 0 xs))

; scan left. (known as reductions in clojure)
; Return intermediate results of foldl as a list.
; Requires empty?, first, rest
(define (scanl f v xs)
  (let*((%scanl
        (lambda (r a ys)
          (if (empty? ys)
            r
            (let*((b (f a (first ys)))) (%scanl (cons b r) b (rest ys)))))))
    (reverse (%scanl (list v) v xs))))

; scan left with no accumulator.
; Requires empty?, size, first, rest.
(define (scanl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) xs
        else (scanl f (first xs) (rest xs))))

; Function composition
(define (compose f g)
  (lambda (x & xs) (f (apply-to g (cons x xs)))))
(define (compose2 f g)
  (lambda (x y) (f (g x y))))

; Function composition using or.
; ((compose-or sequence? number?) x) ;=> (or (sequence? x) (number? x))
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition using and.
; ((compose-or sequence? empty?) x) ;=> (or (sequence? x) (empty? x))
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (not (p x))))

; Perform operations sequencially.
(defmacro (begin & exprs)
  (xcons 'let* '() exprs))

; define memoized function.
(defmacro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (xcons 'lambda (cdr name-bindings) body))))

; Expand the last element of a sequence and returns a list.
; (spread (list 1 2 3 '(9 7 5))) ;=> (1 2 3 9 7 5)
; Requires: take-drop, size
(define (spread xs)
  ((lambda (ys) (append (car ys) (caadr ys))) (take-drop (dec (size xs)) xs)))

; Apply a function to a variable number of arguments with the last one being expanded using spread.
; (apply list 1 2 3 '(9 7 5)) ;=> (list 1 2 3 9 7 5) ;=> (1 2 3 9 7 5)
(define (apply f & xs)
  (apply-to f (spread xs)))

; Lazy map requires empty?, first, rest
(define (map f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs)) (map f (rest xs)))))

; Takes a sequence of sequences and maps over eacch sub-sequence
; (map-split + '((1 2) (3 4) (5 6)))
(define (map-split f xs)
  (if (empty? xs)
    '()
    (lazy-seq (apply-to f (first xs)) (map-split f (rest xs)))))

(define (map-eager f xs)
  (if (empty? xs)
    '()
    (cons (f (first xs)) (map-eager f (rest xs)))))

; map with index.
; Requires empty?, first, rest.
(define (%map-indexed f xs i)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs) i) (%map-indexed f (rest xs) (inc i)))))
(define (map-indexed f xs) (%map-indexed f xs 0))

; map while/until a predicate if true. Uses map and take-while/take-until.
(define (map-while f p xs) (map f (take-while p xs)))
(define (map-until f p xs) (map f (take-until p xs)))

; map but use the rest of the list.
; (maplist size '(1 2 3)) ;=> (3 2 1)
;   Like (list (size '(1 2 3)) (size '(2 3)) (size '(3)))
; Requires: empty?, rest
(define (maplist f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f xs) (maplist f (rest xs)))))

; Take any number of collections and map their first elements until all are empty.
;   (mapcar list '(1 2 3) '(4 5 6) '(7 8 9)) ;=> ((1 4 7) (2 5 8) (3 6 9))
;   (mapcar + '(1 2 3) '(4 5 6) '(7 8 9)) ;=> (12 15 18)
;   (mapcar + '(1 2 3) '(4 5) '(7 8 9)) ;=> (12 15 12)
; Required: v-zip-with to work correctly with all inputs.
(define (mapcar f & ys)
  (v-zip-with f ys))

; maplist and append.
(define (mapcon f xs)
  (foldr append '() (maplist f xs)))

; map and then append (lazy).
(define (mapcat f xs)
  (if (empty? xs)
    '()
    (let*((x (f (first xs))))
      (lazy-seq (first x) (list-concat (rest x) (mapcat f (rest xs)))))))

; See https://clojuredocs.org/clojure.core/juxt
; (juxt identity name) is effectively equivalent to (lambda (x) (list (identity x) (name x)))
(define (juxt f & fs)
  (lambda (x) (mapv (lambda (g) (g x)) (cons f fs))))

; Lazy filter.
; Required: empty?, first, rest
(define (filter p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (first xs) (filter p (rest xs)))
        else (filter p (rest xs))))

; Filter lazily with index.
; Required: empty?, first, rest
(define (%filter-indexed p xs i)
  (cond (empty? xs) '()
        (p (first xs) i) (lazy-seq (first xs) (%filter-indexed p (rest xs) (inc i)))
        else (%filter-indexed p (rest xs) (inc i))))
(define (filter-indexed p xs) (%filter-indexed p xs 0))

; Filter with complement of p
(define (remove p xs) (filter (complement p) xs))
; Filter with index with complement of p
(define (remove-indexed p xs)
  (filter-indexed (lambda (x i) (not (p x i))) xs))

; Check whether all predicates are true
(define (every-pred p & ps)
  ;(lambda (x) (all? (map (lambda (p0) (p0 x)) (cons p ps))))
  (compose (partial all? id) (apply-to juxt (cons p ps))))

; Filter, then map.
; (fmap f p xs) is equivalent to (filter p (map f xs))
; Required: empty?, first, rest
(define (fmap f p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (f (first xs)) (fmap f p (rest xs)))
        else (fmap f p (rest xs))))
; map, then filter
; (mapf f p xs) is equivalent to (map f (filter p xs))
; Required: empty?, first, rest
(define (mapf f p xs)
  (if (empty? xs)
    '()
    (let*((y (f (first xs))))
      (if (p y)
        (lazy-seq y (mapf f p (rest xs)))
        (mapf f p (rest xs))))))

; Split a sequence into 2 parts: From index 0 to n and the rest.
; (take-drop n xs) is equivalent to (list (take n xs) (drop n xs))
; Required: empty?, ->list (for the rest), first, rest
(define (%take-drop n st en)
  (if (or (= n 0) (empty? en))
    (list (reverse (->list st)) (->list en))
    (%take-drop (dec n) (cons (first en) st) (rest en))))
(define (take-drop n xs)
  (%take-drop n '() xs))
  
; (take-drop-until p xs) is equivalent to (list (take-until p xs) (drop-until p xs))
; Required: empty?, first, rest
(define (%take-drop-until p st en)
  (if (or (empty? en) (p (first en)))
    (list (reverse (->list st)) (->list en))
    (%take-drop-until p (cons (first en) st) (rest en))))
(define (take-drop-until p xs)
  (%take-drop-until p '() xs))

; (take-drop-while p xs) is equivalent to (list (take-while p xs) (drop-while p xs))
; Required: empty?, first, rest
(define (take-drop-while p xs)
  (%take-drop-until (complement p) '() xs))

; Take the first n elements of a collection xs or the whole collection, if its size is greater than n.
; Returns Nothing for atoms. Otherwise, the output is always a list.
; Requires: empty?, first, rest
(define (%take n xs)
  (if (or (= 0 n) (empty? xs))
    '()
    (lazy-seq (first xs) (%take (dec n) (rest xs)))))
(define (take n xs)
  (cond
    (empty? xs) '()
    else (%take n xs))
  )

; Take while a predicate is true.
; Required: empty?, first, rest
(define (take-while p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (first xs) (take-while p (rest xs)))
        else '()))

; Take until a predicate is true.
; Required: empty?, first, rest
(define (take-until p xs)
  (cond (empty? xs) '()
        (p (first xs)) '()
        else (lazy-seq (first xs) (take-until p (rest xs)))))

; Take every nth item
(define (take-nth n xs)
  (cond (empty? xs) '()
        else (lazy-seq (first xs) (take-nth n (drop n xs)))))

; Drop the first n elements of a collection xs.
; Returns Nothing for atoms.
; Requires: empty?, first, rest
(define (drop n xs)
  (cond (<= n 0) xs
        (empty? xs) xs
        else (drop (- n 1) (rest xs))))

; Drop the elements of a collection xs until a predicate is false.
; Returns Nothing for atoms.
; Requires: empty?, first, rest
(define (drop-while p xs)
  (cond (empty? xs) xs
        (p (first xs)) (drop-while p (rest xs))
        else xs))

; Drop the elements of a collection xs until a predicate is true.
; Returns Nothing for atoms.
; Requires: empty?, first, rest
(define (drop-until p xs)
  (cond (empty? xs) xs
        (p (first xs)) xs
        else (drop-until p (rest xs))))

; Returns a sub-sequence of a sequence.
; Equivalent to (take length (drop start xs))
(define (subseq start length xs)
  (take length (drop start xs)))

; Replaces a sub-sequence in a sequence.
;   (replace-subseq 0 4 '() '(1 2 3 4)) ;=> ()
;   (replace-subseq 1 2 '(3 4) '(1 2 3 4)) ;=> (1 3 4 4)
;   (replace-subseq 1 2 '(3 4 5 6) '(1 2 3 4)) ;=> (1 3 4 5 6 6)
; Requires take-drop to work correctly.
(define (replace-subseq start length replacement xs)
  (let*((t (take-drop start xs)))
    (concat (car t) replacement (drop length (cadr t)))))

; Check whether a predicate is true for all elements, no elements
; or at least 1 element in a collection xs.
; Requires empty?, first, rest and drop-while/drop-until to work.
(define (all? p xs)
  (empty? (drop-while p xs)))
(define (none? p xs)
  (empty? (drop-until p xs)))
(define (any? p xs)
  (cond (empty? xs) #f
        (p (first xs)) #t
        else (any? p (rest xs))))

; Count how many elements in xs satisfy predicate p.
; Required: foldl
(define (count-by p xs)
  (foldl (lambda (res x) (if (p x) (+ res 1) res)) 0 xs))

; Check whether more than half of the elements of a collection satisfy a predicate p.
; Required: size, count-by
(define (most? p xs)
  (> (count-by p xs) (/ (size xs) 2)))

; zip the elements of two collections with a function.
;   (zip-with + '(1 2 3) '(4 5 6)) ;=> (5 7 9)
;   (zip-with list '(1 2 3) '(4 5 6)) ;=> ((1 4) (2 5) (3 6))
; Required for both l0 and l1: empty?, first, rest
(define (zip-with f l0 l1)
  (if (or (empty? l0) (empty? l1))
    '()
    (lazy-seq (f (first l0) (first l1)) (zip-with f (rest l0) (rest l1)))))

; zip the elements of two collections using list.
;   (zip '(1 2 3) '(4 5 6)) ;=> ((1 4) (2 5) (3 6))
; Required for both l0 and l1: empty?, first, rest
(define (zip l0 l1)
  (zip-with list l0 l1))
  
; zip the elements of a collection to their indices.
;   (zip-to-index '(9 8 7)) ;=> ((0 9) (1 8) (2 7))
; Requires map-indexedd to work.
(define (zip-to-index xs)
  (map-indexed (lambda (x i) (list i x)) xs))

; Similar to zip, but takes a sequence of sequences to zip.
; The output is always a list.
; Stops when all sequences are empty.
;  (v-zip-with v+ '((1 2 3) (4 5 6) (7 8 9))) ;=> (12 15 18)
;  (v-zip-with v+ '((1 2 3) (4) (7 8 9))) ;=> (12 10 12)
;  (v-zip-with v+ '((1 2 3) (4 5 6 10) (7 8 9))) ;=> (12 15 18 10)
; Required for xs: map-eager, all?
; Required for inner sequences: first, empty?, rest
(define (v-zip-with f xs)
  (if (all? empty? xs)
    '()
    (cons (apply-to f (map-eager first xs)) (v-zip-with f (remove empty? (map-eager rest xs))))))

; Split a sequence each time as predicate is true for the current element.
; Always returns a list.
;   (split-by (lambda (x) (= x 1)) '(5 1 2 3 1 6)) ;=> ((5) (2 3) (6))
; Required: foldr
(define (split-by f xs)
  (foldr
    (lambda (x v) (if (f x) (cons '() v) (cons (cons x (car v)) (cdr v))))
    (list '())
    xs))

; Split at each occurance of v in xs.
; Requires split-by to work for xs.
; Requires eq? to be defined for v.
(define (split v xs)
  (split-by (lambda (x) (eq? v x)) xs))

; Repeatedly execute f in a lazy sequence.
(define (repeatedly f)
  (lazy-seq (f) (repeatedly f)))

; Create an infinite sequence of the same element e.
(define (repeat e)
  (lazy-seq e (repeat e)))

; Typical iterate function creating an infinite sequence.
;   (take 5 (iterate inc 0) => (0 1 2 3 4)
;   (take 3 (iterate list '()) => (() (()) ((())))
(define (iterate f e)
  (lazy-seq e (iterate f (f e))))

; Create an infinite sequence repeating the elements of xs.
;   (take 5 (cycle '(1 2)))) ;=> (1 2 1 2 1)
; Required: empty?, first, rest
(define (cycle xs)
  (if (empty? xs)
    '()
    (lazy-seq (first xs) (list-concat (rest xs) (cycle xs)))))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

; Append any number of sequences to each other.
; Required: append, foldr1
(define (concat x & xs)
  (if (list? (car xs))
    (apply-to list-concat (cons x xs))
    (foldr1 append (cons x xs))))

; Variadic versions of =, /=, <, >, <=, >=
(define (v= x & xs) (cond (empty? xs) #t (= x (car xs)) (apply-to v= (cdr xs)) #f))
(define (v/= x & xs) (unique? (cons x xs)))
(define (v< x & xs) (cond (empty? xs) #t (< x (car xs)) (apply-to v< (cdr xs)) #f))
(define (v> x & xs) (cond (empty? xs) #t (> x (car xs)) (apply-to v> (cdr xs)) #f))
(define (v<= x & xs) (cond (empty? xs) #t (<= x (car xs)) (apply-to v<= (cdr xs)) #f))
(define (v>= x & xs) (cond (empty? xs) #t (>= x (car xs)) (apply-to v>= (cdr xs)) #f))

; Variadic versions of +, -, *, /, rem
(define (v+ x & xs) (foldl + x xs))
(define (v- x & xs) (if (empty? xs) (- 0 x) (foldl - x xs)))
(define (v* x & xs) (foldl * x xs))
(define (v/ x & xs) (foldl / x xs))
(define (v% x & xs) (foldl rem x xs))

; (divmod x y) ;=> (list (/ x y) (rem x y))
(define (divmod x y) (list (/ x y) (rem x y)))

; Returns a function which always returns x.
(define (constantly x) (lambda (& ys) x))
(define const constantly)

; Always true
(define T (constantly #t))
(define F (constantly #f))


;; case macro

(define (%case e n cases)
  (let* ((fc (first cases)))
    (cond
      (empty? cases) Nothing
      (= 1 (size cases)) (first cases)
      (and (not (symbol? (first cases))) (atom? (first cases)))
        (list 'if (list 'eq? fc e) (second cases) (%case e n (rest (rest cases))))
      (and (not (list? (first cases))) (collection? (first cases)))
        (list 'if (list 'contains? fc e) (second cases) (%case e n (rest (rest cases))))
      else
        (list 'let* (list (list n (first cases)))
          (list 'cond
            (list 'and (list 'collection? n) (list 'contains? n e)) (second cases)
            (list 'and (list 'function? n) (list n e)) (second cases)
            (list 'eq? n e) (second cases)
            'else (%case e n (rest (rest cases))))))))

(defmacro (case e & cases)
  (let* ((n (gensym 'case))
        (e-name (gensym 'case-elem)))
    (list 'let* (list (list e-name e)) (%case e-name n cases))))




;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

; repeatedly apply cons to a list.
; (xcons 1 2 3 4 '(5 6)) ;=> (1 2 3 4 5 6)
; (xcons 1 2 '(3)) is equivalent to (cons 1 (cons 2 '(3)))
(define (xcons & args) (foldr1 cons args))

; Flatten a collection.
; Required: collection?, foldr, append
; Could use some optimization
(define (flatten xs)
  (if (collection? xs)
    (foldr append '() (map flatten xs))
    (list xs)))

; Flatten by one level.
; Required: map
; Could use some optimization
(define (flatten1 xs)
  (apply-to list-concat (map (lambda (x) (if (collection? x) (->list x) (list x))) xs)))

; Lazily create a range of the numbers between from and to (inclusive)
(define (range from to)
  (if (> from to)
    '()
    (lazy-seq from (range (inc from) to))))

; Get the indices of all occuranges of elem in seq.
; Required for seq: foldr-indexed
; Required for elements in seq: eq?
(define (indices-of seq elem)
  (foldr-indexed
    (lambda (c acc i) (if (eq? c elem) (cons i acc) acc))
    '() seq))

; Plain alias for lambda
(defmacro (λ bindings & body)
  (cons 'lambda (cons bindings body)))

; Evaluate a list
(define (doall! xs)
  (let* ((ys (->list xs)))
    (if (empty? ys)
      ys
      (doall! (cdr ys))))
  xs)

; Sequence of the factorial numbers, starting at 0.
; (yes, it says 1, but starts at 0)
(define (fact-seq)
  (map cadr
    (iterate
      (lambda (p)
        (list (inc (car p)) (* (car p) (cadr p))))
      '(1 1))))

; As in Clojure.
(defmacro (-> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (xcons (car expr) acc (cdr expr)) (list expr acc))) x exprs))

; As in Clojure.
(defmacro (->> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (append expr (list acc)) (list expr acc))) x exprs))

; As in Clojure.
(define (%as-> name x exprs)
  (if (empty? exprs)
    x
    (list 'let* (list (list name x)) (%as-> name (car exprs) (cdr exprs)))))
(defmacro (as-> name x & exprs)
  (%as-> name x exprs))


(defmacro (quasiquote expr)
  (cond
    (not expr)
      '()
    (not (list? expr))
      (list 'quote expr)
    else
      (let* ((fst (car expr)))
        (cond
          (= fst 'unquote)
            (cadr expr)
          (and (list? fst) (= (car fst) 'unquote-splicing)) 
            (list 'concat (second fst) (list 'quasiquote (cdr expr)))
          else
            (list 'cons (list 'quasiquote (car expr)) (list 'quasiquote (cdr expr)))))))

;; Basic case-lambda

(define (%cl-arg-nums args)
  (if (and (> (size args) 2) (= (nth args (- (size args) 2)) '&))
    (list (- (size args) 2) -1)
    (list (size args) (size args))))

(comment define (%cl-form form arg-name)
  (let* ((form-args (car form))
         (arg-nums (%cl-arg-nums form-args)))
    (if (list? (car form))
      (cond
        (= (cadr arg-nums) 0)
          `((= (size ~arg-name) 0) (begin ~@(cdr form)))
        (= (cadr arg-nums) -1)
          `((>= (size ~arg-name) ~(car arg-nums)) (let ((~form-args ~arg-name))  ~@(cdr form)))
        else
          `((= (size ~arg-name) ~(car arg-nums)) (let ((~form-args ~arg-name)) ~@(cdr form))))
      `(else (let ((~form-args ~arg-name)) ~@(cdr form))))))

(define (%cl-form form arg-name)
  (let* ((form-args (car form))
         (arg-nums (%cl-arg-nums form-args)))
    (if (list? (car form))
      (cond
        (= (cadr arg-nums) 0)
          `((= (size ~arg-name) 0) (begin ~@(cdr form)))
        (= (cadr arg-nums) -1)
          `((>= (size ~arg-name) ~(car arg-nums)) (let ((~form-args ~arg-name))  ~@(cdr form)))
        else
          `((= (size ~arg-name) ~(car arg-nums)) (let ((~form-args ~arg-name)) ~@(cdr form))))
      `(else (let ((~form-args ~arg-name)) ~@(cdr form))))))

(define (%case-lambda cl-name forms)
  (let* ((args (gensym 'cl-args)))
    (list
      'lambda* cl-name
      (list '& args)
      (cons
        'cond
        (concat
          (mapcat (lambda (form) (%cl-form form args)) forms)
          `(else (error! (string-concat "invalid number of arguments for function " ~cl-name ". Got " (size ~args)) 'syntax)))))))

(defmacro (case-lambda form1 & forms)
  (%case-lambda (gensym 'case-lambda) (cons form1 forms)))

; Create a multi-function:
; (define f (case-lambda* f
;   (() "0") ; 0 args
;   ((x) "1") ; 1 arg
;   ((x y) "2") ; 2 args
;   ((w x y z & zs) "4 or more") ; 4+ args
;   (default "0 or more"))) ; Varargs going into a list called 'default
; When called, the function decides which function to call by the number of arguments it got.
; (list (f) (f 6) (f 6 7) (f 6 7 8 9) (f 5 4 3)) ; ("0" "1" "2" "4 or more" "0 or more")
(defmacro (case-lambda* cl-name form1 & forms)
  (%case-lambda cl-name (cons form1 forms)))


(define (%interleave xss)
  (if (all? empty? xss)
    '()
    (let*((ys (map first xss)))
      (lazy-seq (car ys) (concat (cdr ys) (%interleave (map rest xss)))))))
(define (interleave xs & xss)
  (%interleave (cons xs xss)))

; Sum up elements of a collection using +.
; Required: foldl, map
(define sum
  (case-lambda* sum
    ((coll) (foldl + 0 coll))
    ((f coll) (foldl + 0 (map f coll)))))

; Calculate the product of the elements of a collection using *.
; Required: foldl, map
(define product
  (case-lambda* product
    ((coll) (foldl * 1 coll))
    ((f coll) (foldl * 1 (map f coll)))))

; Get minimum/maximum of n m (using < or >)
(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))

; Get minimum/maximum of the elements in a sequence using min/max.
; Required: foldl1, map
(define minimum
  (case-lambda* minimum
    ((coll) (foldl1 min coll))
    ((f coll) (min (map f coll)))))
(define maximum
  (case-lambda* maximum
    ((coll) (foldl1 max coll))
    ((f coll) (max (map f coll)))))

; Extended range function.
; Takes 0 to 3 input numbers.
; Arity | Output
; 0     | Infinite sequence starting at 0 and counting up.
; 1     | Infinite sequence starting at from.
; 2     | Lazy sequence counting from 'from' to 'to'.
; 3     | Lazy sequence counting from 'from' to 'to'
;       | If stop is a function, it is repeatedly applied to the current value of from until (>= from to).
;       | Otherwise, step is repeatedly added to from using +.
(define xrange
  (case-lambda* xrange
    (() (iterate inc 0))
    ((from) (iterate inc from))
    ((from to) (xrange from to inc))
    ((from to step)
      (cond
        (>= from to) '()
        (function? step) (lazy-seq from (xrange (step from) to step))
        else (lazy-seq from (xrange (+ from step) to step))))))

;; condp

; (let* ((f0 (lambda (e) (condp <= e  1 0  5 9  11))))
;   (f0 0) ; 0
;   (f0 1) ; 0
;   (f0 3) ; 9
;   (f0 6)) ; 11 ; default
(define (%condp p e cases)
  (let* ((c (first cases)))
    (cond 
      (empty? cases) Nothing
      (= 1 (size cases)) c
      else (list 'if
            (list p c e) (second cases)
            (%condp p e (rest (rest cases)))))))
(defmacro (condp p e & cases)
  (let* ((n (gensym 'condp)))
    (list 'let* (list (list n e)) (%condp p n cases))))


; Intermediate results of foldr as a lazy sequence
;   (scanr + 5 '(1 2 3 4)) ;=> (15 14 12 9 5)
; Required: empty?, first, rest
(define (scanr f v xs)
  (if (empty? xs)
    (list v)
    (let* ((r (scanr f v (rest xs))))
      (lazy-seq (f (first xs) (first r)) r))))

; Intermediate results of foldr1 as a lazy sequence
;   (scanr1 + '(1 2 3 4 5)) ;=> (15 14 12 9 5)
; Required: empty?, first, rest, size
(define (scanr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (list (first xs))
        else (let* ((r (scanr1 f (rest xs))))
              (lazy-seq (f (first xs) (first r)) r))))

; Map of the number of occurances of each item in a collection.
; Required: foldl
(define (frequencies xs)
  (foldl
    (lambda (acc x)
      (let* ((v (or (map-get acc x) 0)))
        (map-set acc x (inc v))))
    {} xs))

; Get a sequence with its duplicates removed.
; Required: empty?, first, rest
(define (%unique xs acc vals)
  (cond (empty? xs) acc
        (contains? vals (first xs)) (%unique (rest xs) acc vals)
        else (%unique (rest xs) (lazy-seq (first xs) acc) (set-add vals (first xs)))))
(define (unique xs)
  (reverse (%unique xs '() (set-of))))

; Check whether (eq? xs (unique xs))
; Required: eq? 
(define (unique? xs)
  (eq? xs (unique xs)))

; (tuples 3 '(1 2 3 4 5)) ;=> ((1 2 3) (2 3 4) (3 4 5))
; Required: size, take, rest
(define (tuples n xs)
  (cond 
    (= n 0) '()
    (< (size xs) n) '()
    else (lazy-seq (take n xs) (tuples n (rest xs)))))

; (slices 3 '(1 2 3 4 5 6)) ;=> ((1 2 3) (4 5 6))
; Required: size, take, drop
(define (slices n xs)
  (cond
    (= n 0) '()
    (< (size xs) n) '()
    else (lazy-seq (take n xs) (slices n (drop n xs)))))

(define (partition-all n xs)
  (cond
    (= n 0) '()
    (empty? xs) '()
    else (lazy-seq (take n xs) (partition-all n (drop n xs)))))

(defmacro (try f0 & fs)
  (let*((forms (take-drop-until
                (lambda (f) (and (list? f) (eq? (car f) 'catch)))
                (cons f0 fs)))
        (body (car forms))
        (_ (if (all?
                (lambda (f)
                  (and
                    (list? f)
                    (or (eq? (car f) 'catch)
                      (eq? (car f) 'finally))))
                (cadr forms))
              #t
              (error! "Syntax error: Invalid format for try-catch-finally" 'syntax)))
        (catch-finally (take-drop-until
                        (lambda (f) (eq? (car f) 'finally))
                        (cadr forms)))
        (catch-clauses (car catch-finally))
        (finally-clause (cadr catch-finally))
        (res-name (gensym 'try))
        (err-name (gensym 'error)))
    (list 'try*
      (list 'let* (list (list res-name 
        (foldl (lambda (bd ct) (list 'try* bd ct)) (cons 'begin body) catch-clauses)))
        (if (empty? finally-clause) Nothing (cons 'begin (cdar finally-clause)))
        res-name)
      (list 'catch (constantly #t) err-name
        (if (empty? finally-clause) Nothing (cons 'begin (cdar finally-clause)))
        (list 'error! (list 'error-msg err-name) (list 'error-info err-name) (list 'error-trace err-name))))
    ))

(defmacro (loop bindings & body)
  (let*((binds (if (vector? bindings) (slices 2 bindings) bindings))
        (name (gensym 'loop))
        (args (map first binds))
        (vals (map second binds)))
    (if (any? (comp (partial /= 2) size) binds)
      (error! "Invalid number of members in loop binding." 'syntax)
      (cons `(lambda' ~name ~args ~@body) vals))))

; Simplified loop without destructuring
(defmacro (loop1 bindings & body)
  (let*((binds (if (vector? bindings) (slices 2 bindings) bindings)))
    (if (any? (comp (partial /= 2) size) binds)
      (error! "Invalid number of members in loop binding." 'syntax)
      (cons
        `(lambda* ~(gensym 'loop) ~(map first binds) ~@body)
        (map second binds)))))

; Add items from 'from' to 'to', keeping the type of 'to'. (if add is correctly defined)
;   (into) ;=> () ; empty input -> empty list
;   (into '(1 2)) ;=> (1 2)
;   (into [1 2#!]!# '(3 4)) ;=> [1 2 3 4]
;   (into [1 2] unique '(3 3 4 3)) ;=> [1 2 3 4]
; The last case works well for partials:
;   (let* ((f (partial into [1 2] unique))) ...)
; Required: foldl, add
(define into
  (case-lambda* into
    (() '())
    ((to) to)
    ((to from) (foldl add to from))
    ((to f from) (foldl add to (f from)))))

; Partition function
; Required: size, take, drop
(define (%partition n step pad xs)
  (cond
    (= n 0) '()
    (< (size xs) n)
      (if (empty? pad)
        '()
        (list (list-concat xs (take (- n (size xs)) pad))))
    else (lazy-seq (take n xs) (%partition n step pad (drop step xs)))))
(define partition
  (case-lambda* partition
    ((n xs) (%partition n n '() xs))
    ((n step xs) (%partition n step '() xs))
    ((n step pad xs) (%partition n step pad xs))))

; Remove consecutive duplicates from a sequence.
; If either set? or map? is true for xs, do nothing and return xs.
; Required: empty?, first, rest
(define (%dedupe prev xs)
  (cond (empty? xs) '()
        (eq? (first xs) prev) (%dedupe prev (rest xs))
        else (lazy-seq (first xs) (%dedupe (first xs) (rest xs)))))
(define (dedupe xs)
  (cond (or (set? xs) (map? xs)) xs
        (empty? xs) '()
        else (lazy-seq (first xs) (%dedupe (first xs) (rest xs)))))

; Creates a function which takes one argument and applies f to it n times.
; (let* ((f (times inc 6)))
;   (f 9) ;=> 15
;   ((times inc 0) 9) ;=> 9
; )
(define (times f n)
  (lambda (x) (loop ((n1 n) (y x)) (if (<= n1 0) y (recur (dec n1) (f y))))))


; Helper for permutations
(define (%insert l n e)
  (if (= 0 n)
    (cons e l)
    (cons (car l) 
          (%insert (cdr l) (- n 1) e))))

; Calculate all permutations of a collection.
; Requires only ->list to be defined.
(define (permutations l0)
  (let* ((l (->list l0)))
    (if (null? l)
      '(())
      (apply-to concat
        (map (lambda (p)
              (map (lambda (n)
                      (%insert p n (car l)))
                    (range 0 (size p))))
            (permutations (cdr l)))))))

; Get an item from xs after calling get on it for each item in ks.
;   (get-in [1 [2 [3]]] '(0)) ;=> 1
;   (get-in [1 [2 [3]]] '(1 0)) ;=> 2
;   (get-in [1 [2 [3]]] '(1 1)) ;=> [3]
;   (get-in [1 [2 [3]]] '(1 1 0)) ;=> 3
; Required for xs: get
; Required for ks: empty?, first, rest
(define (get-in xs ks)
  (cond (empty? ks) xs
        (get-in (get xs (first ks)) (rest ks))))


; Not even in testing yet!
(define (%walk-with-path f coll _path)
  (cond
    (vector? coll)
    (->vector
      (map-indexed
        (lambda (v i)
          (let* ((path (cons i _path)))
            (%walk-with-path f (f v path) path)))
        coll))

    (sequence? coll)
    (map-indexed
      (lambda (v i)
        (let*((path (cons i _path)))
          (%walk-with-path f (f v path) path)))
      coll)

    (set? coll)
    (->set
    (map-indexed
      (lambda (v i)
        (let*((path (cons i _path)))
          (%walk-with-path f (f v path) path)))
      coll))

    (map? coll)
    (->map (flatten1
    (map-indexed
      (lambda (v i)
        (let*((path (cons i _path)))
          (%walk-with-path f (f v path) path)))
      coll)))

    ; coll is not a collection
    else (f coll _path)
    ))
(define (walk-with-path f xs)
  (%walk-with-path f xs '()))


;;; for macro

; Lazily calculates all combinations of any number of lists while preserving order:
; (combinations '(1 2) '(3 4) '(5 6)) 
; => ((1 3 5) (1 3 6) (1 4 5) (1 4 6) (2 3 5) (2 3 6) (2 4 5) (2 4 6))
(define (%combinations x xs)
  (cond
    (empty? xs) (list x)
    (empty? (rest xs)) (map (lambda (y) (cons y x)) (first xs))
    else (mapcat (lambda (a) (%combinations (cons a x) (rest xs))) (first xs))))

(define (combinations & xs1)
  (let*((xs (remove empty? xs1)))
    (if (empty? xs)
      '()
      (map reverse (mapcat (lambda (x) (%combinations (list x) (rest xs))) (first xs))))))

(define (%for-lazy-take xs)
  (if (empty? xs)
    '()
    (let*((x (car xs)))
      (cond
        (car x) '() ; Ended with while
        (cadr x) (%for-lazy-take (cdr xs)) ; Ignores with when
        else (lazy-seq (caddr x) (%for-lazy-take (cdr xs)))))))
(define (%for-binds bindings)
  (if (vector? bindings)
    (if (odd? (size bindings))
      (error! "Syntax error: for must have an even number of bindings." 'syntax)
      (%for-binds (slices 2 bindings)))
    (let*((lets (map cadr (filter (lambda (b) (= (car b) :let)) bindings)))
          (whiles (map cadr (filter (lambda (b) (= (car b) :while)) bindings)))
          (whens (map cadr (filter (lambda (b) (= (car b) :when)) bindings)))
          (defs (remove (lambda (b) (set-includes? #{:let :while :when} (car b))) bindings)))
      (list defs lets whiles whens))))
(define (%for bindings body)
  (let* ((binds (%for-binds bindings))
          (defs (car binds))
          
          (lets (cadr binds))
          (whiles (caddr binds))
          (whens (cadddr binds)))
   (list %for-lazy-take
    (list 'map-split
      (list 'lambda' (gensym 'for) (map car defs)
        (list 'let (mapcat ->list lets)
          (cons 'cond
            (concat
              (if (empty? whiles)
                '()
                (list
                  (list any? not (cons 'list whiles))
                  (list list #t Nothing Nothing)))
              (if (empty? whens)
                '()
                (list
                  (list any? not (cons 'list whens))
                  (list list #f #t Nothing)))
              (list else (cons 'list (list #f #f body)))))))
      (cons 'combinations (map cadr defs))
      ))))
(defmacro (for bindings body)
  (%for bindings body))

(define (cartesian-product lst0 lst1)
  (mapcat (lambda (x) (zip (repeat x) lst1)) lst0))

(define (partition-by f coll)
  (if (empty? coll)
    '()
    (let* ((lst1 (->list coll))
           (expect (f (car coll)))
           (%partition-by (lambda (res lst)
            (cond
              (empty? lst) (reverse res)
              (eq? (f (car lst)) expect)
                (%partition-by (cons (car lst) res) (cdr lst))
              else (reverse res))))
           (pb-head (%partition-by '() lst1)))
      (lazy-seq pb-head (partition-by f (drop (size pb-head) lst1))))))


; Similar to '->> but stops when the value becomes
; Nothing or an exception is thrown.
; if the value becomes nothing, default is returned.
; if an error is thrown, error-default is returned
; (compute*-> 'default 'error 1 inc inc inc)  ; => 4
; (compute*-> 'default 'error 1 (+ 3) inc))   ; => 5
; (compute*-> 'default 'error 1 ->list first) ; => default
; (compute*-> 'default 'error 0 throw! inc)   ; => error
; (compute*-> 'default 'error "r")            ; => "r"
(defmacro (compute*-> default error-default m & funcs)
  (let* ((n (gensym 'compute)))
    (cond
      (not funcs) m
      m (list 'try*
          (list 'let* (list (list n m))
            (list 'if n
              (xcons 'compute*-> default error-default
                (if (list? (car funcs))
                  (list-concat (car funcs) (list n))
                  (list (car funcs) n))
                (cdr funcs))
              default))
          (list 'catch 'id 'e error-default))
      else default)))

; Like compute*-> but the special cases all return Nothing.
; (compute-> 1 inc inc inc)  ; => 4
; (compute-> 1 (+ 3) inc))   ; => 5
; (compute-> 1 ->list first) ; => Nothing
; (compute-> 0 throw! inc)   ; => Nothing
; (compute-> "r")            ; => "r"
(defmacro (compute-> m & funcs)
  `(compute*-> Nothing Nothing ~m ~@funcs))


(define (%can-destructure? left)
  (cond (not (vector? left)) #t
        (not (map? left))    #t
        (not (list? left))   #t
        else                 #f))
(define (%let-destructure-list seq1 seq2 namestack)
  (let ((sym (gensym 'des)))
  (cond
    (not seq1) '()
    (= (car seq1) '&) (list (list (cadr seq1) seq2))
    (%can-destructure? (car seq1))
      (cons
        (list sym seq2)
        (concat
          (%let-destructure (car seq1) (list 'first sym)) ; Recursive inner destructure
          (%let-destructure-list (cdr seq1) (list 'rest sym) (cons sym namestack))))
    else
      (cons
        (list sym seq2)
        (cons (list (first seq1) (list 'first sym))
          (%let-destructure-list (cdr seq1) (list 'rest sym) (cons sym namestack)))))))

(define (%let-destructure-map m1 m2)
  (if (empty? m1)
    res
    (mapcat (lambda (e) (%let-destructure (second e) (list 'map-get m2 (first e)))) (->list m1))))

(define (%let-destructure left right)
  (cond
    (symbol? left)
      (list (list left right))
    (and (sequence? left) (not (empty? left)))
      (%let-destructure-list (->list left) right '())
    (and (map? left) (not (empty? left)))
      (%let-destructure-map left right)
    else
      (error! "parameter must be symbol, list, vector or map" 'syntax)))

(define (destructure binds)
  (mapcat
    (lambda (e) (%let-destructure (first e) (second e)))
    binds))

(defmacro (let binds & body) ; let* with destructuring. Does not support :as yet.
  (if (vector? binds)
    (if (odd? (size binds))
      (error! "odd number of bindings for let" 'syntax)
      `(let ~(slices 2 binds) ~@body)) ; recursive call
    (cons 'let* (cons (destructure binds) body))))

; Extended define
; Supports destructuring
; Will support keyword arguments in the future
(defmacro (define* binds & body)
  (let ((bind-aliases (map #(gensym 'bind) (cdr binds))))
    (list 'define (cons (car binds) bind-aliases) (cons 'let (cons (zip (cdr binds) bind-aliases) body)))))


(defmacro (lambda' binds body1 & body)
  (let ((named (symbol? binds))
        (name (if named binds (gensym 'lambda)))
        (binds (if named body1 binds))
        (body (if named body (cons body1 body)))
        (bind-aliases (map #(if (= %1 '&) '& (gensym 'bind)) binds)))
    (list 'lambda* name bind-aliases (cons 'let (cons (remove #(= (car %1) '&) (zip binds bind-aliases)) body)))))


; Parallel let
(defmacro (plet binds & body)
  (let* ((names (map first binds))
         (vals (map second binds))
         (name-syms (map #(gensym 'name) names)))
    (cons 'let
      (cons
        (list-concat
          (zip name-syms vals)
          (zip names name-syms))
        body))))
)

(cons 'core (load! "string.lyra" "vector.lyra" "set.lyra"))

