(module core
  (comment unwrap foldr foldl append contains? nth ->symbol ->int ->float ->rational ->string ->bool ->list ->vector ->char ->map ->set eq? size rest first second reverse compare collection? sequence? number? print! println! flip fst snd list let1 list-nth last but-last empty? included? seq-eq? not-eq? symbol else not and or odd? even? foldl1 foldl-indexed foldr1 foldr-indexed compose compose-or compose-and complement begin def-memo spread apply map map-eager map-indexed mapv mapv-indexed map-while map-until maplist mapcar mapcon mapcat filter filterv filter-indexed remove remove-indexed fmap mapf take-drop take-drop-until take-drop-while take take-while take-until drop drop-while drop-until subseq replace-subseq all? none? any? zip-with zip zip-to-index v-zip-with split-by split repeatedly repeat iterate va-all? va-none? va-any? concat string-concat v+ v- v* v/ v% caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr flatten flatten1 sum product inc dec min max minimum maximum range indices-of Î» doall! fact-seq -> ->> as-> divmod constantly case cycle case-lambda scanl scanl1 scanr scanr1 condp case-lambda* frequencies unique unique? add compose2 slices tuples xrange succ try count-by most? defmacro loop va-cons)

;;; Some core things

(def-macro (comment & xs) (nothing))

(def-generic x (unwrap x) buildin-unwrap)

(def-generic xs (foldr f v xs) buildin-foldr)
(def-generic xs (foldl f v xs) buildin-foldl)

(def-generic xs (append xs ys) buildin-append)
(def-generic xs (add xs ys) nothing)
(def-generic xs (contains? xs e) buildin-contains?)
(def-generic xs (nth xs i) buildin-nth)

(def-generic x (->symbol x) buildin->symbol)
(def-generic x (->int x) buildin->int)
(def-generic x (->float x) buildin->float)
(def-generic x (->rational x) buildin->rational)
(def-generic x (->string x) buildin->string)
(def-generic x (->bool x) buildin->bool)
(def-generic x (->list x) buildin->list)
(def-generic x (->vector x) buildin->vector)
(def-generic x (->char x) buildin->char)
(def-generic x (->map x) buildin->map)
(def-generic x (->set x) buildin->set)

(def-generic x (eq? x y) =)

(def-generic xs (size xs) nothing)
(def-generic xs (rest xs) nothing)
(def-generic xs (first xs) nothing)
(def-generic xs (second xs) (lambda (xs) (first (rest xs))))
(def-generic xs (reverse xs) (lambda (xs) (foldl (lambda (a b) (cons b a)) '() xs)))

(def-generic x (compare x y) (lambda (x y) (if (= x y) 0 (if (< x y) -1 1))))


(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(def-generic x (succ x) id)
(def-impl ::integer succ inc)
(def-impl ::float succ inc)
(def-impl ::rational succ inc)
(def-impl ::char succ (lambda (c) (int->char (inc (char->int c)))))
(def-impl ::string succ
  (lambda (s)
    (let ((len (- (string-size s) 1)))
      (if (< len 0)
        s
        (string-add
          (string-range s 0 len)
          (succ (->char (string-nth s len))))))))

(def-generic x (collection? x)
  (lambda (xs) (or (list? xs) (or (vector? xs) (or (map? xs) (set? xs))))))
(def-generic x (sequence? x)
  (lambda (xs) (or (list? xs) (vector? xs))))
(def-generic x (number? x)
  (lambda (xs) (or (int? xs) (or (float? xs) (rational? xs)))))


(define (%print! xs)
  (if xs (let () (buildin-print! (->string (car xs))) (%print! (cdr xs))) Nothing))
(define (print! & xs)
  (%print! xs))
(define (println! & xs)
  (%print! xs)
  (buildin-print! "\n"))


(define (flip f)
  (lambda (x y) (f y x)))
; Take 2 arguments, return the first
(define (fst x y) x)
; Take 2 arguments, return the second
(define (snd x y) y)

(define (list & xs)
  xs)


(def-macro (let1 bindings & body)
  (va-cons 'let (list bindings) body))


(def-impl ::list ->string (lambda (xs) (buildin->string (map-eager ->string xs))))
(def-impl ::vector ->string (lambda (xs) (buildin->string (mapv ->string xs))))

(def-impl ::list size list-size)
(def-impl ::vector size vector-size)
(def-impl ::string size string-size)
(def-impl ::set size set-size)
(def-impl ::map size map-size)

(def-impl ::list first car)
(def-impl ::vector first (lambda (v) (vector-nth v 0)))
(def-impl ::string first (lambda (v) (string-nth v 0)))
(def-impl ::set first (lambda (s) (vector-nth (set->vector s) 0)))
(def-impl ::map first (lambda (m) (vector-nth (map->vector m) 0)))

(def-impl ::list rest cdr)
(def-impl ::vector rest (lambda (v) (vector-range v 1 (vector-size v))))
(def-impl ::string rest (lambda (v) (string-range v 1 (string-size v))))
(def-impl ::set rest (lambda (s) (let ((v (set->vector s))) (vector-range v 1 (vector-size v)))))
(def-impl ::map rest (lambda (m) (let ((v (mao->vector m))) (vector-range v 1 (vector-size v)))))

(def-impl ::set reverse id)
(def-impl ::map reverse id)

(def-impl ::list add (lambda (l v) (append l '(x))))
(def-impl ::string add (lambda (s o) (string-add s (->string o))))
(def-impl ::vector add vector-add)
(def-impl ::set add set-add)
(def-impl ::map add (lambda (m kv) (map-set (first kv) (second kv))))

(define (list-nth l i)
  (if (<= i 0)
    (first l)
    (list-nth (rest l) (dec i))))
(def-impl ::list nth list-nth)

(define (last xs)
  (let ((l (->list xs)))
    (if (list? l) (first (drop (dec (size l)) l)) (nothing))))
(define (but-last xs)
  (let ((l (->list xs)))
    (if (list? l) (take (dec (size l)) l) (nothing))))

(define (empty? xs) (if (list? xs) (null? xs) (or (nothing? xs) (= (size xs) 0))))

(define (included? e s) (contains? s e))

(define (seq-eq? l0 l1)
  (if (empty? l0)
    (empty? l1)
    (and (and (not (empty? l1)) (eq? (first l0) (first l1)))
         (seq-eq? (rest l0) (rest l1)))))

(def-impl ::list eq? seq-eq?)
(def-impl ::vector eq? (lambda (v0 v1) (seq-eq? (->vector v0) (->vector v1))))
(def-impl ::set eq? set-eq?)
(def-impl ::map eq? map-eq?)
(def-impl ::string eq? string-eq?)

(define (not-eq? x y) (not (eq? x y)))

(define symbol ->symbol)

(define else #t)

(define (not x) (if x #f #t))
(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (let ((s (gensym 'x))) (list 'let (list (list s x)) (list 'if s s y))))

(define (odd? n) (= 1 (rem (->int n) 2)))
(define (even? n) (= 0 (rem (->int n) 2)))

(define (foldl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (foldl f (first xs) (rest xs))))

(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

(define (foldr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (f (first xs) (foldr1 f (rest xs)))))

(define (%foldr-indexed f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (%foldr-indexed f v (inc i) (rest xs)) i)))
(define (foldr-indexed f v xs)
  (%foldr-indexed f v 0 xs))

(define (scanl f v xs)
  (let ((%scanl
        (lambda (r a ys)
          (if (empty? ys)
            r
            (let ((b (f a (first ys)))) (%scanl (cons b r) b (rest ys)))))))
    (reverse (%scanl (list v) v xs))))

(define (scanl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) xs
        else (scanl f (first xs) (rest xs))))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))
(define (compose2 f g)
  (lambda (x y) (f (g x y))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (not (p x))))

(def-macro (begin & exprs)
  (va-cons 'let '() exprs))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (va-cons 'lambda (cdr name-bindings) body))))

(define (spread xs)
  ((lambda (ys) (append (car ys) (caadr ys))) (take-drop (dec (size xs)) xs)))

(define (apply f & xs)
  (apply-to f (spread xs)))

(define (map f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs)) (map f (rest xs)))))
(define (map-eager f xs)
  (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (%map-indexed f xs i)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs) i) (%map-indexed f (rest xs) (inc i)))))
(define (map-indexed f xs) (%map-indexed f xs 0))

(define (mapv f xs) (foldl (lambda (v x) (vector-add v (f x))) [] xs))
(define (mapv-indexed f xs) (foldl-indexed (lambda (v x i) (vector-add v (f x i))) [] xs))

(define (map-while f p xs) (map f (take-while p xs)))
(define (map-until f p xs) (map f (take-until p xs)))

(define (maplist f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f xs) (maplist f (rest xs)))))

(define (mapcar f & ys)
  (v-zip-with f ys))

(define (mapcon f xs)
  (foldr append '() (maplist f xs)))

(define (mapcat f xs)
  (foldr append '() (map f xs)))

(define (filter p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (first xs) (filter p (rest xs)))
        else (filter p (rest xs))))

(define (filterv p xs)
  (foldl (lambda (v x) (if (p x) (vector-add v x) v)) '() xs))

(define (%filter-indexed p xs i)
  (cond (empty? xs) '()
        (p (first xs) i) (lazy-seq (first xs) (%filter-indexed p (rest xs) (inc i)))
        else (%filter-indexed p (rest xs) (inc i))))
(define (filter-indexed p xs) (%filter-indexed p xs 0))

(define (remove p xs) (filter (complement p) xs))
(define (remove-indexed p xs)
  (filter-indexed (lambda (x i) (not (p x i))) xs))

(define (fmap f p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (f (first xs)) (fmap f p (rest xs)))
        else (fmap f p (rest xs))))
(define (mapf f p xs)
  (if (empty? xs)
    '()
    (let ((y (f (first xs))))
      (if (p y)
        (lazy-seq y (mapf f p (rest xs)))
        (mapf f p (rest xs))))))

(define (%take-drop n st en)
  (if (or (= n 0) (empty? en))
    (list (reverse (->list st)) (->list en))
    (%take-drop (dec n) (cons (first en) st) (rest en))))
(define (take-drop n xs)
  (%take-drop n '() xs))
  
(define (%take-drop-until p st en)
  (if (or (empty? en) (p (first en)))
    (list (reverse (->list st)) (->list en))
    (%take-drop-until p (cons (first en) st) (rest en))))
(define (take-drop-until p xs)
  (%take-drop-until p '() xs))

(define (take-drop-while p xs)
  (%take-drop-until (complement p) '() xs))

(define (take n xs)
  (cond (<= n 0) '()
        (empty? xs) '()
        else (cons (first xs) (take (- n 1) (rest xs)))))
(define (take-while p xs)
  (cond (empty? xs) '()
        (p (first xs)) (cons (first xs) (take-while p (rest xs)))
        else '()))
(define (take-until p xs)
  (cond (empty? xs) '()
        (p (first xs)) '()
        else (cons (first xs) (take-until p (rest xs)))))

(define (drop n xs)
  (cond (<= n 0) xs
        (empty? xs) '()
        else (drop (- n 1) (rest xs))))
(define (drop-while p xs)
  (cond (empty? xs) '()
        (p (first xs)) (drop-while p (rest xs))
        else xs))
(define (drop-until p xs)
  (cond (empty? xs) '()
        (p (first xs)) xs
        else (drop-until p (rest xs))))

(define (subseq start length xs)
  (take length (drop start xs)))

(define (replace-subseq start length replacement xs)
  (let ((t (take-drop start xs)))
    (concat (car t) replacement (drop length (cadr t)))))


(define (all? p xs)
  (empty? (drop-while p xs)))
(define (none? p xs)
  (empty? (drop-until p xs)))
(define (any? p xs)
  (cond (empty? xs) #f
        (p (first xs)) #t
        else (any? p (rest xs))))

(define (count-by p xs)
  (foldl (lambda (res x) (if (p x) (+ res 1) res)) 0 xs))

(define (most? p xs)
  (> (count-by p xs) (/ (size xs) 2)))

(define (zip-with f l0 l1)
  (if (or (empty? l0) (empty? l1))
    '()
    (lazy-seq (f (first l0) (first l1)) (zip-with f (rest l0) (rest l1)))))

(define (zip l0 l1)
  (zip-with list l0 l1))
  
(define (zip-to-index xs)
  (map-indexed (lambda (x i) (list i x)) xs))

(define (v-zip-with f xs)
  (if (all? empty? xs)
    '()
    (cons (apply-to f (map-eager first xs)) (v-zip-with f (remove empty? (map-eager rest xs))))))

(define (split-by f xs)
  (foldr
    (lambda (x v) (if (f x) (cons '() v) (cons (cons x (car v)) (cdr v))))
    (list '())
    xs))

(define (split v xs)
  (split-by (lambda (x) (eq? v x)) xs))

(define (repeatedly f)
  (lazy-seq (f) (repeatedly f)))

(define (repeat e)
  (lazy-seq e (repeat e)))

(define (iterate f e)
  (lazy-seq e (iterate f (f e))))

(define (cycle xs)
  (if (empty? xs)
    '()
    (lazy-seq (first xs) (list-concat (rest xs) (cycle xs)))))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

(define (concat x & xs)
  (if (list? (car xs))
    (apply-to list-concat (cons x xs))
    (foldr1 append (cons x xs))))

(define (string-concat & xs)
  (or (foldr1 strcat (map-eager ->string xs)) ""))

(define (v+ x & xs) (foldl + x xs))
(define (v- x & xs) (if (empty? xs) (- 0 x) (foldl - x xs)))
(define (v* x & xs) (foldl * x xs))
(define (v/ x & xs) (foldl / x xs))
(define (v% x & xs) (foldl rem x xs))

(define (divmod x y) (list (/ x y) (rem x y)))

(define (constantly x) (lambda (& ys) x))

(define (%case e n cases)
  (cond
    (empty? cases) Nothing
    (= 1 (size cases)) (first cases)
    else
      (list 'let (list (list n (first cases)))
        (list 'cond
          (list 'and (list 'collection? n) (list 'contains? n e)) (second cases)
          (list 'and (list 'function? n) (list n e)) (second cases)
          (list 'eq? n e) (second cases)
          else (%case e n (rest (rest cases)))))))

(def-macro (case e & cases)
  (let ((n (gensym 'case)))
    (%case e n cases)))




;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


(define (va-cons & args) (foldr1 cons args))

; Could use some optimization
(define (flatten xs)
  (if (collection? xs)
    (foldr append '() (map flatten xs))
    (list xs)))

; Could use some optimization
(define (flatten1 xs)
  (apply-to list-concat (map (lambda (x) (if (collection? x) (->list x) (list x))) xs)))

(define sum (partial foldl + 0))
(define product (partial foldl * 1))

(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))
(define (minimum xs) (foldl1 min xs))
(define (maximum xs) (foldl1 max xs))

(define (range from to)
  (if (> from to)
    '()
    (lazy-seq from (range (inc from) to))))

(define (indices-of seq elem)
  (foldr-indexed
    (lambda (c acc i) (if (eq? c elem) (cons i acc) acc))
    '() seq))

(def-macro (Î» & args)
  (let* ((args1 (split '. args))
         (bindings (first args1))
         (body (rest args1)))
    (cons 'lambda (apply concat (list bindings) body))))

(define (doall! xs) xs)

(define (fact-seq)
  (map cadr
    (iterate
      (lambda (p)
        (list (inc (car p)) (* (car p) (cadr p))))
      '(1 1))))

(def-macro (-> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (va-cons (car expr) acc (cdr expr)) (list expr acc))) x exprs))

(def-macro (->> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (append expr (list acc)) (list expr acc))) x exprs))

(define (%as-> name x exprs)
  (if (empty? exprs)
    x
    (list 'let (list (list name x)) (%as-> name (car exprs) (cdr exprs)))))

(def-macro (as-> name x & exprs)
  (%as-> name x exprs))

(define (%case-lambda args forms acc)
  (cond
    (empty? forms)
      acc
    (list? (caar forms))
      (%case-lambda args (cdr forms)
        (cons
          (cons
            (list '= (list 'size args) (size (caar forms)))
            (list (list 'apply-to (va-cons 'lambda (caar forms) (cdar forms)) args)))
          acc))
    else
      (cons
        (cons
          #t
          (list (list 'apply-to (va-cons 'lambda (list '& (caar forms)) (cdar forms)) args)))
        acc)))

(def-macro (case-lambda & forms)
  (let ((args (gensym 'xs)))
    (list 'lambda (list '& args)
    (cons 'cond (flatten1 (reverse (%case-lambda args forms '())))))))

(def-macro (case-lambda* name & forms)
  (let ((args (gensym 'xs)))
    (list 'lambda* name (list '& args)
    (cons 'cond
      (append (flatten1 (reverse (%case-lambda args forms '())))
              (list #t (list 'error! (string-concat "Wrong arity for case-lambda " name) ''arity)))))))

(define xrange
  (case-lambda* xrange
    (() (iterate inc 0))
    ((from) (iterate inc from))
    ((from to) (xrange from to inc))
    ((from to step)
      (cond
        (>= from to) '()
        (function? step) (lazy-seq from (xrange (step from) to step))
        else (lazy-seq from (xrange (+ from step) to step))))))

(define (%condp p e cases)
  (if (empty? cases)
    Nothing
    (let ((c (eval! (first cases))))
      (cond
        (= 1 (size cases)) c
        (p c e) (second cases)
        else (%condp p e (rest cases))))))

(def-macro (condp p e & cases)
  (%condp p (eval! e) cases))

(define (scanr f v xs)
  (if (empty? xs)
    (list v)
    (let ((r (scanr f v (rest xs))))
      (cons (f (first xs) (first r)) r))))

(define (scanr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (list (first xs))
        else (let ((r (scanr1 f (rest xs))))
              (cons (f (first xs) (first r)) r))))


(define (frequencies xs)
  (foldl
    (lambda (acc x)
      (let ((v (or (map-get acc x) 0)))
        (map-set acc x (inc v))))
    (map-of)
    xs))

(define (%unique xs acc vals)
  (cond (empty? xs) acc
        (contains? vals (first xs)) (%unique (rest xs) acc vals)
        else (%unique (rest xs) (cons (first xs) acc) (set-add vals (first xs)))))
(define (unique xs)
  (reverse (%unique xs '() (set-of))))

(define (unique? xs)
  (eq? xs (unique xs)))

; (tuples 3 '(1 2 3 4 5)) ;=> ((1 2 3) (2 3 4) (3 4 5))
(define (tuples n xs)
  (cond 
    (= n 0) '()
    (< (size xs) n) '()
    else (cons (take n xs) (tuples n (rest xs)))))

; (slices 3 '(1 2 3 4 5 6)) ;=> ((1 2 3) (4 5 6))
(define (slices n xs)
  (cond
    (= n 0) '()
    (< (size xs) n) '()
    else (cons (take n xs) (slices n (drop n xs)))))

(def-macro (try f0 & fs)
  (let*((forms (take-drop-until
                (lambda (f) (and (list? f) (eq? (car f) 'catch)))
                (cons f0 fs)))
        (body (car forms))
        (_ (if (all?
                (lambda (f)
                  (and
                    (list? f)
                    (or (eq? (car f) 'catch)
                      (eq? (car f) 'finally))))
                (cadr forms))
              #t
              (error! "Syntax error: Invalid format for try-catch-finally" 'syntax)))
        (catch-finally (take-drop-until
                        (lambda (f) (eq? (car f) 'finally))
                        (cadr forms)))
        (catch-clauses (car catch-finally))
        (finally-clause (cadr catch-finally))
        (res-name (gensym 'try)))
    (list 'let (list (list res-name 
      (foldl (lambda (bd ct) (list 'try* bd ct)) (cons 'begin body) catch-clauses)))
      (if (empty? finally-clause) Nothing (cons 'begin (cdar finally-clause)))
      res-name)
    ))
    
(def-macro (loop bindings & body)
  (cond
    (odd? (size bindings)) (error! "Syntax error: Loop must have an even number of bindings." 'syntax)
    else (let* ((name (gensym 'loop))
                (args-values (slices 2 bindings))
                (args (map first args-values))
                (vals (map second args-values)))
          (cons (apply list 'lambda args body) vals))))

(def-macro (defmacro bindings & body)
  (va-cons 'def-macro bindings body))
)



