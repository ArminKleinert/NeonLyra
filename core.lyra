;;; Some core things

(define (list & xs)
  xs)

(def-macro (comment & xs) (nothing))

(def-macro (Î» bindings & body)
  (cons 'lambda (cons bindings body)))

(define else #t)

(define (not x) (if x #f #t))
(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (list 'let1 (list 'x0 x) (list 'if 'x0 'x0 y)))

(define (foldl f v xs)
  (if (empty? xs)
    v
    (foldl f (f v (first xs)) (rest xs))))

(define (foldl1 f xs)
  (cond ((empty? xs) Nothing)
        ((= (size xs) 1) (first xs))
        (else (foldl f (first xs) (rest xs)))))

(define (foldr f v xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr f v (rest xs)))))

(define (foldr1 f xs)
  (cond ((empty? xs) Nothing)
        ((= (size xs) 1) (first xs))
        (else (foldr f (first xs) (rest xs)))))

(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

(define (foldr-idx-helper f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr-idx-helper f v (inc i) (rest xs)) i)))
(define (foldr-indexed f v xs)
  (foldr-idx-helper f v 0 xs))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (not (p x))))

(def-macro (begin & exprs)
  (cons 'let (cons '() exprs)))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (cons 'lambda (cons (cdr name-bindings) body)))))

(define (map f xs) (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (filter p xs) (foldr (lambda (x v) (if (p x) (cons x v) v)) '() xs))
(define (remove p xs) (filter (complement p) xs))

(define (fmap f p xs)
 (foldr
  (lambda (x v)
    (if (p x) (cons (f x) v) v))
  '() xs))
(define (mapf f p xs)
 (foldr
  (lambda (x v)
    (let1 (z (f x)) (if (p z) (cons z v) v)))
  '() xs))

(define (take-drop-h n st en)
  (if (or (= n 0) (empty? en))
    (list (->list st) en)
    (take-drop-h (dec n) (vector-add st (first en)) (rest en))))
(define (take-drop n xs)
  (take-drop-h n [] xs))
  
(define (take-drop-until-h p st en)
  (if (or (empty? en) (p (first en)))
    (list (->list st) en)
    (take-drop-until-h p (vector-add st (first en)) (rest en))))
(define (take-drop-until p xs)
  (take-drop-until-h p [] xs))

(define (take-drop-while p xs)
  (take-drop-until-h (complement p) [] xs))

(define (take n xs)
  (cond ((= n 0) '())
        ((empty? xs) '())
        (else (cons (first xs) (take (- n 1) (rest xs))))))
(define (take-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (cons (first xs) (take-while p (rest xs))))
        (else '())))
(define (take-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) '())
        (else (cons (first xs) (take-until p (rest xs))))))

(define (drop n xs)
  (cond ((= n 0) xs)
        ((empty? xs) '())
        (else (drop (- n 1) (rest xs)))))
(define (drop-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (drop-while p (rest xs)))
        (else xs)))
(define (drop-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) xs)
        (else (drop-until p (rest xs)))))

(define (all? p xs)
  (= (size (drop-while p xs)) 0))
(define (none? p xs)
  (= (size (drop-until p xs)) 0))
(define (any? p xs)
  (cond ((empty? xs) #f)
        ((p (first xs)) #t)
        (else (any? p (rest xs)))))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

(define (concat & xs) (foldr append '() xs))

(define (v+ & xs) (foldl + 0 xs))

;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (reverse xs)
  (foldl (lambda (a b) (cons b a)) '() xs))

(define sum (partial foldl + 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))
(define (minimum xs) (foldl1 min xs))
(define (maximum xs) (foldl1 max xs))

(define (range from to)
  (if (> from to)
    '()
    (cons from (range (inc from) to))))

(define (bubble-up xs)
    (if (empty? (cdr xs))   
        xs
        (if (< (car xs) (cadr xs))
            (cons (car xs) (bubble-up (cdr xs)))   
            (cons (cadr xs) (bubble-up (cons (car xs) (cddr xs)))))))

(define (bubble-sort-aux n xs)    
  (let ((xs (->list xs)))
    (cond ((= n 1) (bubble-up xs))   
          (else (bubble-sort-aux (- n 1) (bubble-up xs))))))

(define (bubblesort xs)
  (bubble-sort-aux (size xs) xs))

;;; Aliases
(define includes? contains?)
(define require! load!)
(define fold foldr)
(define reduce foldl)

(def-generic x (foo x y) +)
(define ::integer foo -)
(define ::float foo *)

;;; Aliases for Clojure devs.

(def-macro (when p & body)
  (list 'if p (cons 'begin (cons Nothing body)) (nothing)))

(def-macro (def name val)
  (list 'define name val))

(def-macro (defn name bindings & body)
  (cons 'define (cons (cons name (->list bindings)) body)))

(def-macro (fn bindings & body)
  (cons 'lambda (cons (->list bindings) body)))

(define do begin)
(define slurp! file-read!)
(define spit! file-write!)


'ok






