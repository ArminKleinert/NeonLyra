;;; Some core things

(define (list & xs)
  xs)

(define (not x) (if x #f #t))
(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (list 'let1 (list 'x0 x) (list 'if 'x0 'x0 y)))

(define (foldl f v xs)
  (if (empty? xs)
    v
    (foldl f (f v (first xs)) (rest xs))))

(define (foldr f v xs)
  (if (empty? xs)
    v
    (f (first xs) (foldr f v (rest xs)))))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (p x)))

(def-macro (begin & exprs)
  (cons 'let (cons '() exprs)))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (cons 'lambda (cons (cdr name-bindings) body)))))

(define (map f xs) (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (filter p xs) (foldr (lambda (x v) (if (p x) (cons x v) v)) '() xs))
(define (remove p xs) (filter (complement p) xs))

(define (fmap f p xs)
 (foldr
  (lambda (x v)
    (if (p x) (cons (f x) v) v))
  '() xs))
(define (mapf f p xs)
 (foldr
  (lambda (x v)
    (let1 (z (f x)) (if (p z) (cons z v) v)))
  '() xs))

(define (take n xs)
  (cond ((= n 0) '())
        ((empty? xs) '())
        (#t (cons (first xs) (take (- n 1) (rest xs))))))
(define (take-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (cons (first xs) (take-while p (rest xs))))
        (#t '())))
(define (take-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) '())
        (#t (cons (first xs) (take-until p (rest xs))))))

(define (drop n xs)
  (cond ((= n 0) xs)
        ((empty? xs) '())
        (#t (drop (- n 1) (rest xs)))))
(define (drop-while p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) (drop-while p (rest xs)))
        (#t xs)))
(define (drop-until p xs)
  (cond ((empty? xs) '())
        ((p (first xs)) xs)
        (#t (drop-until p (rest xs)))))

(define (all? p xs)
  (= (size (drop-while p xs)) 0))
(define (none? p xs)
  (= (size (drop-until p xs)) 0))
(define (any? p xs)
  (cond ((empty? xs) #f)
        ((p (first xs)) #t)
        (#t (any? p (rest xs)))))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

;;; List and Vector stuff

(define (reverse xs)
  (foldl (lambda (a b) (cons b a)) '() xs))

(define sum (partial foldl + 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

;;; Aliases
(define includes? contains?)
(define require! load!)
(define fold foldr)
(define reduce foldl)

;;; Aliases for Clojure devs.

(def-macro (when p & body)
  (list 'if p (cons 'begin (cons Nothing body)) (nothing)))

(def-macro (def name val)
  (list 'define name val))

(def-macro (defn name bindings & body)
  (cons 'define (cons (cons name (->list bindings)) body)))

(def-macro (fn bindings & body)
  (cons 'lambda (cons (->list bindings) body)))

(define do begin)
(define slurp! file-read!)
(define spit! file-write!)

'ok
