(module core
  (comment unwrap foldr foldl append contains? nth ->symbol ->int ->float ->rational ->string ->bool ->list ->vector ->char ->map ->set eq? size rest first second reverse compare collection? sequence? number? print! println! flip fst snd list let1 (list-nth nth) last but-last empty? included? seq-eq? not-eq? symbol else and or odd? even? foldl1 foldl-indexed foldr1 foldr-indexed compose compose-or compose-and complement begin def-memo spread apply map map-eager map-indexed mapv mapv-indexed map-while map-until maplist mapcar mapcon mapcat filter filterv filter-indexed remove remove-indexed fmap mapf take-drop take-drop-until take-drop-while take take-while take-until drop drop-while drop-until subseq replace-subseq 
  ;all? none? any? 
  zip-with zip zip-to-index v-zip-with split-by split repeatedly repeat iterate va-all? va-none? va-any? concat string-concat v+ v- v* v/ v% caar cadr cdar cddr caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr flatten flatten1 sum product inc dec min max minimum maximum range indices-of λ doall! fact-seq -> ->> as-> divmod constantly case cycle case-lambda scanl scanl1 scanr scanr1 condp case-lambda* frequencies unique unique? add compose2 slices tuples xrange succ try count-by most? defmacro loop va-cons v= v/= v< v> v<= v>= partition dedupe times)

;;; Some core things

(def-macro (comment & xs) (nothing))

(def-generic x (unwrap x) buildin-unwrap)

(define (%foldr f s xs)
  (if (or (atom? xs) (empty? xs))
    s
    (f (first xs) (%foldr f s (rest xs)))))

(define (%foldl f s xs)
  (if (or (atom? xs) (empty? xs))
    s
    (%foldl f (f s (first xs)) (rest xs))))

(def-generic xs (foldr f v xs) %foldr)
(def-generic xs (foldl f v xs) %foldl)

(define (%add xs y)
  (append xs (list y)))

(define (%contains? xs e)
  (cond (empty? xs) #f
        (eq? (first xs) e) #t
        else (%contains? (rest xs) e)))

(def-generic xs (append xs ys) buildin-append)
(def-generic xs (add xs y) %add)
(def-generic xs (contains? xs e) %contains?)
(def-generic xs (nth xs i) (lambda (xs i) (if (or (empty? xs) (<= i 0)) (first xs) (recur (rest xs) (- i 1)))))
;buildin-nth

(def-generic x (->symbol x) buildin->symbol)
(def-generic x (->int x) (lambda (x) (buildin->int (buildin->float x))))
(def-generic x (->float x) buildin->float)
(def-generic x (->rational x) (lambda (x) (buildin->rational (buildin->float x))))
(def-generic x (->string x) buildin->string)
(def-generic x (->bool x) buildin->bool)
(def-generic x (->list x) buildin->list)
(def-generic x (->vector x) (lambda (x) (buildin->vector (->list x))))
(def-generic x (->char x) buildin->char)
(def-generic x (->map x) (lambda (x) (buildin->map (->list x))))
(def-generic x (->set x) (lambda (x) (buildin->set (->list x))))

(def-generic x (eq? x y) (lambda (x y) (if (and (sequence? x) (sequence? y)) (seq-eq? x y) (= x y))))

(define (%size xs)
  (let ((c (->list xs)))
    (if c (list-size (->list xs)) 0)))

(def-generic xs (size xs) (lambda (xs) (%size xs)))
(def-generic xs (rest xs) nothing)
(def-generic xs (first xs) nothing)
(def-generic xs (second xs) (lambda (xs) (first (rest xs))))
(def-generic xs (reverse xs) (lambda (xs) (foldl (lambda (a b) (cons b a)) '() xs)))

(def-generic x (compare x y) (lambda (x y) (if (= x y) 0 (if (< x y) -1 1))))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

(def-generic x (succ x) id)
(def-impl ::integer succ inc)
(def-impl ::float succ inc)
(def-impl ::rational succ inc)
(def-impl ::char succ (lambda (c) (int->char (inc (char->int c)))))
(def-impl ::string succ
  (lambda (s)
    (let ((len (- (string-size s) 1)))
      (if (< len 0)
        s
        (string-add
          (string-range s 0 len)
          (succ (->char (string-nth s len))))))))

(def-generic x (sequence? x)
  (lambda (xs) (or (list? xs) (vector? xs))))
(def-generic x (collection? x)
  (lambda (xs) (or (sequence? xs) (or (map? xs) (set? xs)))))
(def-generic x (number? x)
  (lambda (xs) (or (int? xs) (or (float? xs) (rational? xs)))))

(define (%print! xs)
  (if xs (let () (buildin-print! (->string (car xs))) (%print! (cdr xs))) Nothing))
(define (print! & xs)
  (%print! xs))
(define (println! & xs)
  (%print! xs)
  (buildin-print! "\n"))

(define (flip f)
  (lambda (x y) (f y x)))
; Take 2 arguments, return the first
(define (fst x y) x)
; Take 2 arguments, return the second
(define (snd x y) y)

(define (list & xs)
  xs)

(def-macro (let1 bindings & body)
  (va-cons 'let (list bindings) body))

(def-impl ::list nth buildin-nth)
(def-impl ::vector nth vector-nth)
(def-impl ::string nth buildin-nth)
(def-impl ::set nth (lambda (x i) (vector-nth (->vector x) i)))
(def-impl ::map nth (lambda (x i) (vector-nth (->vector x) i)))

(def-impl ::list contains? buildin-contains?)
(def-impl ::vector contains? buildin-contains?)
(def-impl ::string contains? buildin-contains?)
(def-impl ::set contains? buildin-contains?)
(def-impl ::map contains? buildin-contains?)

(def-impl ::list ->vector buildin->vector)
(def-impl ::vector ->vector id)
(def-impl ::string ->vector buildin->vector)
(def-impl ::set ->vector buildin->vector)
(def-impl ::map ->vector buildin->vector)

(def-impl ::list ->set buildin->set)
(def-impl ::vector ->set buildin->set)
(def-impl ::string ->set buildin->set)
(def-impl ::set ->set id)
(def-impl ::map ->set buildin->set)

(def-impl ::list ->map buildin->map)
(def-impl ::vector ->map buildin->map)
(def-impl ::string ->map buildin->map)
(def-impl ::set ->map buildin->map)
(def-impl ::map ->map id)

(def-impl ::list ->string (lambda (xs) (buildin->string (map-eager ->string xs))))
(def-impl ::vector ->string (lambda (xs) (buildin->string (mapv ->string xs))))

(def-impl ::list size list-size)
(def-impl ::vector size vector-size)
(def-impl ::string size string-size)
(def-impl ::set size set-size)
(def-impl ::map size map-size)

(def-impl ::list first car)
(def-impl ::vector first (lambda (v) (vector-nth v 0)))
(def-impl ::string first (lambda (v) (string-nth v 0)))
(def-impl ::set first (lambda (s) (vector-nth (set->vector s) 0)))
(def-impl ::map first (lambda (m) (vector-nth (map->vector m) 0)))

(def-impl ::list rest cdr)
(def-impl ::vector rest (lambda (v) (vector-range v 1 (vector-size v))))
(def-impl ::string rest (lambda (v) (string-range v 1 (string-size v))))
(def-impl ::set rest (lambda (s) (let ((v (set->vector s))) (vector-range v 1 (vector-size v)))))
(def-impl ::map rest (lambda (m) (let ((v (mao->vector m))) (vector-range v 1 (vector-size v)))))

(def-impl ::set reverse id)
(def-impl ::map reverse id)

(def-impl ::list add (lambda (l v) (append l (list x))))
(def-impl ::string add (lambda (s o) (string-add s (->string o))))
(def-impl ::vector add vector-add)
(def-impl ::set add set-add)
(def-impl ::map add (lambda (m kv) (map-set (first kv) (second kv))))

(def-impl ::integer ->int id)
(def-impl ::float ->int buildin->int)
(def-impl ::rational ->int buildin->int)
(def-impl ::char ->int buildin->int)
(def-impl ::string ->int buildin->int)

(def-impl ::integer ->rational buildin->rational)
(def-impl ::float ->rational buildin->rational)
(def-impl ::rational ->rational id)
(def-impl ::char ->rational buildin->rational)
(def-impl ::string ->rational buildin->rational)

(def-impl ::list foldr buildin-foldr)
(def-impl ::vector foldr buildin-foldr)
(def-impl ::string foldr buildin-foldr)
(def-impl ::set foldr buildin-foldr)
(def-impl ::map foldr buildin-foldr)

(def-impl ::list foldl buildin-foldl)
(def-impl ::vector foldl buildin-foldl)
(def-impl ::string foldl buildin-foldl)
(def-impl ::set foldl buildin-foldl)
(def-impl ::map foldl buildin-foldl)

(define (last xs)
  (let ((l (->list xs)))
    (if (list? l) (first (drop (dec (size l)) l)) (nothing))))
(define (but-last xs)
  (let ((l (->list xs)))
    (if (list? l) (take (dec (size l)) l) (nothing))))

(define (empty? xs) (if (list? xs) (null? xs) (or (nothing? xs) (= (size xs) 0))))

(define (included? e s) (contains? s e))

(define (seq-eq? l0 l1)
  (if (empty? l0)
    (empty? l1)
    (and (and (not (empty? l1)) (eq? (first l0) (first l1)))
         (seq-eq? (rest l0) (rest l1)))))

(def-impl ::list eq? seq-eq?)
(def-impl ::vector eq? (lambda (v0 v1) (seq-eq? (->vector v0) (->vector v1))))
(def-impl ::set eq? set-eq?)
(def-impl ::map eq? map-eq?)
(def-impl ::string eq? string-eq?)

(define (not-eq? x y) (not (eq? x y)))

(define symbol ->symbol)

(define else #t)

(def-macro (and x y) (list 'if x y #f))
(def-macro (or x y) (let ((s (gensym 'x))) (list 'let (list (list s x)) (list 'if s s y))))

(define (odd? n) (= 1 (rem (->int n) 2)))
(define (even? n) (= 0 (rem (->int n) 2)))

(define (foldl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (foldl f (first xs) (rest xs))))

(define (foldl-indexed f s xs)
  ((lambda (f acc i xs)
    (if (empty? xs)
      acc
      (recur f (f acc (first xs) i) (inc i) (rest xs))))
    f s 0 xs))

(define (foldr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (first xs)
        else (f (first xs) (foldr1 f (rest xs)))))

(define (%foldr-indexed f v i xs)
  (if (empty? xs)
    v
    (f (first xs) (%foldr-indexed f v (inc i) (rest xs)) i)))
(define (foldr-indexed f v xs)
  (%foldr-indexed f v 0 xs))

(define (scanl f v xs)
  (let ((%scanl
        (lambda (r a ys)
          (if (empty? ys)
            r
            (let ((b (f a (first ys)))) (%scanl (cons b r) b (rest ys)))))))
    (reverse (%scanl (list v) v xs))))

(define (scanl1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) xs
        else (scanl f (first xs) (rest xs))))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))
(define (compose2 f g)
  (lambda (x y) (f (g x y))))

; Function composition
(define (compose-or f g)
  (lambda (x) (or (f x) (g x))))

; Function composition
(define (compose-and f g)
  (lambda (x) (and (f x) (g x))))

; Function complement
(define (complement p)
  (lambda (x) (not (p x))))

(def-macro (begin & exprs)
  (va-cons 'let '() exprs))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (va-cons 'lambda (cdr name-bindings) body))))

(define (spread xs)
  ((lambda (ys) (append (car ys) (caadr ys))) (take-drop (dec (size xs)) xs)))

(define (apply f & xs)
  (apply-to f (spread xs)))

(define (map f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs)) (map f (rest xs)))))
(define (map-eager f xs)
  (foldr (lambda (x v) (cons (f x) v)) '() xs))
(define (%map-indexed f xs i)
  (if (empty? xs)
    '()
    (lazy-seq (f (first xs) i) (%map-indexed f (rest xs) (inc i)))))
(define (map-indexed f xs) (%map-indexed f xs 0))

(define (mapv f xs) (foldl (lambda (v x) (vector-add v (f x))) [] xs))
(define (mapv-indexed f xs) (foldl-indexed (lambda (v x i) (vector-add v (f x i))) [] xs))

(define (map-while f p xs) (map f (take-while p xs)))
(define (map-until f p xs) (map f (take-until p xs)))

(define (maplist f xs)
  (if (empty? xs)
    '()
    (lazy-seq (f xs) (maplist f (rest xs)))))

(define (mapcar f & ys)
  (v-zip-with f ys))

(define (mapcon f xs)
  (foldr append '() (maplist f xs)))

(define (mapcat f xs)
  (foldr append '() (map f xs)))

(define (filter p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (first xs) (filter p (rest xs)))
        else (filter p (rest xs))))

(define (filterv p xs)
  (foldl (lambda (v x) (if (p x) (vector-add v x) v)) '() xs))

(define (%filter-indexed p xs i)
  (cond (empty? xs) '()
        (p (first xs) i) (lazy-seq (first xs) (%filter-indexed p (rest xs) (inc i)))
        else (%filter-indexed p (rest xs) (inc i))))
(define (filter-indexed p xs) (%filter-indexed p xs 0))

(define (remove p xs) (filter (complement p) xs))
(define (remove-indexed p xs)
  (filter-indexed (lambda (x i) (not (p x i))) xs))

(define (fmap f p xs)
  (cond (empty? xs) '()
        (p (first xs)) (lazy-seq (f (first xs)) (fmap f p (rest xs)))
        else (fmap f p (rest xs))))
(define (mapf f p xs)
  (if (empty? xs)
    '()
    (let ((y (f (first xs))))
      (if (p y)
        (lazy-seq y (mapf f p (rest xs)))
        (mapf f p (rest xs))))))

(define (%take-drop n st en)
  (if (or (= n 0) (empty? en))
    (list (reverse (->list st)) (->list en))
    (%take-drop (dec n) (cons (first en) st) (rest en))))
(define (take-drop n xs)
  (%take-drop n '() xs))
  
(define (%take-drop-until p st en)
  (if (or (empty? en) (p (first en)))
    (list (reverse (->list st)) (->list en))
    (%take-drop-until p (cons (first en) st) (rest en))))
(define (take-drop-until p xs)
  (%take-drop-until p '() xs))

(define (take-drop-while p xs)
  (%take-drop-until (complement p) '() xs))

(define (%take n xs)
  (if (or (= 0 n) (empty? xs))
    '()
    (cons (first xs) (%take (dec n) (rest xs)))))
(define (take n xs)
  (cond
    (atom? xs)
      Nothing
    (or (list? xs) (or (vector? xs) (or (set? xs) (map? xs))))
      (buildin-take n xs)
    else (%take n xs)))
(define (take-while p xs)
  (cond (empty? xs) '()
        (p (first xs)) (cons (first xs) (take-while p (rest xs)))
        else '()))
(define (take-until p xs)
  (cond (empty? xs) '()
        (p (first xs)) '()
        else (cons (first xs) (take-until p (rest xs)))))

(define (drop n xs)
  (cond (<= n 0) xs
        (empty? xs) '()
        else (drop (- n 1) (rest xs))))
(define (drop-while p xs)
  (cond (empty? xs) '()
        (p (first xs)) (drop-while p (rest xs))
        else xs))
(define (drop-until p xs)
  (cond (empty? xs) '()
        (p (first xs)) xs
        else (drop-until p (rest xs))))

(define (subseq start length xs)
  (take length (drop start xs)))

(define (replace-subseq start length replacement xs)
  (let ((t (take-drop start xs)))
    (concat (car t) replacement (drop length (cadr t)))))


(comment define (all? p xs)
  (empty? (drop-while p xs)))
(comment define (none? p xs)
  (empty? (drop-until p xs)))
(comment define (any? p xs)
  (cond (empty? xs) #f
        (p (first xs)) #t
        else (any? p (rest xs))))

(define (count-by p xs)
  (foldl (lambda (res x) (if (p x) (+ res 1) res)) 0 xs))

(define (most? p xs)
  (> (count-by p xs) (/ (size xs) 2)))

(define (zip-with f l0 l1)
  (if (or (empty? l0) (empty? l1))
    '()
    (lazy-seq (f (first l0) (first l1)) (zip-with f (rest l0) (rest l1)))))

(define (zip l0 l1)
  (zip-with list l0 l1))
  
(define (zip-to-index xs)
  (map-indexed (lambda (x i) (list i x)) xs))

(define (v-zip-with f xs)
  (if (all? empty? xs)
    '()
    (cons (apply-to f (map-eager first xs)) (v-zip-with f (remove empty? (map-eager rest xs))))))

(define (split-by f xs)
  (foldr
    (lambda (x v) (if (f x) (cons '() v) (cons (cons x (car v)) (cdr v))))
    (list '())
    xs))

(define (split v xs)
  (split-by (lambda (x) (eq? v x)) xs))

(define (repeatedly f)
  (lazy-seq (f) (repeatedly f)))

(define (repeat e)
  (lazy-seq e (repeat e)))

(define (iterate f e)
  (lazy-seq e (iterate f (f e))))

(define (cycle xs)
  (if (empty? xs)
    '()
    (lazy-seq (first xs) (list-concat (rest xs) (cycle xs)))))

; Variadic variants for all?, none? and any?
(define (va-all? p & xs) (all? p xs))
(define (va-none? p & xs) (none? p xs))
(define (va-any? p & xs) (any? p xs))

(define (concat x & xs)
  (if (list? (car xs))
    (apply-to list-concat (cons x xs))
    (foldr1 append (cons x xs))))

(define (string-concat & xs)
  (or (foldr1 strcat (map-eager ->string xs)) ""))

(define (v= x & xs) (cond (empty? xs) #t (= x (car xs)) (apply-to v= (cdr xs)) #f))
(define (v/= x & xs) (not (unique? (cons x xs))))
(define (v< x & xs) (cond (empty? xs) #t (< x (car xs)) (apply-to v< (cdr xs)) #f))
(define (v> x & xs) (cond (empty? xs) #t (> x (car xs)) (apply-to v> (cdr xs)) #f))
(define (v<= x & xs) (cond (empty? xs) #t (<= x (car xs)) (apply-to v<= (cdr xs)) #f))
(define (v>= x & xs) (cond (empty? xs) #t (>= x (car xs)) (apply-to v>= (cdr xs)) #f))

(define (v+ x & xs) (foldl + x xs))
(define (v- x & xs) (if (empty? xs) (- 0 x) (foldl - x xs)))
(define (v* x & xs) (foldl * x xs))
(define (v/ x & xs) (foldl / x xs))
(define (v% x & xs) (foldl rem x xs))

(define (divmod x y) (list (/ x y) (rem x y)))

(define (constantly x) (lambda (& ys) x))

(define (%case e n cases)
  (cond
    (empty? cases) Nothing
    (= 1 (size cases)) (first cases)
    else
      (list 'let (list (list n (first cases)))
        (list 'cond
          (list 'and (list 'collection? n) (list 'contains? n e)) (second cases)
          (list 'and (list 'function? n) (list n e)) (second cases)
          (list 'eq? n e) (second cases)
          else (%case e n (rest (rest cases)))))))

(def-macro (case e & cases)
  (let ((n (gensym 'case)))
    (%case e n cases)))




;;; List and Vector stuff

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))
(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))


(define (va-cons & args) (foldr1 cons args))

; Could use some optimization
(define (flatten xs)
  (if (collection? xs)
    (foldr append '() (map flatten xs))
    (list xs)))

; Could use some optimization
(define (flatten1 xs)
  (apply-to list-concat (map (lambda (x) (if (collection? x) (->list x) (list x))) xs)))

(define sum (partial foldl + 0))
(define product (partial foldl * 1))

(define (min n m) (if (< n m) n m))
(define (max n m) (if (< n m) m n))
(define (minimum xs) (foldl1 min xs))
(define (maximum xs) (foldl1 max xs))

(define (range from to)
  (if (> from to)
    '()
    (lazy-seq from (range (inc from) to))))

(define (indices-of seq elem)
  (foldr-indexed
    (lambda (c acc i) (if (eq? c elem) (cons i acc) acc))
    '() seq))

(def-macro (λ & args)
  (let* ((args1 (split '. args))
         (bindings (first args1))
         (body (rest args1)))
    (cons 'lambda (apply concat (list bindings) body))))

(define (doall! xs) xs)

(define (fact-seq)
  (map cadr
    (iterate
      (lambda (p)
        (list (inc (car p)) (* (car p) (cadr p))))
      '(1 1))))

(def-macro (-> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (va-cons (car expr) acc (cdr expr)) (list expr acc))) x exprs))

(def-macro (->> x & exprs)
  (foldl (lambda (acc expr) (if (list? expr) (append expr (list acc)) (list expr acc))) x exprs))

(define (%as-> name x exprs)
  (if (empty? exprs)
    x
    (list 'let (list (list name x)) (%as-> name (car exprs) (cdr exprs)))))

(def-macro (as-> name x & exprs)
  (%as-> name x exprs))
  
(define (%case-lambda-arity bindings)
  (let* ((num-bindings (size bindings))
         (variadic (= (nth bindings (- num-bindings 2)) '&))
         (min-arity (if variadic (- num-bindings 2) num-bindings)))
    (if variadic
      (list #t min-arity)
      (list #f min-arity))))

(define (%case-lambda args forms acc)
  (cond
    (empty? forms)
      acc
    (list? (caar forms))
      (%case-lambda args (cdr forms)
        (cons
          (cons
            (let* ((cl-arity (%case-lambda-arity (caar forms)))
                   (variadic (car cl-arity))
                   (min-arity (cadr cl-arity)))
              (if variadic
                (list '>= (list 'size args) min-arity)
                (list '= (list 'size args) min-arity)))
            (list (list 'apply-to (cons 'lambda (cons (caar forms) (cdar forms))) args)))
          acc))
    else
      (cons
        (cons
          #t
          (list (list 'apply-to (va-cons 'lambda (list '& (caar forms)) (cdar forms)) args)))
        acc)))

(def-macro (case-lambda & forms)
  (let ((args (gensym 'xs)))
    (list 'lambda (list '& args)
      (cons 'cond (flatten1 (reverse (%case-lambda args forms '())))))))

(def-macro (case-lambda* name & forms)
  (let ((args (gensym 'xs)))
    (list 'lambda* name (list '& args)
      (cons 'cond
        (append
          (flatten1 (reverse (%case-lambda args forms '())))
          (list #t (list 'error! (string-concat "Wrong arity for case-lambda " name) ''arity)))))))

(define xrange
  (case-lambda* xrange
    (() (iterate inc 0))
    ((from) (iterate inc from))
    ((from to) (xrange from to inc))
    ((from to step)
      (cond
        (>= from to) '()
        (function? step) (lazy-seq from (xrange (step from) to step))
        else (lazy-seq from (xrange (+ from step) to step))))))

(define (%condp p e cases)
  (if (empty? cases)
    Nothing
    (let ((c (eval! (first cases))))
      (cond
        (= 1 (size cases)) c
        (p c e) (second cases)
        else (%condp p e (rest cases))))))

(def-macro (condp p e & cases)
  (%condp p (eval! e) cases))

(define (scanr f v xs)
  (if (empty? xs)
    (list v)
    (let ((r (scanr f v (rest xs))))
      (lazy-seq (f (first xs) (first r)) r))))

(define (scanr1 f xs)
  (cond (empty? xs) Nothing
        (= (size xs) 1) (list (first xs))
        else (let ((r (scanr1 f (rest xs))))
              (lazy-seq (f (first xs) (first r)) r))))


(define (frequencies xs)
  (foldl
    (lambda (acc x)
      (let ((v (or (map-get acc x) 0)))
        (map-set acc x (inc v))))
    {} xs))

(define (%unique xs acc vals)
  (cond (empty? xs) acc
        (contains? vals (first xs)) (%unique (rest xs) acc vals)
        else (%unique (rest xs) (lazy-seq (first xs) acc) (set-add vals (first xs)))))
(define (unique xs)
  (reverse (%unique xs '() (set-of))))

(define (unique? xs)
  (eq? xs (unique xs)))

; (tuples 3 '(1 2 3 4 5)) ;=> ((1 2 3) (2 3 4) (3 4 5))
(define (tuples n xs)
  (cond 
    (= n 0) '()
    (< (size xs) n) '()
    else (lazy-seq (take n xs) (tuples n (rest xs)))))

; (slices 3 '(1 2 3 4 5 6)) ;=> ((1 2 3) (4 5 6))
(define (slices n xs)
  (cond
    (= n 0) '()
    (< (size xs) n) '()
    else (lazy-seq (take n xs) (slices n (drop n xs)))))

(def-macro (try f0 & fs)
  (let*((forms (take-drop-until
                (lambda (f) (and (list? f) (eq? (car f) 'catch)))
                (cons f0 fs)))
        (body (car forms))
        (_ (if (all?
                (lambda (f)
                  (and
                    (list? f)
                    (or (eq? (car f) 'catch)
                      (eq? (car f) 'finally))))
                (cadr forms))
              #t
              (error! "Syntax error: Invalid format for try-catch-finally" 'syntax)))
        (catch-finally (take-drop-until
                        (lambda (f) (eq? (car f) 'finally))
                        (cadr forms)))
        (catch-clauses (car catch-finally))
        (finally-clause (cadr catch-finally))
        (res-name (gensym 'try)))
    (list 'let (list (list res-name 
      (foldl (lambda (bd ct) (list 'try* bd ct)) (cons 'begin body) catch-clauses)))
      (if (empty? finally-clause) Nothing (cons 'begin (cdar finally-clause)))
      res-name)
    ))
    
(def-macro (loop bindings & body)
  (cond
    (odd? (size bindings))
      (error! "Syntax error: Loop must have an even number of bindings." 'syntax)
    else
      (let* ((name (gensym 'loop))
             (args-values (slices 2 bindings))
             (args (map first args-values))
             (vals (map second args-values)))
        (cons (apply list 'lambda args body) vals))))

(def-macro (defmacro bindings & body)
  (va-cons 'def-macro bindings body))

(define into
  (case-lambda* into
    (() '())
    ((to) to)
    ((to from) (foldl add to from))
    ((to f from) (foldl add to (f from)))))

(define (%partition n step pad xs)
  (cond
    (< (size xs) n) (list (list-concat xs (take (- n (size xs)) pad)))
    else (lazy-seq (take n xs) (%partition n step pad (drop step xs)))))

(define partition
  (case-lambda* partition
    ((n xs) (%partition n n '() xs))
    ((n step xs) (%partition n step '() xs))
    ((n step pad xs) (%partition n step pad xs))))

(define (%dedupe prev xs)
  (cond (empty? xs) xs
        (eq? (first xs) prev) (%dedupe prev (rest xs))
        else (lazy-seq (first xs) (%dedupe (first xs) (rest xs)))))
(define (dedupe xs)
  (cond (or (set? xs) (map? xs)) xs
        (empty? xs) xs
        else (lazy-seq (first xs) (%dedupe (first xs) (rest xs)))))

(define (times f n)
  (lambda (x) (loop (n1 n y x) (if (<= n1 0) y (recur (dec n1) (f y))))))
)


