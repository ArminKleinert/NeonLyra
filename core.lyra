;;; Some core things

(define (list & xs)
  xs)

(define (foldl f v xs)
  (if (empty? xs)
    v
    (foldl f (f v (car xs)) (cdr xs))))

(define (foldr f v xs)
  (if (empty? xs)
    v
    (f (car xs) (foldr f v (cdr xs)))))

; Function composition
(define (compose f g)
  (lambda (x) (f (g x))))

(def-macro (begin & exprs)
  (cons 'let (cons '() exprs)))

(def-macro (def-memo name-bindings & body)
  (list 'define (car name-bindings) (list 'memoize (cons 'lambda (cons (cdr name-bindings) body)))))

(define (map f xs) (foldr (lambda (x v) (cons (f x) v)) '() xs))

;;; List and Vector stuff

(define (reverse xs)
  (foldl (lambda (a b) (cons b a)) '() xs))

(define sum (partial foldl + 0))

(define (inc n) (+ n 1))
(define (dec n) (- n 1))

;;; Aliases
(define includes? contains?)
(define require! load!)
(define fold foldr)
(define reduce foldl)

;;; Aliases for Clojure devs.

(def-macro (def name val)
  (list 'define name val))

(def-macro (defn name bindings & body)
  (cons 'define (cons (cons name (->list bindings)) body)))

(def-macro (fn bindings & body)
  (cons 'lambda (cons (->list bindings) body)))

(define do begin)
(define slurp! file-read!)
(define spit! file-write!)

'ok
