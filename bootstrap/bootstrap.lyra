(define (list & xs) xs)

(define (list-empty? l)
  (= (list-size l) 0))

(define (list-remove l val)
  (filter (lambda (e) (not (eq? e val))) l))

(define (list-append l0 l1)
  (if (list-empty? l0)
    l1
    (list-append (cdr l0) (cons (car l0) l1))))

(define (list-concat l0 & ls)
  (foldr1 list-append (cons l0 ls)))

(define (list-pairs l0 l1)
  (cond ((list-empty? l0) '())
        ((list-empty? l1) '())
        (else (cons (list (car l0) (car l1)) (list-pairs l0 l1)))))

; From from x to y (exclusive)
(define (range x y)
  (if (>= x y)
    '()
    (cons x (range (inc x) y))))







(define (iterate-seq-p-helper pred func acc vec index)
  (cond
    ((empty? vec) acc)
    ((not (pred acc (first vec) index)) acc)
    (#t (iterate-seq-p-helper pred func
          (func acc (first vec) index) (rest vec) (inc index)))))

(define (iterate-seq-p pred func acc vec)
  (iterate-seq-p-helper pred func acc vec 0))

(define (iterate-seq func acc vec)
  (iterate-seq-p-helper (lambda (x y z) #t) func acc vec 0))



(define (box? x) (is-a? x ::box))
(define (nothing? x) (= x Nothing))
(define nil? nothing?)
(define (null? x) (or (nothing? x) (empty? x)))
(define (list? x) (is-a? x ::list))
(define (int? x) (is-a? x ::integer))
(define (float? x) (is-a? x ::float))
(define (string? x) (is-a? x ::string))
(define (symbol? x) (is-a? x ::symbol))
(define (char? x) (and (string? x) (= 1 (size x))))
(define (boolean? x) (or (= x #t) (= x #f)))
(define (map? x) (is-a? x ::map))
(define (function? x) (is-a? x ::function))













