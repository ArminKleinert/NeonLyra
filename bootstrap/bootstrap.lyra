(define (list & xs) xs)

(define (list-empty? l)
  (= (list-size l) 0))

(define (list-remove l val)
  (filter (lambda (e) (not (eq? e val))) l))

(define (list-append l0 l1)
  (if (list-empty? l0)
    l1
    (list-append (cdr l0) (cons (car l0) l1))))

(define (list-pairs l0 l1)
  (cond ((list-empty? l0) '())
        ((list-empty? l1) '())
        (else (cons (list (car l0) (car l1)) (list-pairs l0 l1)))))

; From from x to y (exclusive)
(define (range x y)
  (if (>= x y)
    '()
    (cons x (range (inc x) y))))


;;;;;
; Vector implemented as a tree.
; Vectors should be implemented as a native construct of cause
; because they should have an access complexity of O(1), but this
; implementation is only O(log(n)).
; If a negative index is accessed, the behavior is implementation
; defined.
(def-type vector-node left index value right)
(def-type vector size entry)

(define (vector-node-set vec idx e)
  (cond
    ((nothing? vec) (make-vector-node Nothing idx e Nothing))
    ((= (vector-node-index vec) idx)
      (make-vector-node (vector-node-left vec) idx e (vector-node-right vec)))
    ((< (vector-node-inde vec) idx)
      (make-vector-node (vector-node-left vec) idx e (vector-node-set (vector-node-right vec))))
    (else
      (make-vector-node (vector-node-set (vector-node-left vec)) idx e (vector-node-right vec)))))

(define (vector-set vec idx e)
  (if (< idx 0)
    vec
    (vector-node-set (vector-entry idx e))))

(define (vector-empty? vec)
  (nothing? (vector-entry vec)))

(define (vector-node-max-idx vec acc)
  (if (nothing? (vector-node-right vec))
    (vector-node-idx vec)
    (vector-node-max-idx (vector-node-right vec))))

(define (vector-size vec)
  (if (vector-empty? vec)
    0
    (inc (vector-node-max-idx (vector-entry vec)))))

(define (vector-append vec e)
  (vector-set vec (vector-size vec) e))

; The elements are insert from the higher indices to the lower,
; so the vector's right side will be fast to access and appending
; will be very quick. Indexed access to the first elements will be
; better if the order of insertion is reversed.
(define (vector & xs)
  (foldr
    (lambda (ix v)
      (vector-set v (car ix) (cadr ix)))
    (make-vector Nothing)
    (list-pairs (range 0 (size xs)) xs)))




(define (iterate-seq-p-helper pred func acc vec index)
  (cond
    ((empty? vec) acc)
    ((not (pred acc (first vec) index)) acc)
    (#t (iterate-seq-p-helper pred func
          (func acc (first vec) index) (rest vec) (inc index)))))

(define (iterate-seq-p pred func acc vec)
  (iterate-seq-p-helper pred func acc vec 0))

(define (iterate-seq func acc vec)
  (iterate-seq-p-helper (lambda (x y z) #t) func acc vec 0))








;;;;;
; Simple but bad list-set implementation.

(def-type set vals)

(define (set-of & vals) (make-set vals))

(define (set-add set v) (make-set set (cons v (set-vals set))))

(define (set-remove set v) (make-set set (list-remove (set-vals set) v)))

(define (set-includes? set v) (list-includes? (set-vals set)))

(define (set-size set) (list-size (set-vals set)))

(define (set-union set0 set1) (make-set (list-append (set-vals set0) (set-vals set1))))

(define (set-intersection set0 set1)
  (make-set (filter (lambda (e) (set-includes? set1 e)) (set-vals set0))))

(define (set-difference)
  (make-set
    (list-append
      (remove (lambda (e) (set-includes? set1 e)) (set-vals set0))
      (remove (lambda (e) (set-includes? set0 e)) (set-vals set1)))))












