(module vector
()
;;;;;
; Vector implemented as a tree.
; Vectors should be implemented as a native construct of cause
; because they should have an access complexity of O(1), but this
; implementation is only O(log(n)).
; If a negative index is accessed, the behavior is implementation
; defined.
(def-type vector-node left index value right)
(def-type mvector size entry)

(define make-vector make-mvector)

(define (vector-node-set vec idx e)
  (cond
    ((nothing? vec) (make-vector-node Nothing idx e Nothing))
    ((= (vector-node-index vec) idx)
      (make-vector-node (vector-node-left vec) idx e (vector-node-right vec)))
    ((< (vector-node-inde vec) idx)
      (make-vector-node (vector-node-left vec) (vector-node-index vec) (vector-node-value vec) (vector-node-set (vector-node-right vec) idx e)))
    (else
      (make-vector-node (vector-node-set (vector-node-left vec) idx e) (vector-node-index vec) (vector-node-value vec) (vector-node-right vec)))))

(define (vector-set vec idx e)
  (if (< idx 0)
    vec
    (let ((v (vector-node-set (vector-entry idx e))))
      (make-vector (vector-size v) v))))

(define (vector-empty? vec)
  (nothing? (vector-entry vec)))

(define (vector-node-max-idx vec acc)
  (if (nothing? (vector-node-right vec))
    (vector-node-idx vec)
    (vector-node-max-idx (vector-node-right vec))))

(define (vector-size vec)
  (if (vector-empty? vec)
    0
    (inc (vector-node-max-idx (vector-entry vec)))))

(define (vector-append vec e)
  (vector-set vec (vector-size vec) e))

(define (vector->list v l)
  (cond ((nothing? v) Nothing)
        (else (list-append (vector->list (vector-node-left v)) (cons (vector-node-value v) (vector->list (vector-node-right v)))))))

; The elements are insert from the higher indices to the lower,
; so the vector's right side will be fast to access and appending
; will be very quick. Indexed access to the first elements will be
; better if the order of insertion is reversed.
(define (list->vector xs)
  (foldr
    (lambda (ix v)
      (vector-set v (car ix) (cadr ix)))
    (make-vector Nothing)
    (zip-to-index xs)))

(define (vector & xs)
  (list->vector xs))
)
