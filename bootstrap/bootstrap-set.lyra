(module bootstrap-set
  ((set-of set-of)
   (set->list set->list)
   (set-size set-size)
   (set-add set-add)
   (set-union set-union)
   (set-difference set-difference)
   (set-intersection set-intersection)
   (set-includes? set-includes?)
   (set-subset? set-subset?)
   (set-true-subset? set-true-subset?)
   (set-superset? set-superset?)
   (set-true-superset? set-true-superset?)
   (set-remove set-remove)
   (set-eq? set-eq?))

;;;;;
; Simple but bad list-set implementation.

; set? is automatically defined
(def-type set vals)

(define (list->set xs)
  (make-set xs))

(define (set-of & vals)
  (list->set vals))

(define set->list set-vals)

(define (set-size set)
  (list-size (set->list set)))

(define (set->vector set)
  (list->vector (set->list set)))

(define (set-add set v)
  (if (set-includes? set v)
    set
    (make-set (set->list v))))

(define (set-union set0 set1)
  (make-set (list-concat (set-difference set0 set1) set1)))

(define (set-difference set0 set1)
  (make-set
    (list-concat
      (remove (lambda (e) (set-includes? set1 e)) (set->list set0)))))

(define (set-intersection set0 set1)
  (make-set (filter (lambda (e) (set-includes? set1 e)) (set->list set0))))

(define (set-includes? set v)
  (list-includes? (set->list set)))

(define (set-subset? xs ys)
  (all? (lambda (e) (set-includes? ys e)) xs))

(define (set-true-subset? xs ys)
  (and (< (set-size xs) (set-size ys)) (set-subset? xs ys)))

(define (set-superset? xs ys)
  (set-subset? ys xs))

(define (set-true-superset? xs ys)
  (set-true-subset? ys xs))

(define (set-remove set v)
  (make-set (remove (lambda (e) (= e v)) (set->list set))))

(define (set-eq? xs ys)
  (and (= (set-size xs) (set-size ys))
       (= 0 (set-size (set-difference xs ys)))))
)
