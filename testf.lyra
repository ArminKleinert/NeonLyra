(define (%destructure-vec pb bvec b val)
  (let*((gvec (gensym "vec__"))
        (gseq (gensym "seq__"))
        (gfirst (gensym "first__"))
        (has-rest (= '& b)))
    ((lambda* destructure-vec-loop (ret n bs seen-rest?) 
      (if (seq bs)
        (let* ((firstb (first bs)))
          (cond
          (= firstb '&) (recur (pb ret (second bs) gseq)
                                n
                                (rest (rest bs))
                                #t)
          (= firstb :as) (pb ret (second bs) gvec)
          else (if seen-rest?
                  (error! "Unsupported binding form, only :as can follow & parameter" 'syntax)
                  (recur (pb (if has-rest
                                (concat ret
                                      (list gfirst `(first ~gseq)
                                      gseq `(next ~gseq)))
                                ret)
                              firstb
                              (if has-rest
                                gfirst
                                (list `nth gvec n)))
                          (inc n)
                          (rest (rest bs))
                          seen-rest?))))
        ret))
          (let* ((ret (concat bvec (list gvec val))))
            (if has-rest
              (concat ret (list gseq (list `seq gvec))) ret))
          0 b #f)))

(define (%destructure-map pb bvec b v)
  (let*((gmap (gensym "map__"))
        (gmapseq (->list gmap))
        (defaults (get b :or)))
    (loop1 [ret ((lambda (ret)
                      (if (get b :as)
                        (conj ret (get b :as) gmap)
                        ret))
                  (conj bvec 
                    gmap v gmap
                    `(if (seq? ~gmap) (->map (slices 2 (seq ~gmapseq))) ~gmap)))
          bes (let* ((transforms
                      (foldl
                        (lambda (transforms mk)
                          (if (keyword? mk)
                            (cond (= mk :keys) (map-set transforms mk ->keyword)
                                  (= mk :syms) (map-set transforms mk #(list `quote (symbol (name %))))
                                  (= mk :strs) (map-set transforms mk ->string)
                                  else transforms)
                            transforms))
                        {} (map-keys b))))
                (foldl
                  (lambda (bes entry)
                    (foldl
                      #(map-set %1 %2 (get %2 (second entry)))
                      (map-remove bes (first entry))
                      (get bes (first entry))))
                  (map-remove (map-remove b :as) :or)
                  (->list transforms)))]
      (if (seq bes)
        (let*((bb (first (first bes))) ; Key
              (bk (second (first bes))) ; Value
              (local bb)
              (bv (if (contains? defaults local)
                  (list `get gmap bk (get defaults local))
                  (list `get gmap bk))))
          (recur (if (or (symbol? bb) (keyword? bb))
                  (conj ret local bv)
                  (pb ret bb bv))
                (rest bes)))
        ret))))

(define (destructure bindings)
  (let*((bents (partition 2 bindings))
        (pb (lambda* pb (bvec b v)
             (let*((pvec %destructure-vec)
                   (pmap %destructure-map))
              (cond
                (symbol? b) (concat bvec (list b v))
                (vector? b) (pvec pb bvec b v)
                (map? b) (pmap pb bvec b v)
                else (error! (add "Unsupported binding form: " b) 'syntax))
              ) ; let*
            ) ; pb lambda
          ) ; pb
        (process-entry
          (lambda* process-entry (bvec b) (pb bvec (first b) (second b)))))
    (if (all? symbol? (map first bents))
      bindings
      (slices 2 (foldl process-entry [] bents)))))


(destructure '([[a] b] ((1) 2)))
(destructure (list {'a :a 'd :d} {:a "A" :b "B" :c "C" :d "D"}))



