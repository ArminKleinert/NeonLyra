(module queue-module
  (deque queue push ->deque ->queue enqueue dequeue peek pop)

  (def-type deque front back)
  
  (define (deque & xs)
    (make-deque xs '()))

  (define queue deque)
  (define queue? deque?)
  
  (define (enqueue q x)
    (make-deque (deque-front q) (cons x (deque-back q))))
  
  (define (dequeue q)
    (if (= (size (deque-front q)) 1)
      (make-deque (reverse (deque-back q)) '())
      (make-deque (cdr (deque-front q)) (deque-back q))))
  
  (define (enqueue-all q xs)
    (foldl enqueue q xs))
  
  (define (peek xs)
    (if (vector? xs)
      (vector-nth xs (- (size xs) 1))
      (first xs)))
  
  (define (pop xs)
    (if (vector? xs)
      (vector-range xs 0 (- (vector-size xs) 1))
      (rest xs)))
  
  (define (push xs e)
    (if (list? xs)
      (cons e xs)
      (add xs e)))
  
  (define (deque-eq? q0 q1)
    (id
      (if (deque? q1)
        (and (eq? (deque-front q0) (deque-front q1))
            (eq? (deque-back q0) (deque-back q1)))
        (eq? (->list q1) (->list q0)))))
  
  (def-impl ::deque first peek)
  (def-impl ::deque rest dequeue)
  (def-impl ::deque add enqueue)
  (def-impl ::deque append enqueue-all)
  
  (def-generic xs (->deque xs) (partial enqueue-all (deque)))
  (def-generic xs (->queue xs) ->deque)
  
  (def-impl ::deque sequence? (lambda (x) #t))
  
  (def-impl ::deque ->list (lambda (q) (append (deque-front q) (reverse (deque-back q)))))
  (def-impl ::deque ->vector (lambda (q) (append [] (deque-front q) (reverse (deque-back q)))))
  
  (def-impl ::deque size (lambda (q) (+ (size (deque-front q)) (size (deque-back q)))))
  
  (def-impl ::deque reverse
    (lambda (q)
      (if (empty? (deque-back q))
        (make-deque (reverse (deque-front q)) '())
        (make-deque (deque-back q) (deque-front q)))))

  (def-impl ::deque eq? deque-eq?)
)
