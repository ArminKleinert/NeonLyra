

; xs = (n,m,...)
; xs = (m) if only 1 element remains
(define (ack-h xs)
  (cond (= (size xs) 1) ; only result in list
          (car xs) ; m
        (= (car xs) 0) ; n is 0: (cons m-1 rest)
          (ack-h (cons 1 (cons (dec (cadr xs)) (cddr xs))))
        (= (cadr xs) 0) ; m is 0: (cons n+1 rest)
          (ack-h (cons (inc (car xs)) (cddr xs)))
        else ; Default: (cons n-1 (cons m (cons m-1 rest)))
          (ack-h (cons (dec (car xs)) (cons (cadr xs) (cons (dec (cadr xs)) (cddr xs)))))))

(define (ack m n)
  (ack-h (list n m)))

(def-macro (test-performance text expr)
  (list 'println! (list 'string-concat (list 'ljust  text 50) (list '->string (list 'measure! 'runs (list 'lambda () expr))))))

(let ((runs 50)
      (r (range 0 100)))
      

(test-performance "Many math ops:" (-> 5 (+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)))

(test-performance "Without -> :" (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ 5 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5))

(let ((l (lambda (n) (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ 5 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) n))))
  (test-performance "Many math ops (lambda):" (l 5 )))

(let ((ops (foldr compose id (list (partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)))))
  (test-performance "Same as partials with composition:" (ops 5)))

(test-performance "(ack 3 4)" (ack 3 4))
(test-performance "lazy sequences" (->> -500 (iterate inc) (filter (lambda (n) (> n 0))) (map inc) (filter odd?) (map inc) (map (partial * 211)) (remove (lambda (n) (= (rem n 5) 0))) (take 50)))

(load! "core/sort.lyra")
(let ((sequence (reverse (range 0 5000))))
  (test-performance "Sort 5000 elements:" (sort sequence)))

(load! "core/random.lyra")
(let ((sequence (range 0 5000)))
  (test-performance "Shuffle 5000 elements:" (shuffle sequence 0xC0FFEE)))
)


(comment
Times in milliseconds.

Tests with v0.0.7:
167.859757

Tests with generic eq?:
250.824882

After making all important functions generic:
370.53632

Tests with v0.0.8 and jRuby support:
Ruby: 370.876406
jruby: 720.529
Truffleruby: 1095.8115

Frozen names:
Ruby: 355.27617
jruby: 1073.5075
Truffleruby: 708.4105

IDs as keys for generics:
Ruby: 341.11100250000004

Native foldr and foldl:
Ruby: 273.103618
jruby: 562.018
Truffleruby: 827.8824999999999

After adding new tests:
Ruby: 302.417607
jruby: 626.0905
Truffleruby: 926.5335

After adding anonymous arguments (v0.0.9):
Ruby: 342.32527550000003

After adding anonymous arguments and performance improvements:
Ruby: 281.233253

After adding lazy lists but without actually using them:
Ruby: 233.50337

After making most functions lazy and adding iterate:
Ruby: 253.244277
jruby: 598.5474999999999
Truffleruby: 988.9205000000001

After fixing (if lazy ...) and changing how compound functions are initialized (0.1.0):
Ruby: 248.1495455
jruby: 552.375
Truffleruby: 961.738

After adding random.lyra and more sorting functions (Including many tests):
Ruby: 550.5251805
)

