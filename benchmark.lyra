

; xs = (n,m,...)
; xs = (m) if only 1 element remains
(define (ack-h xs)
  (cond (= (size xs) 1) ; only result in list
          (car xs) ; m
        (= (car xs) 0) ; n is 0: (cons m-1 rest)
          (ack-h (cons 1 (cons (dec (cadr xs)) (cddr xs))))
        (= (cadr xs) 0) ; m is 0: (cons n+1 rest)
          (ack-h (cons (inc (car xs)) (cddr xs)))
        else ; Default: (cons n-1 (cons m (cons m-1 rest)))
          (ack-h (cons (dec (car xs)) (cons (cadr xs) (cons (dec (cadr xs)) (cddr xs)))))))

(define (ack m n)
  (ack-h (list n m)))

(define (g n p)
  (cond (not (< 1 p)) 1
        (not (< p (dec n))) 1
        else (foldl (lambda (res q) (+ res (if (> q (- n p)) 0 (g (- n p) q)))) 1 (range 2 p))))

(define (9-billion-names rows)
  (foldl
    (lambda (res n)
      (string-append
        (apply string-concat res
          (map-eager
            (lambda (p) (string-append (->string (g n p)) " "))
            (range 1 n)))
        "\n"))
    ""
    (range 1 (inc rows))))

(define (test-set-stuff)
  (let ((r (range -199 200))
        (s (->set (xrange -199 200 1)))
        (s1 (->set (xrange 0 399 1))))
    (foldl
      (lambda (r x)
        (cond (= 0 x)
          (= x 0) (set-size s)
          (= x 1) (set-add s s1)
          (= x 2) (set-union s s1)
          (= x 3) (set-difference s s1)
          (= x 4) (set-intersection s s1)
          (= x 5) (set-includes? s x)
          (= x 6) (set-subset? s s1)
          (= x 7) (set-true-subset? s s1)
          (= x 8) (set-superset? s s1)
          (= x 9) (set-true-superset? s s1)
          (= x 10) (set->vector s)
          (= x 11) (set-eq? s s1)
          (= x 12) (set-size s)
          (= x 13) (set-add s s)
          (= x 14) (set-union s s)
          (= x 15) (set-difference s s)
          (= x 16) (set-intersection s s)
          (= x 17) (set-includes? s s)
          (= x 18) (set-subset? s s)
          (= x 19) (set-true-subset? s s)
          (= x 20) (set-superset? s s)
          (= x 21) (set-true-superset? s s)
          (= x 22) (set->vector s)
          (= x 23) (set-eq? s s)))
    0 r)))

(define (test-map-stuff)
  (let* ((r (range -199 400))
         (m (->map r))
         (m1 (->map (range 0 799))))
    (foldl
      (lambda (r x)
        (cond (= 0 x)
          (= x 0) (map-size m)
          (= x 1) (map-add m x x)
          (= x 2) (map-get m x)
          (= x 3) (map-set m x x)
          (= x 4) (map-remove m x)
          (= x 5) (map-keys m x)
          (= x 6) (map-merge m m1)
          (= x 7) (map-has-key? m x)
          (= x 8) (map-entries m)
          (= x 9) (map->vector m)
          (= x 9) (map-eq? m m1)
          (= x 10) (apply-to map-of r)
          (= x 11) (map-merge m m)))
      0 r)))

(def-macro (test-performance text expr)
  (list 'println! (list 'string-concat (list 'ljust  text 50) (list '->string (list 'measure! 'runs (list 'lambda () expr))))))

(let ((runs 50))

(test-performance "Many math ops:" (-> 5 (+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)(+ 5)(- 5)(* 5)(/ 5)))

(test-performance "Without -> :" (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ 5 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5))

(let ((l (lambda (n) (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ (/ (* (- (+ 5 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) 5) n))))
  (test-performance "Many math ops (lambda):" (l 5 )))

(let ((ops (foldr compose id (list (partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)(partial + 5)(partial - 5)(partial * 5)(partial / 5)))))
  (test-performance "Same as partials with composition:" (ops 5)))
  
(let ((s (->set (xrange -500 500 1)))
      (s1 (->set (xrange -250 750 1))))
  (test-performance "set operations" (test-set-stuff)))

(test-performance "map operations" (test-map-stuff))

(test-performance "(ack 3 4)" (ack 3 4))

(test-performance "lazy sequences" (->> -500 (iterate inc) (filter (lambda (n) (> n 0))) (map inc) (filter odd?) (map inc) (map (partial * 211)) (remove (lambda (n) (= (rem n 5) 0))) (take 50)))

(load! "core/sort.lyra")
(let ((sequence (reverse (range 0 5000))))
  (test-performance "Sort 5000 elements:" (sort sequence)))

(load! "core/random.lyra")
(let ((sequence (range 0 5000)))
  (test-performance "Shuffle 5000 elements:" (shuffle sequence 0xC0FFEE)))

(test-performance "9-billion-names (25):" (9-billion-names 25))
)


(comment
Times in milliseconds.

0.1.1
Ruby:
  Many math ops:                                    0.17283199999999999
  Without -> :                                      0.167156
  Many math ops (lambda):                           0.18175750000000002
  Same as partials with composition:                0.3615785
  (ack 3 4)                                         1270.993801
  lazy sequences                                    90.884589
  Sort 5000 elements:                               1123.7094325
  Shuffle 5000 elements:                            1250.69714
jruby:
  Many math ops:                                    1.259
  Without -> :                                      0.7795
  Many math ops (lambda):                           0.903
  Same as partials with composition:                1.6555
  (ack 3 4)                                         2373.7315
  lazy sequences                                    188.454
  Sort 5000 elements:                               1767.841
  Shuffle 5000 elements:                            1942.1085
truffleruby:
  Many math ops:                                    3.2715
  Without -> :                                      2.3735
  Many math ops (lambda):                           2.4485
  Same as partials with composition:                3.527
  (ack 3 4)                                         3539.3155
  lazy sequences                                    323.72400000000005
  Sort 5000 elements:                               2212.497
  Shuffle 5000 elements:                            2260.6495

0.1.2
Ruby:
  Many math ops:                                    0.181013
  Without -> :                                      0.226936
  Many math ops (lambda):                           0.185336
  Same as partials with composition:                0.385166
  (ack 3 4)                                         1522.117557
  lazy sequences                                    92.27283899999999
  Sort 5000 elements:                               1135.8074410000002
  Shuffle 5000 elements:                            1270.712288
jruby:
  Many math ops:                                    5.785
  Without -> :                                      5.718
  Many math ops (lambda):                           5.1209999999999996
  Same as partials with composition:                14.291
  (ack 3 4)                                         2619.4260000000004
  lazy sequences                                    294.57
  Sort 5000 elements:                               1832.3100000000002
  Shuffle 5000 elements:                            1986.322
truffleruby:
  Many math ops:                                    3.6170000000000004
  Without -> :                                      3.632
  Many math ops (lambda):                           3.837
  Same as partials with composition:                7.819000000000002
  (ack 3 4)                                         3860.883
  lazy sequences                                    757.476
  Sort 5000 elements:                               2667.729
  Shuffle 5000 elements:                            3184.793

0.1.3
Ruby:
  Many math ops:                                    0.174354
  Without -> :                                      0.170699
  Many math ops (lambda):                           0.1830095
  Same as partials with composition:                0.402227
  set operations                                    153.952123
  map operations                                    66.956069
  (ack 3 4)                                         1395.9497675
  lazy sequences                                    95.1766455
  Sort 5000 elements:                               1188.972549
  Shuffle 5000 elements:                            5665.627157
  9-billion-names (25):                             2049.2737935
jruby:
  Many math ops:                                    1.478
  Without -> :                                      1.4105
  Many math ops (lambda):                           1.6295
  Same as partials with composition:                4.679
  set operations                                    152.3055
  map operations                                    67.258
  (ack 3 4)                                         2519.9255
  lazy sequences                                    197.052
  Sort 5000 elements:                               1828.251
  Shuffle 5000 elements:                            6652.0645
  9-billion-names (25):                             2121.621
truffleruby:
  Many math ops:                                    2.377
  Without -> :                                      2.0745
  Many math ops (lambda):                           2.062
  Same as partials with composition:                4.1695
  set operations                                    70.2375
  map operations                                    122.561
  (ack 3 4)                                         3767.6895
  lazy sequences                                    330.4945
  Sort 5000 elements:                               2366.332
  Shuffle 5000 elements:                            4680.691
  9-billion-names (25):                             921.8655

)

