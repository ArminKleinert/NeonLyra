(module clj
  (when def defn fn
  (do begin)
  (slurp! file-read!)
  (spit! file-write!)
  (count size)
  (true #t)
  (false #f)
  (nil Nothing)
  (enumerate zip-to-index)
  (conj add)
  (distinct unique)
  (str string-concat)
  (not-any? none?)
  (every? all?)
  reduce reductions some some? some-fn
  nthrest nthnext next fnext ffirst nnext
  keep)

  (def-macro (when p & body)
    (list 'if p (cons 'begin (cons Nothing body)) (nothing)))

  (def-macro (def name val)
    (list 'define name val))

  (def-macro (defn name bindings & body)
    (cons 'define (cons (cons name (->list bindings)) body)))

  (def-macro (fn bindings & body)
    (cons 'lambda (cons (->list bindings) body)))

  (define (nthrest xs i) (drop i xs))
  (define (nthnext xs i) (let ((r (nthrest xs i))) (if (empty? r) Nothing r)))
  (define (next xs) (let ((r (rest xs))) (if (empty? r) Nothing r)))
  (define (fnext xs) (first (next xs)))
  (define (ffirst xs) (first (first xs)))
  (define (nnext xs) (next (next xs)))
  (define (nfirst xs) (next (first xs)))
  
  (define reduce
    (case-lambda* reduce
      ((f s xs) (foldl f s xs))
      ((f xs) (foldl1 f xs))))

  (define reductions
    (case-lambda* reductions
      ((f s xs) (scanl f s xs))
      ((f xs) (scanl1 f xs))))

  (define (some p xs)
    (first (drop-until p xs))); first returns Nothing on empty sequences.

  (define (some? x)
    (not (nothing? x)))

  ; For some reason, clojure returns nil if some gives negative results,
  ; but false for some-fn...
  (define (some-fn p & ps)
    (lambda (& xs)
      (->>
        (repeat xs)
        (zip-with drop-until (cons p ps))
        (remove empty?)
        first first)))
  
  (define (any? x)
    #t)
  
  (define (keep f xs)
    (remove nothing? (map f xs)))
)




