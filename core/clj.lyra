(module clj
  (when
  def
  defn
  fn
  (do begin)
  (slurp! file-read!)
  (spit! file-write!)
  (count size)
  (reduce foldl)
  (true #t)
  (false #f)
  (nil Nothing)
  (enumerate zip-to-index)
  nthrest nthnext next fnext ffirst nnext)

  (def-macro (when p & body)
    (list 'if p (cons 'begin (cons Nothing body)) (nothing)))

  (def-macro (def name val)
    (list 'define name val))

  (def-macro (defn name bindings & body)
    (cons 'define (cons (cons name (->list bindings)) body)))

  (def-macro (fn bindings & body)
    (cons 'lambda (cons (->list bindings) body)))
  
  (define (nthrest xs i) (drop i xs))
  (define (nthnext xs i) (let ((r (nthrest xs i))) (if (empty? r) Nothing r)))
  (define (next xs) (let ((r (rest xs))) (if (empty? r) Nothing r)))
  (define (fnext xs) (first (next xs)))
  (define (ffirst xs) (first (first xs)))
  (define (nnext xs) (next (next xs)))
  (define (nfirst xs) (next (first xs)))
)
