(module clj
  ()

;## Macro: when
;# when : expr -> expr* -> expr
;# Works as an if without an else branch. If the predicate does not hold true, Nothing is returned.
(defmacro (when p & body)
  (list 'if p (xcons 'begin Nothing body) Nothing))

;## Macro: def
;# def : symbol -> expr -> expr
;# Works as define for variables.
(defmacro (def name val)
  (list 'define name val))

(define (%defn name bindings body)
  (if (or (string? bindings) (map? bindings))
    (%defn name (car body) (cdr body)) ; ignore docstring or attr-map
    (list 'define name (xcons 'fn name bindings body))))
;## Macro: defn
;# defn : symbol -> sequence|string|map -> sequence? -> expr* -> expr
;# Works as define for functions. Does not support inlined documentation and meta-data.
;# (defn f [a b] ...)                 => (define (f a b) ...)
;# (defn f {meta-data} [a b] ...)     => (define (f a b) ...)
;# (defn f "documentation" [a b] ...) => (define (f a b) ...)
(defmacro (defn name bindings & body)
  (%defn name bindings body))

(define (%fn name bindings body)
  (cond
    (list? bindings) ; Probably multi-fn
      (%multifn name (cons bindings body))
    (vector? bindings)
      (cons 'lambda* (xcons name (->list bindings) body))
    else (error! "Syntax error: Invalid format for fn." 'syntax)))

(define (%multifn name body)
  (xcons 'case-lambda* name (map-eager (lambda (xs) (cons (->list (car xs)) (cdr xs))) body)))

;## Macro: fn
;# fn : (symbol|sequence -> expr*)+ -> expr
;# Defines a function, as lambda does, but can also create named funktions like lambda* or case-lambdas, depending on the form.
;# (fn [a b] ...)               => (lambda (a b) ...)
;# (fn f [a b] ...)             => (lambda* f (a b) ...)
;# (fn ([a] ...) ([a b] ...))   => (case-lambda ((a) ...) ((a b) ...))
;# (fn f ([a] ...) ([a b] ...)) => (case-lambda* f ((a) ...) ((a b) ...))
(defmacro (fn name & body)
  (cond
    (symbol? name)
      (%fn name (car body) (cdr body))
    (vector? name) ; no name, but actually bindings
      (%fn (gensym 'fn) name body)
    (list? name) ; multi-function
      (%multifn (gensym 'fn) (cons name body))
    else
      (error! "Syntax error: Invalid format for fn." 'syntax)))

(define (nthrest xs i) (drop i xs))
(define (nthnext xs i) (let ((r (nthrest xs i))) (if (empty? r) Nothing r)))
(define (next xs) (let ((r (rest xs))) (if (empty? r) Nothing r)))
(define (fnext xs) (first (next xs)))
(define (ffirst xs) (first (first xs)))
(define (nnext xs) (next (next xs)))
(define (nfirst xs) (next (first xs)))

(define reduce
  (case-lambda* reduce
    ((f s xs) (foldl f s xs))
    ((f xs) (foldl1 f xs))))

(define reductions
  (case-lambda* reductions
    ((f s xs) (scanl f s xs))
    ((f xs) (scanl1 f xs))))

(define (some p xs)
  (first (drop-until p xs))); first returns Nothing on empty sequences.

(define (some? x)
  (not (nothing? x)))

; For some reason, clojure returns nil if some gives negative results,
; but false for some-fn...
(define (some-fn p & ps)
  (lambda (& xs)
    (->>
      (repeat xs)
      (zip-with drop-until (cons p ps))
      (remove empty?)
      first first)))

(define (any? x)
  #t)

(define (keep f xs)
  (remove nothing? (map f xs)))

(define do begin)
(define slurp! file-read!)
(define spit! file-write!)
(define count size)
(define nil Nothing)
(define enumerate zip-to-index)
(define distinct unique)
(define str string-concat)
(define vec ->vector)
(define not-any? none?)
(define every? all?)
)


